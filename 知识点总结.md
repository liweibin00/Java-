# 基础班知识点总结

## Day 01 【前言、入门程序、常量、变量】

#### 1. Java语言用途

```
开发网站的后台业务逻辑，例如：传统行业和电商
```

#### 2. 十进制和二进制的转换规则

```
十进制转二进制：辗转相除法，一直到商为0为止，取余数，将余数倒着连接就是二进制

二进制转十进制：位权乘以二进制数，再相加
```

#### 3.计算机存储单元

```
最小的存储单元是字节，一个字节 = 8 bit，100Mbps ≈ 12MB/s

进制单位是1024
```

#### 4. Java的跨平台性？

```java
因为Java运行在虚拟机上，不同的系统对应不同版本的虚拟机（JVM）
```

#### 5. JDK、JRE和JVM

```
JDK：是开发工具包，能进行开发，运行环境

JRE：是java的运行环境

JVM：是java的核心，虚拟机

包含关系: jdk --> jre --> jvm
```

#### 6. 环境变量配置的意义

```
配置环境变量的意义是让操作系统知道去哪里找java命令，使计算机能够在任意目录下运行java和javac这两个命令
```

#### 7. Java程序编写的三个步骤

```
编写：程序员编写代码

编译：将我们编写的代码编程计算机能识别的代码

运行：运行字节码文件，.class文件，显示效果
```

#### 8. 常用命令提示符

| 功能               | 输入                        |
| ------------------ | --------------------------- |
| 切换盘符           | 盘符名称：                  |
| 进入文件夹         | cd  文件夹1\文件夹2\文件夹3 |
| 返回上一级         | cd ..                       |
| 直接回根路径       | cd \                        |
| 查看当前文件夹内容 | dir                         |
| 清屏               | cls                         |
| 退出               | exit                        |

#### 9. 注释及其格式

```
注释是对代码进行解释说明的文字，提高代码的可读性
```

> **java中的注释分三种：**
>
> - 单行注释:		// 文字
> 	 多行注释:		/*  文字 */
> 	 文档注释:		/** 文字 */

#### 10. 关键字

```
关键字：被java语言赋予了特殊的含义的单词，Java一共定义了50个关键字。

特点：（1）全部小写；（2）在不同的编辑器下关键字的颜色是不一样的

```

> 目前已学的关键字可分为4类：（更新至Day05课程）
>
> **定义数据类型**：class  byte  short  int  long  float  double  char  boolean  void
>
> **定义数据值类型**：true  false  null
>
> **定义流程控制**：if  else  switch  case  default  while  do  for  break  continue  return
>
> **其他类型**：public  static  new  package  import 

#### 11. 标识符及其定义规范

```
标识符：自己定义的单词

```

> **硬性要求：**
>
> 1. 标识符包含英文26字母（大小写）、数字0-9、$、_
> 2. 不能以数字开头
> 3. 不能是关键字

> **软性建议：**
>
> 1. 类名：大驼峰（单词的首字母全部大写）
> 2. 变量名：小驼峰（如果有多个单词，那么第一个单词首字母小写，后面单词首字母大写）
> 3. 方法名：小驼峰

#### 12. 数据类型

```
java是强类型语言, 对于每一种数据类型都规定了明确的取值范围。

数据类型分为两种：基本数据类型（四类八种）、引用数据类型（目前有String和数组）

```

|  四类  |    八种    | 字节数 |     表示范围     |
| :----: | :--------: | :----: | :--------------: |
|  整型  |    byte    |   1    |     -128~127     |
|  整型  |   short    |   2    |    正负3万多     |
|  整型  |  **int **  |   4    |    正负21亿多    |
|  整型  |    long    |   8    |    正负19位数    |
| 布尔型 |  boolean   |   1    |   true, false    |
| 字符型 |    char    |   2    | 一个字符'A'，'a' |
| 浮点型 |   float    |   4    |    正负38位数    |
| 浮点型 | **double** |   8    |   正负308位数    |

#### 13. 常量及其分类

```
常量：在程序的执行过程中, 其值不可以发生改变的量

```

> 1. 整数常量：所有整数
> 2. 浮点数常量：所有小数
> 3. 字符常量：被单引号括起来的内容, 里面只能装单个字
> 4. 字符串常量：被双引号括起来的内容
> 5. 布尔常量：true、false
> 6. 空常量：null

#### 14. 变量及其定义格式

```
变量：在程序的执行过程中, 其值在某个范围内可以发生改变的量。变量就像一个容器，可以不断修改其中的内容。

```

> **三种定义格式：**
>
> 1. 一步到位 ： `int a = 10；`
> 2. 分开定义，赋值： `int a；`   `a = 10；`
> 3. 简便格式： `int a = 10, b = 20, c = 30;`

> **变量需注意的细节：**
>
> 1. 变量不赋值，不能使用
> 2. 变量名不能重复定义
> 3. 变量赋值的范围，不能超过数据类型的最大表示范围
> 4. 变量有作用域，作用域是一对大括号
> 5. long类型数据需加上标识L，float类型数据需加上标识F



## Day 02 【数据类型转换、运算符、方法入门】

#### 1. 数据类型转换

```java
自动类型转换：是程序自动完成的，将小的数据类型转换成大的数据类型

强制类型转换：需要手动进行转换，将大的数据类型转换成小的数据类型  格式：int a = (int) 10.5;

```

#### 2. 精度损失和数据溢出

```
精度损失：当一个浮点数转为整数的时候，会发生精度损失，精度损失是直接舍弃小数部分

数据溢出：当一个表示范围大的数据类型强转为范围小的数据类型的时候，会发生数据溢出，造成部分数据丢失

```

#### 3.  运算时数据类型的转换规则

```java
范围小的类型向范围大的类型提升，byte、short、char 运算时直接提升为int

byte、short、char-->int-->long-->float-->double

```

#### 4.  编译器的两点优化

```java
优化一：对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器将会自动隐含地为
我们补上一个(byte)(short)(char)。

byte num1 = /*(byte)*/ 30; // 右侧没有超过左侧的范围

```

```java
优化二：在给变量进行赋值的时候，如果右侧的表达式当中全都是常量，没有任何变量，那么编译器javac将会直接将若干个常量表达式计算得到结果。但是注意：一旦表达式当中有变量参与，那么就不能进行这种优化了。

short a = 5;
short result = 5 + 8;  //编译通过
short result2 = a + 8; //编译报错

```

#### 5. 加号的三种用法

```
1.数值运算

2.和char类型参数运算的时候，会将char类型按照ASCII码表，查表找到对应的ASCII值，进行计算

3.用于字符串拼接，所有的数据类型和字符串进行拼接，都会变成字符串，也要看运算顺序

```

#### 6. ASCII码表

美国标准信息交换码(American Standard Code for Information Interchange ）

```
人类定义的一个字符和计算机中二进制存储的对照关系表，是所有编码表的核心。

编码表本身是字符和一个十进制数进行对应起来组成一张表格，需要记住：'0'-48，'A'-65，'a'-97

```

#### 7. 运算符

| 类型       | 符号                                           |
| :--------- | :--------------------------------------------- |
| 算数运算符 | `+` `-` `*` `/` `%` `++`  `--`                 |
| 赋值运算符 | `=` `+=` `-=` `*=` `/=` `%=`                   |
| 比较运算符 | `>` `<` `==` `>=` `<=` `!=`                    |
| 逻辑运算符 | `&` `|` `!` `&&` `||`                          |
| 三元运算符 | `数据类型 变量名 = 条件判断？表达式A：表达式B` |

> 运算符注意事项：
>
> 1. 除法，不会出现小数，会将小数部分舍弃
> 2. `+` 符号在遇到字符串的时候，表示**连接、拼接**的含义
> 3. 比较运算符返回的一定是布尔值true、false
> 4. 逻辑运算符符号两边一定是布尔值
> 5. 短路效果：如果已经得到结果，那么不会进行后面的操作（双写`&` `|` 得到短路效果）
> 6. 三元运算符的结果**必须被使用**，必须同时保证表达式A和表达式B都**符合左侧数据类型**的要求。

#### 8. ++、--的使用场景

```
单独操作: 就是自身完成+1或者是-1的动作;

参数运算：++在前, 先自增, 再赋值；++在后, 先赋值, 再自增。

```

#### 9. a += 1和a = a + 1的区别

```
a += 1 等价于 a = (a的数据类型)(a+1)，当中存在隐含了一个强制类型转换的过程

```

#### 10. 定义方法的好处

```
1. 将代码按照功能进行划分，提高代码的可读性

2. 提高代码的复用性

```

#### 11. 方法定义和调用的注意事项

```
1. 不能嵌套定义，方法中不能定义方法

2. 方法的执行顺序和定义顺序无关，和调用顺序有关

3. 方法不调用就不执行,main方法不能人为调用

4. 在定义方法形式参数的时候,参数需要用逗号隔开

```



## Day 03 【流程控制语句】

#### 1. if语句的三种格式

```
1.if--一种情况的判断

2.if...else两种情况的判断

3.if...else if...else多种情况判断

```

#### 2. 程序的健壮性

```
健壮性：我们需要尽可能多的考虑程序出现的情况，并给出解决方案

```

#### 3. switch语句的格式

```java
public static void main(String[] args) {
        int num = 1;
        switch (num) {
            case 1:
                System.out.println("春天");
                break;
            case 2:
                System.out.println("夏天");
                break;
            case 3:
                System.out.println("秋天");
                break;
            case 4:
                System.out.println("冬天");
                break;
           default:
                System.out.println("输入数据超出范围");
                break;
        }
}

```

> **switch语句的注意事项：**
>
> 1. switch可以接受的4+2种数据类型：4种基本：byte/short/char/int ；  2种引用：String/enum
> 2. case后面的表达式不能重复
> 3. case语句的穿透效果：没有break会往下穿透
> 4. switch语句很灵活，前后顺序可颠倒

#### 4. 三种循环语句的格式

##### （1）for循环

```java
格式： for(初始化语句;条件判断语句;步进语句){
		循环体;
	  }

示例：	for(int i = 1; i <= 10; i++){
		sop(i);	
	  }

```

##### （2）while循环

```java
格式：   初始化语句;
		while(条件判断语句){
		循环体;
		步进语句;
		}

示例：	  int i = 0;
		while(i <= 10){
  		  sop(i);
          i++;
		}

```

##### （3）do..while循环

```java
格式：	  初始化语句;
		do{
			循环体;
			步进语句;
		}while(条件判断语句);

示例：   int i = 0;
		do{
   			 sop(i);
    		 i++;
		}while(i <= 10);

```

#### 5. 三种循环语句的区别

```
1. for循环的初始化表达式出了循环不能使用，while循环可以使用

2. for循环和while循环条件不满足，一次不会执行；do...while循环无论如何执行一次

3. 当已知循环次数的情况下，建议使用for循环，不知道次数建议使用while循环

```

#### 6. break和continue

```
break：在switch语句中，表示遇到break，switch语句结束；在循环语句中，表示跳出循环，继续往下执行代码

continue：结束本次循环，进入下一次循环

```

#### 7. 死循环的格式

```java
while(true);

for(;;);

```



## Day 04 【Idea、方法】

#### 1. 什么是方法

```
方法就是经常使用的一部分代码抽取成的代码块

方法可以理解为工厂，给方法一些参数，方法换给我们一个结果

方法可以理解为模板，方法是写的通用的逻辑，可以重复调用多次，根据传入的参数不同，返回的结果也不同

```

#### 2. 方法的定义格式

```
修饰符  返回值类型  方法名（参数列表）{

	方法体；

	return  (返回值）；

}

```

#### 3. return的作用

```
1. 将返回值返回给方法的调用处

2. 结束方法 

```

#### 4.方法的调用的方式

```
1. 单独调用：适用于有返回值的和无返回值的方法，有返回值的方法单独调用没有意义

2. 打印调用：只适用于有返回值的方法，打印调用返回值结果只能使用一次

3. 赋值调用：只适用于有返回值的方法，返回值使用变量接收，可以使用多次

```

#### 5. 方法的执行流程

```
1. 以main方法为起点，虚拟机调用main方法，main方法中调用其他方法

2. 调用方法，传递参数

3. 将传递的实参给方法中定义的形参进行赋值 ，执行方法体

4. 使用return语句将返回值，返回给方法的调用处

```

#### 6. 方法的三要素

```
1. 返回值类型：看需求，说是想让你给出结果，还是直接在方法中打印

2. 参数列表：看该方法完成任务，需不需要外部提供的参数

3. 方法名：小驼峰命名规则，见名知意

```

#### 7. 方法的重载

```
方法的重载：是指方法名称相同，但参数列表不同的一组方法。用户希望相似的功能，只需要记一个方法名称。

```

> **方法重载的三个相关**：
>
> 1. 参数列表的个数
> 2. 参数列表的数据类型
> 3. 参数列表的参数顺序

> **方法重载的三个无关：**
>
> 1. 和参数的变量名称无关
> 2. 和方法的返回值类型无关
> 3. 和方法的修饰符无关

#### 8. IDEA 常用快捷键

| 功能                     | 快捷键                 |
| ------------------------ | ---------------------- |
| 调出结果窗口             | Alt + 4                |
| 自动导包+修正代码        | Alt + Enter            |
| 删除光标所在行           | Ctrl + Y               |
| 往下复制一行             | Ctrl + D               |
| 格式化代码               | Ctrl + Alt + L         |
| 自动生成常用方法         | Alt + Insert           |
| 移动当前代码行           | Alt + Shift + 上下箭头 |
| 选中一个变量的所有使用处 | Shift + F6             |
| 快速生成for循环          | XXX.fori               |



## Day 05 【数组】

#### 1. 什么是数组

```
数组是Java中的一种容器，用于存储数据

```

> 1. 数组中存储的数据类型一致
> 2. 数组是引用数据类型
> 3. 数组的长度一旦确定，不可改变

#### 2. 数组的初始化

```java
动态初始化：int[] array = new int[3];
静态初始化：int[] array = new int[]{1,2,3};
静态初始化的省略格式：int[] array = {1,2,3};
动态初始化的拆分：
int[] array;  
array = new int[3];
静态初始化拆分：
int[] array;  
array = new int[]{1,2,3};  
(拆分后不能使用省略格式进行初始化：array = {1,2,3})

```

#### 3. 索引

```
索引就是数组元素的编号，从0开始，到length-1为止

```

> 赋值：数组名[索引值] = 值；
>
> 访问：数据类型 变量名 = 数组名[索引值]；

#### 4. Java内存的5个组成部分

```
1.栈(Stack)：方法运行时使用的内存，比如main方法运行，进入方法栈中执行，存放方法中的局部变量。
2.堆(Heap)：存储对象或者数组，new来创建的，都存储在堆内存
3.方法区(Method Area)：存储可以运行的class文件
4.本地方法栈(Native Method Stack)：JVM在使用操作系统功能的时候使用，和开发无关
5.寄存器(pc Register)：与CPU相关，性能极高，和开发无关

```

#### 5. 数组越界索引异常

```
系统访问了数组中不存在的索引，将抛出数组越界索引异常。
(ArrayIndexOutOfBoundsException)

```

```java
public static void main(String[] args) {
	int[] arr = {1,2,3};
	System.out.println(arr[3]);
}

```

#### 6. 数组空指针异常

```
给数组赋值null之后，数组将不会保存数组的内存地址，也不允许再操作数组了，运行时会抛出空指针异常。
(NullPointerException)

```

```java
 public static void main(String[] args) {
	int[] arr = {1,2,3};
	arr = null;
	System.out.println(arr[0]);
｝

```

#### 7. 方法的参数类型区别

```
方法的参数为基本类型时,传递的是数据值，值不会受到影响；方法的参数为引用类型时,传递的是地址值，所以在方法中

将引用数据类型中的值进行修改，那么会永久性的修改

```

#### 8. 数组的直接打印

```
直接打印数组名称，得到的是数组对应的内存地址哈希值
[I@7575412c2f  
其中[代表数组，I代表int 

```

#### 9. 数组的内存执行流程

> 1. 编写代码，编译代码，生成.class字节码文件
> 2. 字节码文件，将信息加载到方法区中，方法区中有类的方法信息
> 3. JVM虚拟机去找程序的入口——main方法
> 4. main方法进栈执行
> 5. main方法中定义的变量，会在栈内存中生成
> 6. 在堆内存中，开辟了一块空间，将空间中的数值赋默认值，JVM将数组的内存地址赋值给引用类型变量
> 7. 打印数组名称，找到堆内存中的地址值.
> 8. 先通过数组名找到堆内存中的地址值，然后通过索引值找到对应的数据值，在数据值进行修改
> 9. main方法会出栈/弹栈
> 10. 堆内存中的两块区域，没有变量去引用了，堆内存中的内容会被JVM垃圾回收机制回收

#### 10. 数组的反转

```java
public static void main(String[] args) {
	int[] arr = { 1, 2, 3, 4, 5 };
	for (int min = 0, max = arr.length ‐ 1; min <= max; min++, max‐‐) {
	//利用第三方变量完成数组中的元素交换
		int temp = arr[min];
		arr[min] = arr[max];
		arr[max] = temp;
	}
	// 反转后，遍历数组
	for (int i = 0; i < arr.length; i++) {
		System.out.println(arr[i]);
	}
}

```





## Day 06 【类与对象、封装、构造方法】

#### 1. 面向对象

```
就是当我们需要做一件事情的时候，不是去自己亲力亲为的考虑每一个细节，而是找到能做这件事情的人，帮我们做事

在代码中，就是找到能完成这个功能的类，并调用这个类中的方法。

```

#### 2. 类与对象

```
类：是一个模板，描述了现实事物的信息

对象：是根据类这个模板生成的一个实体，会在堆内存中开辟空间

```

> 类是对象的模板，对象是类的实体

#### 3. 类描述的信息

```
属性：事物具备什么特征，在代码中叫做成员变量

行为：事物能做什么事情，在代码中叫做成员方法

```

#### 4. 对象的使用方式

```
导包：通常不用考虑，IDEA会进行自动导包

创建对象：根据类生成一个对象实例

使用：给对象中的成员变量进行赋值，调用方法

```

#### 5. 成员变量和局部变量区别

|            | 成员变量     | 局部变量     |
| ---------- | ------------ | ------------ |
| 类中位置   | 类中，方法外 | 方法内       |
| 作用范围   | 类中         | 方法中       |
| 初始化值   | 有默认值     | 无默认值     |
| 内存中位置 | 堆内存       | 栈内存       |
| 生命周期   | 随着对象存在 | 随着方法存在 |

#### 6. 封装

```
就是将细节隐藏起来，对外只暴露实现方式

（1）方法是一种封装

（2）private关键字也是一种封装

```

#### 7. private关键字

```
将成员变量私有，只允许本类访问，不允许外界访问，对外提供Getter/Setter方法

```

#### 8. this关键字

```
this代表所在类的当前对象的引用（地址值），即对象自己的引用。

方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。

```

#### 9. 成员变量的默认值

|          | 数据类型       | 默认值   |
| -------- | -------------- | -------- |
| 基本类型 | 整数           | 0        |
|          | 浮点数         | 0.0      |
|          | 字符           | '/u0000' |
|          | 布尔           | false    |
| 引用类型 | 数组，类，接口 | null     |

#### 10. 构造方法注意事项

> 1. 构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样
> 2. 构造方法不要写返回值类型，连void都不写
> 3. 构造方法不能return一个具体的返回值
> 4. 如果你不提供构造方法，系统会给出无参数构造方法。
> 5. 如果你提供了构造方法，系统将不再提供无参数构造方法。
> 6. 构造方法是可以重载的，既可以定义参数，也可以不定义参数。

#### 11. 标准代码——JavaBean

```java
public class Student {
    //成员变量
    private String name;
    private int age;
    //构造方法
    public Student() {}
    public Student(String name,int age) {
        this.name = name;
        this.age = age;
    }
    //成员方法
    public void setName(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public int getAge() {
        return age;
    }
}

```

#### 12. 对象的内存图流程

> 1. 方法区加载类的方法信息
> 2. JVM去找main方法，main方法进栈执行
> 3. 在栈内存中生成一个变量Phone one，在堆内存中开辟一块空间，内含成员变量和成员方法
> 4. 对成员变量进行赋值
> 5. 调用成员方法，方法进栈执行，执行完毕之后，方法出栈
> 6. 最后main方法出栈
> 7. 垃圾回收机制回收堆内存中的两块区域



## Day 07【Scanner类、Random类、ArrayList类】

#### 1. API的使用方式

> （Application Programming Interface） 应用程序编程接口

```
（1）看包路径 -->导包

（2）构造方法-->创建

（3）成员方法-->使用

```

#### 2. Scanner类使用步骤

```java
Scanner sc = new Scanner(System.in);

sc.nextInt();录入整数

sc.next();录入字符串，不含空格，Tab。有效字符之前的空格、Tab被视为无效；之后的空格、Tab视为结束符号

sc.nextLine();可以包含空格和Tab,只以回车为结束符号

```

#### 3. Random类使用步骤

```
Random ran = new Random();

ran.nextInt()；生成一个int范围的随机数

生成(a~b)范围的随机数: ran.nextInt(b-a+1)+a

```

#### 4. 匿名对象

```
匿名对象就是没有变量名接受的对象，new  类名（）；

优点：省略变量名，减少代码的编写

缺点：对象只能使用一次

```

#### 5. 数组与集合的不同

|              | 数组              | 集合            |
| :----------- | ----------------- | :-------------- |
| 运行期间长度 | 不可变            | 可变            |
| 存储数据类型 | 基本+引用数据类型 | 引用数据类型    |
| 直接打印     | 地址值            | 集合的内容      |
| 可操作方法   | 查、改            | 增、删、改、查  |
| 获取长度     | 数组名.length     | 集合名称.size() |

#### 6. ArrayList类

```
ArrayList集合是Java中的一种容器，底层是数组，默认初始长度是10

```

> 特点：
>
> 1. 长度是可变的
> 2. 只能存储引用数据类型，如果想存储基本数据类型，要使用其包装类
> 3. 直接打印显示的是集合的内容

#### 7. ArrayList中的常用方法

```java
public boolean add(E e)：向集合当中添加元素，参数的类型和泛型一致，返回值是boolean(Always true)
public E remove(int index)：从集合当中删除元素，参数是索引编号，返回值就是被删除掉的元素
public E set(int index, E element): 用指定的元素替代此列表中指定位置上的元素,返回被替代的元素
public E get(int index)：从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素
public int size(): 获取集合的尺寸长度，返回值就是集合中包含的元素个数

```

#### 8. 包装类

| 基本类型 | 基本类型包装类 |
| :------: | :------------: |
|   byte   |      Byte      |
|  short   |     Short      |
|   int    |    Integer     |
|   long   |      Long      |
|  float   |     Float      |
|  double  |     Double     |
|   char   |   Character    |
| boolean  |    Boolean     |

> 自动装箱：基本类型 -->包装类型
> 自动拆箱：包装类型 -->基本类型



## Day 08【String类、static关键字、Arrays类、Math类】

#### 1. String类的三个特点

```java
1. 字符串不变：字符串的值在创建后不能被更改。

2. 因为String对象是不可变的，所以它们可以被共享。

3. "abc" 等效于 char[] data={'a','b','c'}，底层原理是byte[]字节数组。 

```

#### 2. 创建字符串的1+3种方法

```java
一种直接创建：直接写上双引号，就是字符串对象

三种构造方法：
1. public String()：初始化新创建的 String对象，以使其表示空字符序列
2. public String(char[] array)：根据字符数组的内容，来创建对应的字符串
3. public String(byte[] array)：根据字节数组的内容，来创建对应的字符串

```

> 字符串常量池：直接写“ ”的字符串，在常量池中，如果常量池中有相同的字符串，那么不会创建新的，而是使用以前的。双引号直接写的字符串在常量池当中，new出来的不在池当中。

```java
public static void main(String[] args) {
        String s1 = "Java";
        String s2 = "Java";
        char[] chars = {'J', 'a', 'v', 'a'};
        String s3 = new String(chars);
        System.out.println("s1和s2是否直接相等" + (s1 == s2));  //true
        System.out.println("s1和s3是否直接相等" + (s1 == s3));	 //false

```

#### 3.String常用方法

##### 判断

```java
public boolean equals(Object anObject)：将此字符串与指定对象进行比较。
public boolean equalsIgnoreCase(String anotherString)：将此字符串与指定对象进行比较，忽略大小写。

```

##### 获取

```java
public int length () ：返回此字符串的长度。
public String concat (String str) ：将指定的字符串连接到该字符串的末尾。
public char charAt (int index) ：返回指定索引处的 char值。
public int indexOf (String str) ：返回指定子字符串第一次出现在该字符串内的索引。
public String substring (int begin) ：返回一个子字符串，从begin开始截取字符串到字符串结尾。
public String substring (int begin, int end) ：返回一个子字符串，从[begin,end)截取字符串。

```

##### 转换

```java
public char[] toCharArray () ：将此字符串转换为新的字符数组。
public byte[] getBytes () ：使用平台的默认字符集将该 String编码转换为新的字节数组。
public String replace (CharSequence target, CharSequence replacement) ：将与target匹配的字符串使用replacement字符串替换。

```

##### 分割

```java
public String[] split(String regex) ：将此字符串按照给定的regex（规则）拆分为字符串数组。

```

> String可以比，接，截，割，替，从内容获取索引，从索引获取内容
>
> equal, concat, substring, split, replace, indexof, charAt

#### 4. 正则表达式

> 正则表达式也是一个字符串，是专门解决字符串规则匹配的工具，用来定义匹配规则

|  表达式  |                     含义                     |
| :------: | :------------------------------------------: |
|    x     |                    字符 x                    |
|   \\\    |                  反斜线字符                  |
|  [abc]   |             a、b 或 c（简单类）              |
|  [^abc]  |       任何字符，除了 a、b 或 c（否定）       |
| [a-zA-Z] | a 到 z 或 A 到 Z，两头的字母包括在内（范围） |
|    \w    |            单词字符：[a-zA-Z_0-9]            |
|    X?    |             X，一次或一次也没有              |
|    X*    |                X，零次或多次                 |
|    X+    |                X，一次或多次                 |
|   X{n}   |                 X，恰好 n 次                 |
|  X{n,}   |                 X，至少 n 次                 |
|  X{n,m}  |        X，至少 n 次，但是不超过 m 次         |
|    ^     |                匹配输入的行首                |
|    $     |                匹配输入的行尾                |

#### 5. static关键字

```java
static关键字可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属于某个对象的。

也就是说，既然属于类，就可以不靠创建对象来调用了。

```

> 静态存储在方法区中，既不在堆中，也不在栈中（方法中有一块独立的静态区）

##### 类变量

```
当 static 修饰成员变量时，该变量称为类变量。该类的每个对象都共享同一个类变量的值。

任何对象都可以更改该类变量的值，也可以在不创建该类的对象的情况下对类变量进行操作。

```

##### 静态方法

```
当static修饰成员方法时，该方法称为类方法,习惯称为静态方法。建议使用类名来调用，而不需要创建类的对象。

```

> **静态方法调用的注意事项：**
>
> 1. 静态方法可以直接访问类变量和静态方法。
> 2. 静态方法不能直接访问普通成员变量或成员方法。反之，成员方法可以直接访问类变量或静态方法。
> 3. 静态方法中，不能使用this关键字。

##### 静态代码块

```
类中方法外，使用static修饰的代码块{ }。

```

> 当第一次用到本类时，静态代码块执行唯一的一次，优先于main方法和构造方法的执行。
>
> 作用：给类变量进行初始化赋值。

#### 6. Arrays类

```java
public static String toString(int[] a) ：返回指定数组内容的字符串表示形式。
public static void sort(int[] a) ：对指定的 int 型数组按数字升序进行排序。

```

```java
public static void main(String[] args) {
        int[] arr = {2,34,35,4,657,8,69,9};
        System.out.println(arr); // [I@2ac1fdc4
        System.out.println(Arrays.toString(arr)); // [2, 34, 35, 4, 657, 8, 69, 9]
        Arrays.sort(arr);
        System.out.println(Arrays.toString(arr)); //[2, 4, 8, 9, 34, 35, 69, 657]

```

> 备注：如果是数值，sort方法默认按照升序从小到大
> 如果是字符串，sort方法默认按照字母升序
> 如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持

```java 
// 冒泡排序法代码
 public static void mySort(int[] arr){
        for (int i = 1; i < arr.length; i++) {
            for (int j = i; j > 0 && arr[j] < arr[j-1] ; j--) {
                 int temp = arr[j];
       			 arr[j] = arr[j-1];
      			 arr[j-1] = temp;} } }

```

#### 7. Math类

```java
public static double abs(double a)：获取绝对值
public static double ceil(double a)：向上取整
public static double floor(double a)：向下取整
public static long round(double a)：四舍五入

```



## Day 09【继承、super、this、抽象类】

#### 1. 继承

```
就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。

子类可以直接访问父类中的非私有的属性和行为。

```

> **语法格式**：子类 extends 父类
>
> **继承的作用**：提高代码复用性，类与类之间产生了关系，是多态的前提。
>
> **继承的特点：**
>
> 1. 一个子类只能有一个直接父类，不能有多个直接父类
> 2. 继承可以支持多级继承，一个子类只能有一个直接父类，但可以有多个间接父类
> 3. 一个父类可以有多个子类

#### 2. 抽象类

```
对子类共性的内容进行抽取，有可能包含抽象方法的类

```

> **语法格式：**abstract关键字
>
> **抽象类的作用：**
>
> 1. 为子类提供便利：抽象类中可以定义一些方法，子类继承之后可以直接使用
> 2. 对子类进行约束：抽象类中的抽象方法，子类继承之后，必须重写，否则子类也是一个抽象类
>
> **注意事项：**
>
> 1. 抽象类不能创建对象，如果要创建，需要创建的是子类（抽象类的对象调用方法无方法体，无意义）
> 2. 抽象类中可以包含构造方法，用于初始化父类成员
> 3. 抽象类中可以没有抽象方法，但是只要类中有抽象方法，那这个类一定是一个抽象类
> 4. 子类继承抽象类必须重写全部抽象方法，否则该子类也是一个抽象类

#### 3. 继承后的特点

##### 成员变量重名

```
使用super关键字区分

```

##### 成员方法重名——重写(Override)

```
子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。

```

> **方法重写的注意事项：**
>
> 1. 必须保证父子类之间方法的名称相同，参数列表也相同。
> 2. @Override:写在方法前面，用来检测是不是有效的正确覆盖重写，也可以不写。
> 3. 子类方法的返回值必须【小于等于】父类方法返回值的范围。
> 4. 子类方法的权限必须【大于等于】父类方法的权限修饰符。
>
> 备注：public > protected >(default) > private，（default）不是关键字，是什么都不写，留空。

##### 构造方法

> **构造方法注意事项：**
>
> 1. 子类构造方法当中有一个默认隐含的“super()”调用，所以一定是先调用的父类构造，后执行的子类构造。
> 2. 子类构造可以通过super关键字来调用父类重载构造。
> 3. super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。

#### 4. super关键字的三种用法

```
（1）在子类的成员方法中，访问父类的成员变量

（2）在子类的成员方法中，访问父类的成员方法

（3）在子类的构造方法中，访问父类的构造方法

```

#### 5. this关键字的三种用法

```
（1）在本类的成员方法中，访问本类的成员变量

（2）在本类的成员方法中，访问本类的成员方法

（3）在本类的构造方法中，访问本类的另一种重载的构造方法

```

> 注意：super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。



## Day 10【接口、多态】

#### 1. 接口的定义

```java
接口，是Java语言中一种引用类型，是方法的集合，使用interface关键字，是一种公共的规范标准。

```

> 作用：（1）提供功能的拓展（2）提出约束
>
> 定义格式：public interface   接口名称{接口内容}
>
> 注意：接口也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。

#### 2. 接口包含的内容

##### 常量（Java 7）

```java
接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。

一旦赋值，不可以修改，从效果上看，这其实就是接口的【常量】。

```

> 注意事项：
>
> 1. 三个修饰符可以省略，但是不写也默认有
> 2. 接口当中的常量，必须进行赋值；不能不赋值。
> 3. 接口中常量的名称，使用完全大写的字母，用下划线进行分割：
>
> `public static final int NUM_OF_PEOPLE = 10`;

##### 抽象方法（Java 7）

```java
public abstract  返回值  方法名称（参数列表）;

```

> public abstract 可以省略不写

##### 默认方法(Java 8)

```java
public default 返回值类型 方法名称（参数列表）{方法体}

```

> 接口中的默认方法用于接口的升级和修改，可以保证所有的实现类不必被强制要求重写抽象方法。
>
> 如果重写使用重写的方法，如果不重写使用默认方法。

##### 静态方法(Java 8)

```java
public static 返回值类型 方法名称（参数列表）{方法体}

```

> 注意：不能通过接口实现类的对象来调用接口当中的静态方法！因为一个实现类可能实现多个接口，通过对象调用接口的静态方法有可能方法名重复导致冲突。正确用法：通过接口名称，直接调用其中的静态方法。

##### 私有方法(Java 9)

```java
（1）普通私有方法：private  返回值  方法名称（参数列表）{}

（2）静态私有方法：private static   返回值  方法名称（参数列表）{}

```

> 解决多个默认方法和静态方法代码重复度过高问题，同时避免该方法被接口的实现类使用。
>
> 从设计的角度讲，私有的方法是对默认方法和静态方法的辅助。

#### 3. 接口的多实现

```
一个类可以实现多个接口

```

> **注意事项：**
>
> 1. 有多个**抽象方法**时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。
> 2. 有多个**默认方法**时，实现类都可继承使用。如果默认方法有重名的，必须重写一次。
> 3. 存在同名的**静态方法**并不会冲突，原因是只能通过各自接口名访问静态方法。
> 4. 当一个类既继承一个父类，又实现若干个接口时，**父类中的成员方法**与接口中的默认方法重名，子类就近
>
> 选择执行父类的成员方法。

#### 4. 接口的特点

```
1. 一个接口能继承另一个或者多个接口，使用 extends 关键字，子接口继承父接口的方法。

2. 如果父接口中的默认方法有重名的，那么子接口需要重写一次。

3. 如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。

4. 接口中，没有构造方法，不能创建对象。

5. 接口中，没有静态代码块。

```

#### 5. 多态

```
父类引用指向子类对象，一个对象的多种形态

```

> **多态使用的前提条件**：必须以继承或者实现为前提条件（用父类或者接口去接收对象都行）
>
> **多态的表现形式：**父类类型  变量名 = new  子类（）;     接口类型  变量名 = new 实现类（）;

#### 6. 多态成员的访问

```
多态成员变量的访问方式：编译看左边，运行也看左边

（1）直接访问：看等号左边是谁就优先用谁，没有向上找

（2）间接访问：方法属于谁，就优先用谁，没有向上找

多态成员方法的访问方式：编译看左边，运行看右边

看等号右边对象创建的是谁，就优先用谁，没有向上找

```

#### 7. 多态的好处和弊端

```
好处：提高代码复用性

弊端：不能使用子类独有的方法

```

#### 8. 引用、对象、对象名称的区分

```
Animal a = new Cat();

引用：等号左侧的数据类型叫引用（Animal）

对象：等号右边new的就是对象（new Cat()）

对象名称：变量名称就叫对象名称（a）

```

#### 9. 向上转型和向下转型

```
向上转型：向上转型一定是安全的，因为左父右子，从小范围转向了大范围 

向下转型：子类类型  变量名 = （子类类型）父类对象；不安全

```

> 对象的向下转型，其实是一个【还原】的动作。由哪个子类转成的父类类型，再转回去要注意，不能转为其
>
> 他子类类型，否则会报错。(ClassCastException)

#### 10. instanceof 关键字

```java
格式：变量名 instanceof 数据类型

如果变量属于该数据类型，返回true；如果变量不属于该数据类型，返回false

```

> instanceof 可用于判断对象属于哪一个实例，一般都在方法中使用。
>
> 对传入的父类类型的对象进行实例判断，强转回子类，目的是调用子类特有的方法

```java
public class Test {
	public static void main(String[] args) {
		// 向上转型
		Animal a = new Cat();
		if (a instanceof Cat){
			Cat c = (Cat)a;
			c.catchMouse(); // 调用的是 Cat 的 catchMouse
		} else if (a instanceof Dog){
			Dog d = (Dog)a;
			d.watchHouse(); // 调用的是 Dog 的 watchHouse

```



## Day 11【final、权限、内部类、引用类型】

#### 1. final 关键字

```
被final关键字修饰的类、方法和变量不可改变。有以下四种主要用法：

```

##### 修饰类

```java
final class 类名 {
}

```

##### 修饰方法

```java
修饰符 final 返回值类型 方法名(参数列表){
	//方法体
}

```

##### 修饰局部变量

```java
因为局部变量无初始化默认值，可以先定义后赋值。{final int a; a = 10;}

```

##### 修饰成员变量

```java
1. 由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了。{final int a = 10;}

2. 对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值，二者选其一。

3. 必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值。

```

#### 2. 权限修饰符

|                | public | protected | (default) | private |
| :------------: | :----: | :-------: | :-------: | :-----: |
|    同一类中    |   √    |     √     |     √     |    √    |
|    同一包中    |   √    |     √     |     √     |         |
|  不同包的子类  |   √    |     √     |           |         |
| 不同包的无关类 |   √    |           |           |         |

#### 3. 成员内部类

```java
定义在类中方法外的类。
class 外部类 {
	class 内部类{
	
	}
}

```

> **访问特点**：
>
> 1. 内部类可以直接访问外部类的成员，包括私有成员。
> 2. 外部类要访问内部类的成员，必须要建立内部类的对象。
> 3. 创建内部类对象格式：`外部类名.内部类名 对象名 = new 外部类型().new 内部类型()；`

> **注意：**
>
> 1. 内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号 。比如，Outer$Heart.class
> 2. 如果内部类和外部类的变量出现了重名现象，那么在内部类调用外部类变量的格式是：
>
> `外部类名称.this.对象名`

```java
public class Outer {
    int num = 10; // 外部类的成员变量
    public class Inner {
        int num = 20; // 内部类的成员变量
        public void methodInner() {
            int num = 30; // 内部类方法的局部变量
            System.out.println(num); // 30 局部变量，就近原则
            System.out.println(this.num); // 20 内部类的成员变量
            System.out.println(Outer.this.num); // 10 外部类的成员变量
        }
    }
}

```

#### 4. 类的权限修饰符

```
定义一个类的时候，权限修饰符规则：

1. 外部类：public/(default)

2. 成员内部类：四个都行

3. 局部内部类：什么都不能写

```

#### 5. 局部内部类的final问题

```java
//局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】。
public void methodOuter() {
	int num = 10; // 所在方法的局部变量,从Java 8+开始,只要局部变量事实不变,那么final关键字可以省略			
	class MyInner {
		public void methodInner() {
		System.out.println(num);
    	}
	}
}

```

> **原因：**
>
> 1. new出来的对象在堆内存当中。
> 2. 局部变量是跟着方法走的，在栈内存当中。
> 3. 方法运行结束之后，立刻出栈，局部变量就会立刻消失。
> 4. 但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。

#### 6. 匿名内部类

```
是内部类的简化写法。它的本质是一个带具体实现的【父类或者父接口的】匿名的子类对象。

```

```java
//格式
new 父类名或者接口名(){
	// 方法重写
	@Override
	public void method() {
		// 执行语句
	}
};

```

> 匿名内部类特点：
>
> 匿名内部类的好处：不用编写实现类，就能创建实现类对象。
>
> 匿名内部类的弊端：创建的这个实现类对象，模板只能使用一次。
>
> 匿名内部类和匿名对象不是一回事，但是可以【匿名内部类】+【匿名对象】组合使用



# 就业班知识点总结

## Day01【Object类、常用API】

#### 1. Object类

```java
java.lang.Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。如果一个类没有特别指定父类， 那么默认则继承自Object类。
```

#### 2. toString方法

```
toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。
直接打印对象的名字，其实就是调用对象的toString方法。toString方法可以通过快捷键快速覆盖重写。
```

#### 3. equals方法

```java
调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。
默认进行的比较是 == 运算符的对象地址比较，只要不是同一个对象，结果必然为false。
希望进行对象内容的比较时，可以通过重写进行对象内容的比较：

@Override
    public boolean equals(Object o) {
        // 如果对象地址一样，则认为相同
        if (this == o) return true;  
        // 如果参数为空，或者类型信息不一样，则认为不同
        if (o == null || getClass() != o.getClass()) return false;
        //向下转型
        Student student = (Student) o;
        // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果
        return age == student.age && Objects.equals(name, student.name);}
```

#### 4. Objects类

```
在JDK7添加了一个Objects工具类，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。
```

> `public static boolean equals(Object a, Object b)` :判断两个对象是否相等

```java
//源码
public static boolean equals(Object a, Object b) {
	//短路与，若a为null，则避免了a.equals(b)的执行
    return (a == b) || (a != null && a.equals(b));
}	
```

#### 5. Date类

```
表示特定的瞬间，精确到毫秒。
```

> 注意：
>
> 1. 时间原点：1970年1月1日 00:00:00（英国格林威治时间）
> 2. 中国属于东八区，会把时间增加8个小时

> 两个构造方法：
>
> 1. Date():返回当前时间的日期对象
> 2. Date(long date):返回一个从1970年1月1日 0点0分0秒 + 毫秒值 所对应的日期对象
>
> 一个成员方法：
>
> 1. getTime():将一个日期对象，转为对象的毫秒值表示

#### 6. DateFormat类

```
DateFormat用于将日期对象格式化成指定的字符串表示，或者将一个字符串解析成Date对象。
```

> 构造方法：public SimpleDateFormat(String pattern)
>
> 格式化：按照指定的格式，从Date对象转换为String对象： `public String format(Date date)`
>
> 解析：按照指定的格式，从String对象转换为Date对象： `public Date parse(String source)`

**格式规则**

| 字母 |     日期或时间元素     |
| :--: | :--------------------: |
|  y   |           年           |
|  M   |       年中的月份       |
|  D   |       年中的天数       |
|  d   |      月份中的天数      |
|  E   |      星期中的天数      |
|  H   | 一天中的小时数（0-23） |
|  m   |     小时中的分钟数     |
|  s   |      分钟中的秒数      |
|  S   |         毫秒数         |

#### 7. Calendar类

```
Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。
```

> **常用方法：**
>
> 1. `public static Calendar getInstance()`： 通过静态方法创建对象
> 2. `public int get(int field)`：返回给定日历字段的值
> 3. `public abstract void add(int field, int amount)` ：根据日历的规则，为给定的日历字段添加或减去指定的时间量。
> 4. `public Date getTime() `：返回一个表示此Calendar时间值(从历元到现在的毫秒偏移量)的Date对象。
> 5. `public void set(int field, int value) `：将给定的日历字段设置为给定值。 （也可以同时设置年月日：`set(int year, int month, int day)`）

Calendar类中提供很多成员常量，代表给定的日历字段：

|    字段值    |                          含义                          |
| :----------: | :----------------------------------------------------: |
|     YEAR     |                           年                           |
|    MONTH     |    月（月份特殊，西方是0-11表示12个月，可以+1使用）    |
| DAY_OF_MONTH |                    月中的天（几号）                    |
|     HOUR     |                     时（12小时制）                     |
| HOUR_OF_DAY  |                     时（24小时制）                     |
|    MINUTE    |                           分                           |
|    SECOND    |                           秒                           |
| DAY_OF_WEEK  | 周中的天（西方是从星期日开始每周的第一天，可以-1使用） |

#### 8. 日期、字符串、毫秒值和日历的相互转换

```java
              SimpleDateFormat.parse(s)                 Date.getTime(d)    
	字符串		------------------------>	  日期	----------------------->   毫秒值
   (String)   <------------------------    (Date)  <-----------------------   (long)
             SimpleDateFormat.format(d)   /|\   |          new Date(l)
                                           |    |
                                getTime()  |	|  setTime(Date date)
                                           |	|   
                                           |   \|/
                                       日历（Calendar）

```

> **Date类是另外三种时间格式连接的桥梁，相互之间转换时都需要通过Date类。**

#### 9. System类

```java
public static long currentTimeMillis() ：返回以毫秒为单位的当前时间，经常用来测试程序性能。
public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) ：将源数组中指定的数据拷贝到目标数组中。数组的拷贝动作是系统级的，性能很高。    

```

| 参数名称 | 参数类型 | 参数含义             |
| -------- | -------- | -------------------- |
| src      | Object   | 源数组               |
| srcPos   | int      | 源数组索引起始位置   |
| dest     | Object   | 目标数组             |
| destPos  | int      | 目标数组索引起始位置 |
| length   | int      | 复制元素个数         |

#### 10. StringBuilder类

```
StringBuilder又称为可变字符序列，它是一个类似于String的字符串缓冲区，支持可变的字符串，可以提高字符串的操作效率。底层也是一个数组，但是没有被final修饰，可以改变长度在数组中加入新内容。

```

> 构造方法：
>
> 1. `public StringBuilder()` ：构造一个空的StringBuilder容器。
> 2. `public StringBuilder(String str) `：构造一个StringBuilder容器，并将字符串添加进去。  
>
> 常用方法：
>
> 1. public StringBuilder append(...) ：添加任意类型数据的字符串形式，并返回当前对象自身。 
> 2. public String toString() ：将当前StringBuilder对象转换为String对象。 

#### 11. 基本类型与字符串之间的转换

> **基本类型转换为String**
>
> 1. 基本类型的值 + ""  (推荐方法）
> 2. `static String toString(基本数据类型):String s = Integer.toString(int i)`
> 3. `static String valueOf(基本数据类型):String s = String.valueOf(int i)`
>
> **String转换为基本类型**
>
> 除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型。
>
> 例如：Integer类: `static int parseInt(String s)`



## Day02【Collection、泛型】

#### 1. Collection

```java
单列集合类的根接口，有两个重要的子接口，分别是java.util.List和java.util.Set

```

> **List**
>
> 特点：元素有序、元素可重复
>
> 主要实现类：`java.util.ArrayList`和`java.util.LinkedList`

> **Set**
>
> 特点：元素无序，而且不可重复
>
> 主要实现类：`java.util.HashSet`和`java.util.LinkedHashSet`

#### 2. 集合和数组的区别

> **长度不同**
>
> - 集合：集合的长度是可变的，因为集合的底层就是数组，当增删元素的时候，会进行数组的扩容
> - 数组：数组的长度在运行期间不可变，一旦创建，就固定

> **存储的数据类型不同**
>
> - 集合：只能存储引用数据类型，如果想存储基本数据类型，需要存储对应的包装类
> - 数组：基本数据类型和引用数据类型都可以存储

#### 3. Collection 常用功能

```
Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合:

```

- `public boolean add(E e)`：  把给定的对象添加到当前集合中 。
- `public void clear()` :清空集合中所有的元素。
- `public boolean remove(E e)`: 把给定的对象在当前集合中删除。
- `public boolean contains(E e)`: 判断当前集合中是否包含给定的对象。
- `public boolean isEmpty()`: 判断当前集合是否为空。
- `public int size()`: 返回集合中元素的个数。
- `public Object[] toArray()`: 把集合中的元素，存储到数组中。

#### 4.  Iterator接口

```
【迭代器】Iterator是一种通用的Collection集合元素的获取方式，通过判断集合中是否有元素，有则取出，继续判断，直到把集合中的元素全部取出为止。

```

> 获取迭代器的方法：
>
> - `collection.iterator()`:由于接口不能直接实例化，使用集合的Iterator方法获取
>
> 常用的两个方法：
>
> - `public E next()`:返回迭代的下一个元素。
> - `public boolean hasNext()`:如果仍有元素可以迭代，则返回 true。
>
> **并发修改异常**：迭代器的底层实现原理，运用到指针。在使用迭代器的过程中，修改了集合的长度，就会抛出该异常。使用Iterator接口的一个子接口ListIterator接口可以解决这个问题。

```java
//代码展示：
public static void main(String[] args) {
	Collection<String> coll = new ArrayList<String>();
	Iterator<String> it = coll.iterator(); //通过集合获取迭代器
	while(it.hasNext()){ //判断是否有迭代元素
		String s = it.next();//获取迭代出的元素
		System.out.println(s);}}

```

#### 5. ListIterator接口

```
Iterator接口有一个子接口ListIterator接口，其中定义了add方法和remove方法，可以对集合添加\删除元素。由迭代器自己添加\删除的不会抛出异常。

```

> 使用步骤：
>
> 1. 创建的集合首先不能使用Collection，因为Collection获取不了ListIterator接口，需要使用List接口获取ListIterator接口实现类
> 2. 调用listIterator（）方法，获取listIterator接口实现类
> 3. 使用hasNext和next方法进行迭代
> 4. 使用接口实现类的add方法进行添加，remove方法进行删除元素。注意：不要使用集合进行添加删除

```java
//代码展示
public static void main(String[] args) {
	List<String> list = new ArrayList<>();
    list.add("黑马");
	ListIterator<String> lit = list.listIterator();
	while (lit.hasNext()) {
		String s = lit.next();
		System.out.println(s);
        if ("黑马".equals(s)) {
			lit.add("金马");}}

```

#### 6. 增强for

```java
增强for循环是基于迭代器设计的一种高级for循环，专门用于遍历数组和集合。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。格式：
for(元素的数据类型  变量 : Collection集合or数组){ 
  	//写操作代码
}

```

#### 7. 泛型

```
在定义类或方法时，对于未知类型的数据进行占位，用于后期接收数据类型，以便预支使用的一种未知的数据类型。

```

> 泛型的好处：
>
> 1. 避免了类型转换的麻烦，使用API时更加直观简洁。
> 2. 把运行期异常，提升到了编译期

##### 含有泛型的类

> 定义格式：`修饰符 class 类名<代表泛型的变量> {}`
>
> 确定泛型：在创建对象的时候

##### 含有泛型的方法

> 定义格式：`修饰符 <代表泛型的变量> 返回值类型 方法名(参数){}`
>
> 确定泛型：调用方法时

##### 含有泛型的接口

> 定义格式：`修饰符 interface 接口名<代表泛型的变量> {}`
>
> 确定泛型：1、定义类时确定泛型的类型； 2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型

#### 8. 泛型通配符

```
不知道使用什么类型来接收的时候,此时泛型可以使用“?”表示,“?”表示未知通配符。
但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。

```

> **受限泛型**：泛型没有继承概念，JAVA的泛型中可以指定一个泛型的上限和下限。
>
> **泛型的上限**：
>
> - 格式： `类型名称 <? extends 类 > 对象名称`
> - 意义： `只能接收该类型及其子类`
>
> **泛型的下限**：
>
> - 格式： `类型名称 <? super 类 > 对象名称`
> - 意义： `只能接收该类型及其父类型`



## Day03【List、Set、数据结构、Collections】

#### 1. 数据结构

##### 栈

```
stack,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作

```

> **特点：先进后出**
>
> - 压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。
> - 弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。

##### 队列

```
也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。

```

> **特点：先进先出**

##### 数组

```
数组是有序的元素序列，在内存中开辟一段连续的空间，并在此空间存放元素

```

> **特点：有索引值，查询快，增删慢**

##### 链表

```
链表中的每一个元素也称之为一个节点，一个节点包含了一个数据源，两个指针域（存储地址）：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。

```

> **特点：查询慢，增删快**
>
> - 单项链表：链表中只有一条链，不能保证元素的顺序（存储元素和取出元素的顺序可能不一致）
> - 双向链表：链表中有两条链子，有一条链子是专门记录元素的顺序，是一个有序的集合

##### 红黑树

```
是一种比较平衡的二叉树

```

> **特点：速度特别快，**趋近平衡树，查询叶子节点最大次数和最小次数不能超过2倍
>
> 约束：
>
> 1. 节点可以是红色的或者黑色的
> 2. 根节点是黑色的
> 3. 叶子节点(特指空节点)是黑色的
> 4. 每个红色节点的子节点都是黑色的
> 5. 任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同

#### 2. List 接口

> 特点：
>
> 1. 有序的集合,存储元素和取出元素的顺序是一致的(存储123 取出123)
> 2. 有索引,包含了一些带索引的方法
> 3. 允许存储重复的元素

```java
常用方法：
    - public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。
    - public E get(int index):返回集合中指定位置的元素。
    - public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。
    - public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。

```

#### 3. LinkedList 集合

```
LinkedList是一个双向链表，查询慢，增删快，包含了大量操作首尾元素的方法。

```

```java
    - public void addFirst(E e):将指定元素插入此列表的开头。
    - public void addLast(E e):将指定元素添加到此列表的结尾。
    - public E getFirst():返回此列表的第一个元素。
    - public E getLast():返回此列表的最后一个元素。
    - public E removeFirst():移除并返回此列表的第一个元素。
    - public E removeLast():移除并返回此列表的最后一个元素。
    - public E pop():从此列表所表示的堆栈处弹出一个元素。
    - public void push(E e):将元素推入此列表所表示的堆栈。
    - public boolean isEmpty()：如果列表不包含元素，则返回true。

```

#### 4. HashSet 集合

```
是Set接口的一个实现类，存储的元素不可重复，并且元素都是无序的(即存取顺序不一致),没有索引,不能使用普通的for循环遍历。HashSet根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。

```

> **HashSet集合存储数据的结构（哈希表）**：
>
> - jdk1.8版本之前：哈希表 = 数组 + 链表
> - jdk1.8版本之后：哈希表 = 数组 +链表/红黑树；
>
> （当链表长度超过阈值（8）时，将链表转换为红黑树提高查询的速度）

#### 5. LinkedHashSet 集合

```
HashSet是无序的，LinkedHashSet是有序的

```

> 特点：底层是一个哈希表（数组+链表/红黑树）+ 链表：多了一条链表(记录元素的存储顺序)，保证元素有序

#### 6. 重写HashCode()方法

> **为什么需要重写HashCode()方法？**
>
> 如果两个对象需要判断是否内容相同，可以调用equals方法进行比较，但如果一个对象的字段过多，那就会偏频繁的进行字段的比较，非常的耗费性能。我们可以对Object类继承过来的hashCode方法进行覆盖重写，不让他生成地址值，而是**根据我们对象的内容**，生成hash值进行比较。因为比较hash值比equals方法容易得多。如果hash值相同，再调用equals方法进行内容比较。

> **哈希值：**是一个十进制的整数，由系统随机给出(就是对象的地址值，是一个逻辑地址，是模拟出来得到地址，不是数据实际存储的物理地址)

> **重写HashCode()进行比较的步骤：**
>
> 1. 重写Object类中继承过来的HashCode()方法，自定义，根据对象的内容生成的哈希值
> 2. 我们在进行集合元素存储的时候，比如向HashSet集合添加元素的时候，会先调用HashCode()方法，生成哈希值，不同对象生成的哈希值可能相同（虽然概率比较低）
> 3. 哈希值不同，对象的内容肯定不同；哈希值相同，对象的内容有可能相同，有可能不同
> 4. 比较哈希值，如果不同，直接存；如果相同，再调用equals方法进行内容比较

#### 7. 可变参数

```java
当方法的参数列表数据类型已经确定，但是参数的个数不确定，就可以使用可变参数
格式：修饰符 返回值类型 方法名(参数类型... 形参名){ }

```

> 原理：可变参数底层就是一个数组，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数，传递的参数个数，可以是0个（不传递），1,2,…多个

> 注意事项：
>
> 1. 一个方法的参数列表，只能有一个可变参数
> 2. 如果方法的参数有多个，那么可变参数必须写在参数列表的末尾
> 3. 可变参数的终极写法：Object...obj 

#### 8. Collections 工具类

```java
public static <T> boolean addAll(Collection<? super T> c, T... elements)：
往集合中添加一些元素
public static void shuffle(List<?> list)：打乱集合顺序
public static void sort(List<T> list)（<T extends Comparable<? super T>>）：
根据元素的自然顺序对指定列表按升序进行排序
public static void sort(List<T> list, Comparator<? super T> c)：
根据指定比较器产生的顺序对指定列表进行排序

```

#### 9. Comparable/Comparator 接口

> **Comparable和Comparator的区别：**
>
> - Comparable：自己(this)和别人(参数)比较,在源代码类中需要实现Comparable接口，重写比较的规则compareTo方法，耦合度太高
> - Comparator：在需要做排序的时候去选择的Comparator，相当于找一个第三方的裁判
> - 排序规则：this - 参数：升序；参数 - this：降序

```java
//Comparable使用示例，在源码类中实现Comparable接口
public class People implements Comparable<People> {
    String name;
    int age;
    @Override
    public int compareTo(People o) {
        return this.age - o.age;
    }}

```

```java
//Comparator使用示例，在Collections.sort方法中实现Comparator接口的匿名内部类
 Collections.sort(list, new Comparator<People>() {
            @Override
            public int compare(People o1, People o2) {
                return o1.age - o2.age;
            }
        });

```

```java
//Comparator如果想实现更多规则，示例如下：
Collections.sort(list, new Comparator<People>() {
            @Override
            public int compare(People o1, People o2) {
                int result =  o1.age - o2.age;
                if (o1.age - o2.age == 0) {
                    result = o1.name.charAt(0) - o2.name.charAt(0);
                }
                return result;
            }
        });

```



## Day04【Map、Debug】

#### 1. Map接口

```
Collection 中的集合称为单列集合， Map 中的集合称为双列集合。

```

> 特点：
>
> 1. 是一个双列集合，一个元素包含两个值（一个key，一个value）
> 2. Map集合中的元素，key和value的数据类型可以相同，也可以不同
> 3. Map集合中的元素，key是不允许重复的，value是可以重复的
> 4. Map集合中的元素，key和value是一一对应的

#### 2. Map的常用子类

> **HashMap：**存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需
> 要重写键的hashCode()方法、equals()方法。
>
> **LinkedHashMap：**存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。
>
> **HashTable：**底层也是一个哈希表，是一个线程安全的集合，单线程集合，速度慢。不能存储空值，空键。Hashtable和Vector集合一样，在jdk1.2版本之后被更先进的集合取代了。

#### 3. Map的常用方法

```java
public V put(K key, V value) : 把指定的键与指定的值添加到Map集合中。
//返回值V的说明：存储键值对的时候，key不重复，返回值V是null;key重复，会使用新的value替换map中重复的value，返回被替换的value值
public V remove(Object key) : 把指定的键所对应的键值对元素在Map集合中删除，返回被删除元素的值。如果不存在指定的键，则返回空。
public V get(Object key) 根据指定的键，在Map集合中获取对应的值。如果不存在指定的键，则返回空。
public boolean containsKey(Object key): 集合中是否包含指定的键
public Set<K> keySet() : 获取Map集合中所有的键，存储到Set集合中。
public Set<Map.Entry<K,V>> entrySet() : 获取到Map集合中所有的键值对对象的集合(Set集合)。

```

#### 4. Entry键值对对象

```
一对key(键)+value(值)称做Map中的一个Entry(项)，Entry将键值对的对应关系封装成了对象，即键值对对象。

```

```java
//Entry相关方法
public K getKey() ：获取Entry对象中的键。
public V getValue() ：获取Entry对象中的值。
在Map集合中也提供了获取所有Entry对象的方法：
public Set<Map.Entry<K,V>> entrySet() : 获取到Map集合中所有的键值对对象的集合(Set集合)。

```

#### 5. Map的两种遍历方式

```java
public static void main(String[] args) {
        Map<Integer, String> map = new HashMap<>();
        map.put(1, "one");
        map.put(2, "two");
        map.put(3, "thr");
		//keySet遍历方式
        for (Integer key : map.keySet()) {
            System.out.println(key + " = " + map.get(key));
        }
    	//entrySet遍历方式（更快）
  		Set<Map.Entry<Integer, String>> entries = map.entrySet();
        for (Map.Entry<Integer, String> entry : entries) {
            System.out.println(entry.getKey + "=" + entry.getValue());
        }

```

#### 6. JDK9对集合添加的优化

```
Java 9给List接口，Set接口和Map接口增加了一个静态的方法of，可以给集合一次性添加多个元素。

```

```java
public class HelloJDK9 {
	public static void main(String[] args) {
		Set<String> str1=Set.of("a","b","c");
		//str1.add("c");这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合
		System.out.println(str1);
		Map<String,Integer> str2=Map.of("a",1,"b",2);
		System.out.println(str2);
		List<String> str3=List.of("a","b");
		System.out.println(str3);
	}}

```

> **注意：**
>
> 1. of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如
>    HashSet，ArrayList等；
> 2. of方法的返回值时一个不能改变的集合，集合不能再使用add,put方法添加元素，会抛出异常；
> 3. Set接口和Map接口在调用of方法的时候，不能有重复的元素，否则会抛出异常

#### 7. Debug追踪

```
使用IDEA的断点调试功能，可以让代码逐行执行，查看代码执行的过程，调试程序中出现的bug。

```

> **使用方式：**
>
> 1. 在行号的右边，鼠标左键单击，添加断点（哪里有bug添加到哪里）
> 2. 右键选择Debug执行程序
> 3. 程序就会停留在添加的第一个断点处
>
> **执行程序：**
>
> - F7：逐句执行程序（进入到方法中）
> - F8：逐行执行程序（不进入方法中）
> - Shift + F8：跳出方法
> - F9：跳到下一个断点，如果没有下一个断点，那么就结束程序
> - Ctrl + F2：退出Debug模式，停止程序



## Day05【异常、线程】

#### 1. 异常

```
在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处
理异常的方式是中断处理。

```

> 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行。

#### 2. Throwable体系

> - **Error**：严重错误，无法通过处理的错误，只能事先避免，好比绝症。（内存不够用或和系统相关）
> - **Exception**：异常，产生后程序员可以通过代码的方式纠正，使程序继续运行，好比感冒。

```java
//Throwable常用方法：
String getMessage()：返回此throwable的简短描述,一般用于提示给用户
String toString()：返回此throwable的详细消息字符串
void printStackTrace():JVM打印异常对象，默认此方法，信息是最全面的，用于开发和调试阶段

```

#### 3. 异常的分类

> - 编译时期异常：必须要处理。在编译时期就会检查，如果没有处理异常，则编译失败。
> - 运行时期异常：可以不处理。在运行时期检查异常，在编译时期，运行异常不会被编译器报错。

#### 4. 异常产生过程解析

```java
// 定义一个对给定的数组通过给定的索引获取元素的方法
public static int getElement(int[] arr, int index) {
	int element = arr[index];
	return element;
}
// 在主方法中调用getElement方法
public static void main(String[] args) {
	int[] arr = {1,2,3};
	intnum = ArrayTools.getElement(arr, 4)
}

```

> 过程解析：getElement方法由于没有找到4索引，导致运行发生了异常，接下来JVM会：
>
> 1. Jvm会根据异常产生的原因创建一个异常对象，这个对象包含了异常产生的（内容，原因，位置） new ArrayIndexOutOfBoundsException("4");
> 2. 在getElement方法中，没有异常的处理逻辑（try...catch），那么JVM就会把异常对象抛出给方法的调用者main方法来处理这个异常
> 3. main方法接受后也没有处理异常的逻辑，继续把对象抛给main方法的调用者JVM处理
> 4. JVM收到这个异常对象，做了两件事：
>    - 把异常对象（内容、原因、位置）以红色的字体打印在控制台
>    - JVM会终止当前正在执行的Java程序--->中断处理

#### 5. throw关键字

```java
throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。例如：
throw new NullPointerException("要访问的arr数组不存在");
throw new ArrayIndexOutOfBoundsException("该索引在数组中不存在，已超出范围");

```

> throw将异常抛出，也就是将问题返回给该方法的调用者。对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续将问题声明出去，使用**throws**声明处理。

> 注意：
>
> 1. throw关键字必须写在方法的内部
> 2. throw关键字后边new的对象必须是Exception或者Exception的子类对象
> 3. throw关键字抛出RuntimeException或者是其子类对象，我们可以不处理，默认交给JVM处理
> 4. throw关键字后边创建的是编译异常，我们就必须处理这个异常（try...catch）

#### 6. Objects非空判断

```java
public static <T> T requireNonNull(T obj) :查看指定引用对象不是null
//源码：
	if (obj == null)
		throw new NullPointerException()  ;
	return obj;

```

#### 7. throws声明异常

```
声明异常：如果方法内通过throw抛出编译时异常，而没有捕获处理，那么必须通过throws进行声明，将问题标识出来。
抛出异常：关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常。

```

```java
//代码演示：
public static void main(String[] args) throws IOException {
	read("a.txt");
}
public static void read(String path)throws FileNotFoundException, IOException {
	if (!path.equals("a.txt")) {
		throw new FileNotFoundException("文件不存在");
	}
	if (!path.equals("b.txt")) {
		throw new IOException();
	}
}

```

> 子父类的异常：子类抛出的异常在数量和继承关系上不能超出父类

#### 8. try…catch捕获异常

```java
捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。
try{
	编写可能会出现异常的代码
}catch(异常类型 e){
	处理异常的代码
	//记录日志/打印异常信息/继续抛出异常
}

```

```java
//代码演示
public static void main(String[] args) {
	try {
		read("b.txt");
	} catch (FileNotFoundException e) {
		System.out.println(e);
	}
	System.out.println("over");
}
public static void read(String path) throws FileNotFoundException {
	if (!path.equals("a.txt")) {
		throw new FileNotFoundException("文件不存在");
	}
}

```

#### 9. finally代码块

```
因为异常会引发程序跳转，导致有些语句执行不到。但有一些特定的代码必须执行，将这些代码放在finally代码块中是一定会被执行的。

```

```java
//代码演示
public static void main(String[] args) {
	try {
		read("a.txt");
	} catch (FileNotFoundException e) {
		throw new RuntimeException(e);
	} finally {
		System.out.println("不管程序怎样，这里都将会被执行。");
	}
	System.out.println("over");
}

```

> 注意：
>
> - finally不能单独使用。
> - 如果finally有return语句,永远返回finally中的结果,避免该情况。
> - 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。

#### 10. 多个异常使用捕获

```java
//一般多个异常一次捕获，多次处理。
try{
	编写可能会出现异常的代码
}catch(异常类型A e){ 当try中出现A类型异常,就用该catch来捕获.
	处理异常的代码
	//记录日志/打印异常信息/继续抛出异常
}catch(异常类型B e){ 当try中出现B类型异常,就用该catch来捕获.
	处理异常的代码
	//记录日志/打印异常信息/继续抛出异常
}

```

> 注意：这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异
> 常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。

#### 11. 自定义异常

```java
//格式：
public class XXXException extends Exception/RuntimeException{
	//空参数的构造方法
    public XXXException() {
	}
	//添加一个带异常信息的构造方法
    public XXXException(String message) {
		super(message);
	}
}

```

> 注意：
>
> 1. 自定义异常类一般都是以Exception结尾，说明该类是一个异常类
> 2. 所有的异常类都会有一个带异常信息的构造方法，方法内部会调用父类带异常信息的构造方法
> 3. 自定义异常类，必须继承Exception/RuntimeException
>    - 继承RuntimeException：那么就是一个运行期异常，无需处理，交给虚拟机
>    - 继承Exception：那么就是一个编译期异常，如果方法内部抛出了编译期异常，就必须处理这个异常，要么throws，要么try...catch

#### 12. 并发与并行

```
并发：指两个或多个事件在同一个时间段内发生（交替执行）。
并行：指两个或多个事件在同一时刻发生（同时执行）。

```

#### 13. 线程与进程

```
进程：一个应用程序可以同时运行多个进程，每个进程都有一个独立的内存空间，是系统运行程序的基本单位。
线程：是CPU和任务之间的执行通道，是任务的执行单元，一个进程中可以有多个线程。
一个应用程序可以有多个进程，一个进程可以有多个线程。

```

> 线程调度：
>
> - 分时调度：
>   所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。
> - 抢占式调度：
>   优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。



## Day06【线程、同步】

#### 1. Thread类

```java
//构造方法：
public Thread() :分配一个新的线程对象。
public Thread(String name) :分配一个指定名字的新的线程对象。
public Thread(Runnable target) :分配一个带有指定目标新的线程对象。
public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。

```

```java
//常用方法：
public String getName() :获取当前线程名称。
public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。
public void run() :此线程要执行的任务在此处定义代码。
public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。
public static Thread currentThread() :返回对当前正在执行的线程对象的引用。

```

#### 2. 创建线程-继承Thread类

```
创建多线程的第一种方式：创建Thread类的子类

```

> 实现步骤：
>
> 1. 创建一个Thread类的子类，并重写Thread类中的run方法，设置线程任务
> 2. 创建Thread类的子类对象
> 3. 调用线程对象的start()方法，开启新的线程，执行run方法

```java
//代码演示
//创建Thread类的子类
public class MyThread extends Thread {
	@Override
	public void run() {
		for (int i = 0; i < 10; i++) {
		System.out.println(getName()+"：正在执行！"+i);
	}
}
//测试类
public static void main(String[] args) {
	MyThread mt = new MyThread();
	mt.start();
}

```

#### 3. 创建线程-Runnable接口

```
创建多线程的第二种方式：Thread构造器实现Runnable接口

```

> 实现步骤：
>
> 1. 创建一个Runnable接口的实现类
> 2. 在实现类中重写Runnable接口的run方法，设置线程任务
> 3. 创建一个Runnable接口的实现类对象
> 4. 创建Thread类对象，构造方法中传递Runnable接口的实现类对象
> 5. 调用Thread类中的start方法，开启新的线程执行run方法

```java
//代码演示
//创建Runnable接口的实现类
public class MyRunnable implements Runnable{
	@Override
	public void run() {
		for (int i = 0; i < 20; i++) {
			System.out.println(Thread.currentThread().getName()+" "+i);
		}
	}
}
//测试类
public static void main(String[] args) {
	MyRunnable mr = new MyRunnable();
	Thread t = new Thread(mr);
	t.start();
}//也可以使用匿名内部类方式实现线程的创建

```

#### 4. Runnable接口具有的优势

1. 适合多个相同的程序代码的线程去共享同一个资源。
2. 可以避免java中的单继承的局限性。
3. 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。
4. 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。

#### 5. 线程安全

```
当多个线程对象访问同一个资源，并且多个线程中对资源有写的操作，就容易产生线程安全问题。

```

#### 6. 同步代码块

```java
synchronized 关键字可以用于方法中的某个区块中，表示对这个区块的资源实行互斥访问。

```

```java
//代码演示
public class Ticket implements Runnable{
	private int ticket = 100;
	Object lock = new Object();
	@Override
	public void run() {
		while(true){
			synchronized (lock) {  //对卖票的操作进行锁
				if(ticket>0){
					String name = Thread.currentThread().getName();
					System.out.println(name+"正在卖:"+ticket‐‐);
                }

```

> **同步锁：对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁**
>
> 1. 锁对象可以是任意类型。
> 2. 多个线程对象要使用同一把锁。
> 3. 在任何时候，最多允许一个线程拥有同步锁，谁拿到锁就进入代码块，其他的线程只能在外等着。

#### 7. 同步方法

```
使用synchronized修饰的方法，就叫做同步方法，保证一个线程执行该方法的时候，其他线程只能在方法外等着。

```

```java
//代码演示
public class Ticket implements Runnable{
	private int ticket = 100;
	@Override
	public void run() {
		while(true){
		sellTicket();
		}
	}
	public synchronized void sellTicket(){
		if(ticket>0){
			String name = Thread.currentThread().getName();
			System.out.println(name+"正在卖:"+ticket‐‐);

```

> **同步锁是谁?**
>
> 对于非static方法，同步锁就是**this**。
>
> 对于static方法，我们使用当前方法所在类的**字节码对象**(类名.class)。

#### 8. Lock锁

```
java.util.concurrent.locks.Lock 机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外Lock更强大,更体现面向对象。

```

```java
//代码演示
public class Ticket implements Runnable{
	private int ticket = 100;
	Lock lock = new ReentrantLock();	//1.创建锁对象
	@Override
	public void run() {
		while(true){
			lock.lock();	//2.加同步锁
			if(ticket>0){
				String name = Thread.currentThread().getName();
				System.out.println(name+"正在卖:"+ticket‐‐);
			}
			lock.unlock();	//3.释放同步锁

```

#### 9. 六种线程状态

| 线程状态                    | 说明                                                         |
| :-------------------------- | :----------------------------------------------------------- |
| 新建状态(New)               | 线程刚被创建，但是还没调用start方法启动。                    |
| 运行状态(Runnable)          | 线程可以在java虚拟机中运行的状态。                           |
| 阻塞状态(Blockd)            | 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态。 |
| 计时等待状态(Timed waiting) | 一个线程在等待另一个线程调用notify或者notifyAll方法（唤醒）动作时，该线程进入Waiting状态，进入这个状态后是不能自动唤醒的。 |
| 无限等待状态(Waiting)       | 同waiting状态，这一状态将一直保持到超时期满或者接收到唤醒通知。 |
| 死亡状态(Terminated)        | 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。 |

#### 10. 等待与唤醒方法

```java
进入到TimeWaiting(计时等待)有两种方式：
    1. sleep(long m)方法,在毫秒值结束之后,线程睡醒进入到Runnable/Blocked状态。sleep方法使用后线程失
    去CPU执行权，但仍然拥有锁对象。
    2. wait(long m)方法,wait方法如果在毫秒值结束之后,还没有被notify唤醒,就会自动醒来,线程睡醒进入到
    Runnable/Blocked状态。wait方法同时释放锁对象和cpu执行权。
唤醒的两种方式:
	1. void notify() 唤醒在此对象监视器上等待的单个线程。
	2. void notifyAll() 唤醒在此对象监视器上等待的所有线程。

```

> wait和notify方法是来源于Object类，不是Thread类，等待和唤醒都是Object的方法



## Day07【线程池、Lambda表达式】

#### 1. 等待唤醒机制

```java
一个线程进行了规定操作后，通过wait()方法进入等待状态，等待其他线程执行完他们的指定代码过后再通过notify()方法将其唤醒，是线程间的一种协作机制。

```

> 注意：
>
> 1. wait方法与notify方法必须要由同一个锁对象调用。
> 2. wait方法与notify方法必须要在同步代码块或者是同步函数中使用，因为要通过锁对象调用这2个方法。
> 3. 被唤醒的线程不一定能立即恢复执行，需要再次获取锁后才能在从 wait() 方法之后的地方恢复执行。

#### 2. 线程池

```
容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。

```

> **线程池的好处：**
>
> 1. 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。
> 2. 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
> 3. 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。

> **线程池使用步骤：**
>
> 1. 用线程池的工厂类Executors里边提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池
> 2. 创建一个类，实现Runnable接口，重写run方法，设置线程任务
> 3. 调用ExecutorService中的方法submit，传递线程任务(实现类)，开启线程，执行run方法
> 4. 调用ExecutorService中的方法shutdown销毁线程池(不建议执行)

```java
//代码展示
public static void main(String[] args) {
        ExecutorService es = Executors.newFixedThreadPool(3);
        es.submit(() -> System.out.println(Thread.currentThread().getName()));
    	es.shutdown();
}

```

#### 3. Lambda表达式

```java
Lambda表达式的标准格式为：(参数类型 参数名称) ‐> { 代码语句 }

```

> 使用前提：
>
> 1. 必须有**函数式接口**——只包含一个抽象方法的接口
> 2. 必须有上下文引用（必须有接口作为数据类型接收）

> 省略格式（**可推导,可省略**）：
>
> 1. 小括号内参数的类型可以省略；
> 2. 如果小括号内有且仅有一个参，则小括号可以省略；
> 3. 如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。

```java
//代码演示
public static void main(String[] args) {
    //重写Runnable接口    
    new Thread(() -> System.out.println("创建并执行线程")).start(); 
    //重写Comparator接口，降序排序	
    Collections.sort(list,(o1, o2) -> o2 - o1);	
}

```

 

## Day08【File类、递归】

#### 1. File类

```
File类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。
File类的实例是不可变的，一旦创建，File对象表示的抽象路径名将永不改变

```

##### 构造方法

```java
public File(String pathname) ：通过将给定的路径名字符串创建新的 File实例。
public File(String parent, String child) ：父路径名字符串+子路径名字符串创建新的File实例。
public File(File parent, String child) ：从父File实例路径名+子路径名字符串创建新的File实例。

```

##### 获取的方法

```java
public String getAbsolutePath() ：返回此File的绝对路径名字符串。
//File对象的toString方法调用的就是getPath()方法
public String getPath() ：将此File转换为路径名字符串。
public String getName() ：返回由此File表示的文件或目录的名称。
public long length() ：返回由此File表示的文件的长度。

```

##### 判断的方法

```java
public boolean exists() ：此File表示的文件或目录是否实际存在。
public boolean isDirectory() ：此File表示的是否为目录。
public boolean isFile() ：此File表示的是否为文件。

```

##### 创建删除的方法

```java
public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。
public boolean delete() ：删除由此File表示的文件或目录，目录项下有内容的话无法删除。
public boolean mkdir() ：创建由此File表示的目录。
public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录。

```

##### 遍历的方法

```java
public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。
public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。

```

> 调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。

#### 2. 绝对路径和相对路径

```java
绝对路径：从盘符开始的路径，这是一个完整的路径。
相对路径：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。

```

> `File.pathSeparator`：获取当前系统路径分隔符；（Windows用" **;** "	Linux用" **:** "）
> `File.separator`：获取当前系统文件名称分隔符；（Windows用"**反斜杠\\**"	Linux用"**正斜杠/**"）

#### 3. 递归

```
递归：指在当前方法内调用自己的这种现象。

```

> 注意事项：
>
> 1. 递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。(StackOverflowError)
> 2. 在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。(StackOverflowError)
> 3. 构造方法,禁止递归。

```java
//代码演示 #暴力删除#
public static void deleteAll(File f) {
        if (f.exists()) {
            if (f.isDirectory()) {
                for (File file : f.listFiles()) {
                    if (file.isFile()) {
                        file.delete();
                    } else {
                        deleteAll(file);
                    }}}
            f.delete();
        }else{
            System.out.println("该路径不是有效路径");
        }}

```

```java
//代码演示 #阶乘#
public static double factorial(int n) {
        if (n == 1) {
            return  1;
        }
        return n * factorial(n - 1);
}
//代码演示 #内存容量测试#
public static void main(String[] args) {
        b(1);
    }
public static void b(int i){
        System.out.println(i);
        b(++i);
    }

```

#### 4. 文件过滤器

```java
public File[] listFiles():返回指定目录中的子目录和文件。
public File[] listFiles(FileFilter filter):返回指定目录中符合自定义规则的子目录和文件。
FileFilter接口中抽象方法：
	boolean accept(File pathname) 测试指定格式路径名是否包含在某个路径名列表中。
public File[] listFiles(FilenameFilter filter):返回指定目录中指定文件。
FilenameFilter接口中抽象方法：
	boolean accept(File dir, String name) 测试指定文件是否应该包含在某一文件列表中。

```

```java
//定义一个方法，输出文件夹里的所有的java文件
public static void showJava(File f) {
        File[] files = f.listFiles(pathname->pathname.isDirectory()||
                                   pathname.getName().toLowerCase().endsWith(".java"));
        for (File file : files) {
            if (file.isDirectory()) {
                showJava(file);
            }else{
                System.out.println(file.getAbsolutePath());
            }}}

```



## Day09【字节流、字符流】

#### 1. IO流

```
输入流 ：把数据从其他设备上读取到【内存中】的流。
输出流 ：把数据从【内存中】写出到其他设备上的流。

```

| 顶级父类们 |          输入流           |           输出流           |
| :--------: | :-----------------------: | :------------------------: |
|   字节流   | 字节输入流【InputStream】 | 字节输出流【OutputStream】 |
|   字符流   |   字符输入流【Reader】    |    字符输出流【Writer】    |

#### 2. 字节输出流【OutputStream】

```
java.io.OutputStream 抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。

```

```java
//OutputStream 基本方法：
public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。
public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。
public void write(byte[] b) ：将 b.length字节从指定的字节数组写入此输出流。
public void write(byte[] b, int off, int len) ：从指定的字节数组写入len字节，从偏移量off开始输出到此输出流。

```

##### FileOutputStream

```java
//构造方法：true 表示追加数据， false 表示清空原有数据
public FileOutputStream(String name, boolean append) ： 创建文件输出流以指定的名称写入文件。
public FileOutputStream(File file, boolean append) ：创建文件输出流以写入由指定的File对象表示的文件。	

```

#### 3. 字节输入流【InputStream】

```
java.io.InputStream 抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。

```

```java
//InputStream 基本方法：
public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。
public abstract int read() ： 从输入流读取数据的下一个字节。
public int read(byte[] b) ： 从输入流中读取一些字节数，并将它们存储到字节数组b中，返回读取的字节数。

```

##### FileInputStream

```java
//构造方法
FileInputStream (File file)：通过打开与实际文件的连接来创建一个FileInputStream，该文件由文件系统中的File对象file命名。
FileInputStream (String name)：通过打开与实际文件的连接来创建一个 FileInputStream，该文件由文件系统中的路径名name命名。

```

```java
//文件复制代码演示
public static void main(String[] args) throws IOException {
        //创建输入输出流对象
        FileInputStream fis = new FileInputStream("src.jpg");
        FileOutputStream fos = new FileOutputStream("des.jpg");
        //创建容器
        byte[] bys = new byte[1024];
        int len;
        //读取源文件
        while ((len = fis.read(bys)) != -1) {
            //输出文件
            fos.write(bys, 0, len);
        }
        //释放资源
        fos.close();
        fis.close();

```

#### 4. 字符输入流【Reader】

```
java.io.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。

```

```java
//Reader 基本方法：
public void close() ：关闭此流并释放与此流相关联的任何系统资源。
public int read() ： 从输入流读取一个字符。
public int read(char[] cbuf) ： 从输入流中读取一些字符，并将它们存储到字符数组cbuf中 。

```

##### FileReader

```java
//构造方法
FileReader(File file)：创建一个新的 FileReader，给定要读取的File对象。
FileReader(String fileName)：创建一个新的 FileReader，给定要读取的文件的名称。

```

```java
//代码演示
public static void main(String[] args) throws IOException {
        FileReader fr = new FileReader("a.txt");
        char[] chars = new char[1024];
        int len;
        while ((len = fr.read(chars)) != -1) {
            System.out.println(new String(chars,0,len));
        }
}

```

#### 5. 字符输出流【Writer】

```
java.io.Writer 抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。

```

```java
//Writer 基本方法
void flush() 刷新该流的缓冲。
void close() 关闭此流，但会自动先刷新它。
void write(int c) 写入单个字符。
void write(char[] cbuf) 写入字符数组。
void write(char[] cbuf, int off, int len) 写入字符数组的某一部分,off数组的开始索引,len字符个数。
void write(String str) 写入字符串。
void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len字符个数。

```

##### FileWriter

```java
//构造方法
FileWriter(File file)：创建一个新的 FileWriter，给定要读取的File对象。
FileWriter(String fileName)：创建一个新的 FileWriter，给定要读取的文件的名称。

```

> 注意：
>
> 使用FileWriter中的方法write，是把数据写入到内存缓冲区中，需要刷新缓冲区，才能将数据保存到文件中。
>
> - flush ：刷新缓冲区，流对象可以继续使用。
> - close :先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。

#### 6. IO异常的处理

##### JDK7前处理

```java
//代码演示
public static void main(String[] args) {
        FileWriter fw = null;
        try {
            fw = new FileWriter("fw.txt");
            fw.write("黑马程序员"); 
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (fw != null) {
                    fw.close();
                }
            } catch (IOException e) {
                e.printStackTrace();}}}

```

##### JDK7的处理

```java
//JDK7优化后用()包裹流对象语句，确保每个流对象在结束使用后关闭
public static void main(String[] args) {
        try ( FileWriter fw = new FileWriter("fw.txt"); ) {
            fw.write("黑马程序员"); 
        } catch (IOException e) {
            e.printStackTrace();}}

```

##### JDK9的改进

```java
//JDK9中使用引入对象的方式，同样可以确保每个流对象在结束使用后自动关闭
public static void main(String[] args) throws IOException {
        FileWriter fw = new FileWriter("fw.txt");
        try (fw) {
            fw.write("黑马程序员");
        } catch (IOException e) {
            e.printStackTrace();}}

```

#### 7. Properties类

```java
java.util.Properties继承于Hashtable，使用键值结构存储数据，每个键及其对应值都是一个字符串。
可以方便地在双列集合和数据文件之间转换。

```

```java
//构造方法
public Properties() :创建一个空的属性列表。
//存储方法
public Object setProperty(String key, String value)：添加一个键值对。
public String getProperty(String key)：通过键获取对应的值。
public Set<String> stringPropertyNames()：获取所有键名称的集合。
//流相关方法
public void load(InputStream in)：从字节输入流中读取键值对,生成Properties集合。
public void store(OutputStream out,String comments)：从Properties集合中获取键值对，输出到字节输出流的文件中。

```

```java
//代码演示
public static void main(String[] args) throws FileNotFoundException {
    Properties pro = new Properties();	//创建Properties对象
    pro.load(new FileInputStream("read.txt"));	//从read.txt中读取数据
    pro.setProperty("one", "111");	//往对象中添加数据
    Set<String> strings = pro.stringPropertyNames();	//获取对象所有键名称的集合
	for (String key : strings ) {	//遍历集合并打印
		System.out.println(key+" ‐‐ "+pro.getProperty(key));
	}
    pro.store(new FileOutputStream("write.txt"),"Saving");	//将对象的信息输出到文件中

```



## Day10【缓冲流、转换流、序列化流】

#### 1. 缓冲流

##### 字节缓冲流

```java
public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。
public BufferedOutputStream(OutputStream out) ： 创建一个新的缓冲输出流。

```

##### 字符缓冲流

```java
public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。
public BufferedWriter(Writer out) ： 创建一个新的缓冲输出流。
//特有方法
BufferedReader： public String readLine() : 读一行文字。
BufferedWriter： public void newLine() : 写一行行分隔符,由系统属性定义符号。

```

```java
//通过缓冲流复制文件，代码演示：
public static void main(String[] args) throws IOException{
        BufferedOutputStream bos = 
            new BufferedOutputStream(new FileOutputStream("des.jpg"));
        BufferedInputStream bis = 
            new BufferedInputStream(new FileInputStream("src.jpg"));
        byte[] bys = new byte[1024];
        int len;
        while ((len = bis.read(bys)) != -1) {
            bos.write(bys, 0, len);
        }
        bos.close();
        bis.close(); }

```

#### 2. 字符集

```
也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。

```

> - **ASCII字符集** ：基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。
> - **GBK**：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了
>   21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。
> - **Unicode字符集** ：为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国
>   码，其中最为常用的是UTF-8编码：
>   1. 128个US-ASCII字符，只需一个字节编码。
>   2. 拉丁文等字符，需要二个字节编码。
>   3. 大部分常用字（含中文），使用三个字节编码。
>   4. 其他极少使用的Unicode辅助字符，使用四字节编码。

#### 3. 转换流

##### InputStreamReader类

```java
转换流java.io.InputStreamReader ，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定
的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。
//构造方法
InputStreamReader(InputStream in) : 创建一个使用默认字符集的字符流。
InputStreamReader(InputStream in, String charsetName) : 创建一个指定字符集的字符流。

```

##### OutputStreamWriter类

```java
转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符
编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。
//构造方法
OutputStreamWriter(OutputStream in) : 创建一个使用默认字符集的字符流。
OutputStreamWriter(OutputStream in, String charsetName) : 创建一个指定字符集的字符流。

```

```java
//将GBK编码的文件转换为UTF-8编码，代码演示：
public static void main(String[] args) throws IOException{
        OutputStreamWriter osw = 
            new OutputStreamWriter(new FileOutputStream("U8code.txt"));
        InputStreamReader isr = 
            new InputStreamReader(new FileInputStream("GBKcode.txt"), "GBK");
        int len;
        char[] chars = new char[1024];
        while ((len = isr.read(chars)) != -1) {
            osw.write(chars,0,len);
        }
        osw.close();
        isr.close();}

```

#### 4. 序列化

```
Java提供了一种对象序列化的机制，使【内存中对象的数据】与【硬盘中文件里的数据】可以相互转化。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。

```

##### ObjectOutputStream类

```java
java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。
//构造方法
public ObjectOutputStream(OutputStream out)：创建一个指定OutputStream的序列化流对象。
//写出方法
public final void writeObject (Object obj) : 将指定的对象写出。

```

> **序列化操作注意事项：**
>
> 1. 要实现序列化的类必须实现`java.io.Serializable`接口，否则会抛出NotSerializableException异常。
> 2. 被瞬态`transient`或静态`static`修饰的属性不会被序列化。

##### ObjectInputStream类

```java
ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。
//构造方法
public ObjectInputStream(InputStream in) ： 创建一个指定InputStream的ObjectInputStream。
//读取方法
public final Object readObject () : 读取一个对象。

```

> **serialVersionUID序列版本号：**Serializable 接口给需要序列化的类，提供了一个序列版本号，目的在于验证序列化的对象和对应类是否版本匹配。如果对类进行和修改，那么其序列标本号也会发生修改。可通过在类中写死序列版本号，使修改后的类依然能够匹配序列化的对象。

```java
//序列化代码演示
//定义学生类
public class Student implements Serializable{
    private String name;
    private int age;
    private static final long serialVersionUID = 8206478034432139083L;
	public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
//测试类
public static void main(String[] args) throws IOException, ClassNotFoundException {
        //序列化
        ObjectOutputStream oos =
                new ObjectOutputStream(new FileOutputStream("Student.txt"));
        oos.writeObject(new Student("Eric", 20));
        oos.close();
        //反序列化
        ObjectInputStream ois =
            new ObjectInputStream(new FileInputStream("Student.txt"));
        Student stu = (Student)ois.readObject();
        System.out.println(stu); //Student{name='Eric', age=20}
        ois.close();}

```

#### 5. 打印流

```
java.io.PrintStream 类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。

```

##### PrintStream类

```java
//构造方法
public PrintStream(String fileName) ： 使用指定的文件名创建一个新的打印流。
//改变打印流向
public static void main(String[] args) throws IOException {
	PrintStream ps = new PrintStream("ps.txt");
	System.setOut(ps);
	System.out.println("Hello,World");} //在ps.txt中输出Hello,World

```

 

## Day11【网络编程】

#### 1. 软件结构

- C/S结构 ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。
- B/S结构 ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。

#### 2. 网络通信协议

```
传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。

```

|       分层        |            协议             |
| :---------------: | :-------------------------: |
|      应用层       | HTTP/FTP/TFTP/SMTP/SNMP/DNS |
|      传输层       |           TCP/UDP           |
|      网络层       |    ICMP/IGMP/IP/ARP/RARP    |
| 数据链路层+物理层 |    由底层网络定义的协议     |

#### 3. TCP协议

```
TCP：传输控制协议 (Transmission Control Protocol)。TCP协议是面向连接的通信协议，即传输数据之前，
在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。

```

> **三次握手建立连接：**在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。
>
> 1. 客户端向服务器端发出连接请求，等待服务器确认。
> 2. 服务器端向客户端回送一个响应，通知客户端收到了连接请求。
> 3. 客户端再次向服务器端发送确认信息，确认连接。

> **四次挥手断开连接：**客户端与服务器之间的四次交互后断开，保证了数据的完整性。
>
> 1. 客户端先向服务器发送断开请求，问询服务器是否可以断开（说明客户端没有数据要传输了）
> 2. 服务器向客户端发送数据，需要客户端确认（说明服务器没有数据要传输了）
> 3. 客户端再次问询服务器是否可以断开连接
> 4. 断开连接

#### 4. UDP协议

```
UDP：用户数据报协议(User Datagram Protocol)。UDP协议是一个面向无连接的协议。传输数据时，不需要建立连接，不管对方端服务是否启动，直接将数据、数据源和目的地都封装在数据包中，直接发送。每个数据包的大小限制在64k以内。它是不可靠协议，因为无连接，所以传输速度快，但是容易丢失数据。日常应用中,例如视频会议、QQ聊天等。

```

#### 5. IP地址

```
IP地址：指互联网协议地址（Internet Protocol Address），俗称IP。IP地址用来给一个网络中的计算机设
备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。

```

> **IP地址分类：**
>
> - IPv4：是一个32位的二进制数，通常被分为4个字节，表示成a.b.c.d 的形式，例如`192.168.65.100 `，最多可以表示42亿个。有资料显示，全球IPv4地址在2011年2月分配完毕。
> - IPv6：采用128位地址长度，每16个字节一组，分成8组十六进制数，解决了网络地址资源数量不够的问题。表示成：`ABCD:EF01:2345:6789:ABCD:EF01:2345:6789` 。

> - 查看本机IP地址，在控制台输入：`ipconfig`
> - 检查网络是否连通，在控制台输入：`ping 空格 IP地址`
> - 本机IP地址：`127.0.0.1`

#### 6. 端口号

```
网络的通信，本质上是两个进程（应用程序）的通信，端口号可以标识设备中的不同进程（应用程序）。

```

> 用两个字节表示的整数，它的取值范围是0~65535。
>
> 0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。
>
> 常用端口号：
>
> 1. 网络端口 https:443  http:80
> 2. 数据库  mysql:3306  oracle:1521
> 3. Tomcat服务器:8080

**【协议+ IP地址+ 端口号】** 三元组合可以标识网络中的进程，进程间的通信可以利用这个标识与其它进程交互。

#### 7. Socket类

```
java.net.Socket类表示客户端。创建Socket对象向服务器发出连接请求，服务器响应请求，两者建立连接开始通信。

```

```java
//构造方法
public Socket(String host, int port) :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null，则相当于指定地址为回送地址。
//成员方法
public InputStream getInputStream()：返回此套接字的输入流。
public OutputStream getOutputStream()：返回此套接字的输出流。
public void close()：关闭此套接字,关闭socket也将关闭相关的InputStream和OutputStream 。
public void shutdownOutput()：禁用此套接字的输出流,任何先前写出的数据将被发送，随后终止输出流。

```

#### 8. ServerSocket类

```java
java.net.ServerSocket类表示服务端。创建ServerSocket 对象，相当于开启一个服务，并等待客户端的连接。

```

```java
//构造方法
public ServerSocket(int port)：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。
//成员方法
public Socket accept()：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。

```

```java
//客户端代码演示
public class TCPClient {
    public static void main(String[] args) throws IOException {
        Socket socket = new Socket("127.0.0.1", 8888);
        OutputStream os = socket.getOutputStream();
        os.write("你好服务器".getBytes());
        InputStream is = socket.getInputStream();
        byte[] bys = new byte[1024];
        int len = is.read(bys);
        System.out.println(new String(bys,0,len));
        System.out.println(socket);
        socket.close();}}
//服务端代码演示
public class TCPServer {
    public static void main(String[] args) throws IOException {
        ServerSocket server = new ServerSocket(8888);
        Socket socket = server.accept();
        InputStream is = socket.getInputStream();
        byte[] bys = new byte[1024];
        int len = is.read(bys);
        System.out.println(new String(bys, 0, len));
        OutputStream os = socket.getOutputStream();
        os.write("收到谢谢".getBytes());
        System.out.println(server);
        socket.close();
        server.close();}}

```

#### 9. 文件上传优化分析

```java
//文件上传案例服务端代码演示
public static void main(String[] args) throws IOException {
        ServerSocket server = new ServerSocket(8888);
        Socket socket = server.accept(); ②
        FileOutputStream fos = new FileOutputStream("copy.jpg"); ①
        InputStream is = socket.getInputStream();
        int len;
        byte[] bys = new byte[1024];
        while ((len = is.read(bys)) != -1) {
            fos.write(bys, 0, len);
        }
        socket.getOutputStream().write("上传成功".getBytes());
        fos.close();
        socket.close();
        server.close();
//文件上传案例客服端代码演示
public static void main(String[] args)throws IOException {
        FileInputStream fis = new FileInputStream("src.jpg");
        Socket socket = new Socket("127.0.0.1", 8888);
        OutputStream os = socket.getOutputStream();
        int len;
        byte[] bys = new byte[1024];
        while ((len = fis.read(bys)) != -1) {
            os.write(bys, 0, len);
        }
        socket.shutdownOutput(); //避免阻塞问题
        InputStream is = socket.getInputStream();
        while ((len = is.read(bys)) != -1) {
            System.out.println(new String(bys, 0, len));
        }
        socket.close();
        fis.close();

```

##### ① 文件名称写死的问题

```java
服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下：
FileOutputStream fis = new FileOutputStream(System.currentTimeMillis()+".jpg") // 文件名称

```

##### ② 循环接收的问题

```java
服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下：
while（true）{
	Socket socket = server.accept();
	......
}

```

##### ③ 效率问题

```java
服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下：
while（true）{
	Socket socket = serverSocket.accept();
	// socket 交给子线程处理.
	new Thread(() ‐> {
		......
		InputStream is = socket.getInputStream();
		......
	}).start();
}

```



## Day12【函数式接口】

#### 1. 函数式接口

```
有且仅有一个抽象方法的接口。

```

> @FunctionalInterface注解：使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。

#### 2. Lambda的延迟执行

```java
//无论level是多少，都会先把字符串拼接并传入方法内。如果level不符合要求，拼接操作就白做了
public static void main(String[] args) {
	String msgA = "Hello";
	String msgB = "World";
	String msgC = "Java";
	log(1, msgA + msgB + msgC);}

private static void log(int level, String msg) {
	if (level == 1) {
	System.out.println(msg);}}

//使用Lambda的延迟执行进行优化，只有满足要求的时候才会进行三个字符串的拼接；否则三个字符串将不会进行拼接。
public static void main(String[] args) {
	String msgA = "Hello";
	String msgB = "World";
	String msgC = "Java";
	log(1, () ‐> msgA + msgB + msgC );}

private static void log(int level, MessageBuilder builder) {
	if (level == 1) {
		System.out.println(builder.buildMessage());}}

@FunctionalInterface
public interface MessageBuilder {
	String buildMessage();}

```

#### 3. Supplier接口

```java
java.util.function.Supplier<T>接口用来获取一个泛型参数指定类型的对象数据。
仅包含一个无参的抽象方法：T get() 。

```

```java
//代码演示
public static void main(String[] args) {
	String s = getString(() -> "Eric" + "loset");
	System.out.println(s);}

public static String getString(Supplier<String> sup) {
	return sup.get();}

```

#### 4. Consumer接口

```java
java.util.function.Consumer<T> 接口与Supplier接口相反，是消费一个数据，其数据类型由泛型决定。
包含一个有参的抽象方法void accept(T t)，一个默认方法andThen(),可以组合多个步骤。
//andThen方法源码：
default Consumer<T> andThen(Consumer<? super T> after) {
	Objects.requireNonNull(after);
	return (T t) ‐> { accept(t); after.accept(t); }

```

```java
//代码演示
public static void main(String[] args) {
	method("方法",
	(t) -> System.out.print(t + "1"),
	(t) -> System.out.print(t + "2"),
	(t) -> System.out.print(t + "3"));}       //方法1方法2方法3

public static void method(String name, Consumer<String> con1, Consumer<String> con2, 								Consumer<String> con3){
	con1.andThen(con2).andThen(con3).accept(name);}

```

#### 5. Predicate接口

```java
java.util.function.Predicate<T>接口返回一个boolean值结果，用于对某种类型的数据进行判断。
接口中包含一个抽象方法： boolean test(T t)，用于条件判断的场景。
接口中包含三个默认方法： and(),or(),negate()

```

```java
//代码演示
public static void main(String[] args) {
        String s = "abcdefg";
        boolean b = checkString(s,
                (str) -> str.length() > 20,
                (str) -> str.contains("bc"));
        System.out.println(b);} 	//true

public static boolean checkString(String s, Predicate<String> pre1, 
                                  	Predicate<String> pre2) {
        return pre1.or(pre2).test(s);}

```

#### 6. Function接口

```java
java.util.function.Function<T,R> 接口用来根据一个类型的数据得到另一个类型的数据。
包含一个有参的抽象方法 R apply(T t)，一个默认方法andThen()，可以组合多个步骤。

```

```java
//代码演示
private static void method(String str, Function<String, Integer> function) {
	int num = function.apply(str);
	System.out.println(num + 20);
    }
public static void main(String[] args) {
	method("100",s->Integer.parseInt(s));
    }

```



## Day13【Stream流、方法引用】

#### 1. 流式思想

```
Stream（流）是一个来自数据源（集合、数组等）的元素队列，元素是特定类型的对象，形成一个队列。
Java中的Stream并不会存储元素，而是按需计算。中间操作都会返回流对象本身，这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。
这样做可以对操作进行优化，比如延迟执行(laziness)和短路( short-circuiting)。

```

> Stream流支持并行，效率高

#### 2. 获取流

```java
//单列集合中，Collecion接口中加入了stream方法用于获取流
Collection<String> c = new ArrayList();
Stream<String> collectionStream = c.stream();
//双列集合中，获取流需要先获得key集合或value集合或者entry集合
Map<String, String> map = new HashMap<>();
Stream<String> keyStream = map.keySet().stream();
Stream<String> valueStream = map.values().stream();
Stream<Map.Entry<String, String>> entryStream = map.entrySet().stream();
//要获取数组的流对象，可以通过Stream接口中提供的静态方法of
String[] arr = {"one", "two", "three"};
Stream<String> arrStream = Stream.of(arr);

```

> 备注： of 方法的参数其实是一个可变参数，所以支持数组。

#### 3. 常用方法

> - **延迟方法：**返回值类型仍然是Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方法均为延迟方法。）
> - **终结方法：**返回值类型不再是Stream 接口自身类型的方法，因此不再支持类似StringBuilder 那样的链式调用。终结方法包括count 和forEach 方法。

##### forEach：逐一处理

```java
void forEach(Consumer<? super T> action);

```

##### filter：过滤

```java
Stream<T> filter(Predicate<? super T> predicate);

```

##### map：映射

```java
<R> Stream<R> map(Function<? super T, ? extends R> mapper);

```

##### count：统计个数

```java
long count();

```

##### limit：取用前几个

```java
Stream<T> limit(long maxSize);

```

> 参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。

##### skip：跳过前几个

```java
Stream<T> skip(long n);

```

> 如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。

##### concat：组合

```java
static <T> Stream<T> concat(Stream<? extends T> a, Stream<? extends T> b)

```

##### collect：将流元素生成集合

```java
List<T> list = stream.collect(Collectors.toList());
Set<T> set = stream.collect(Collectors.toSet());

```

##### toArray：将流元素生成数组

```java
Object[] array = stream.toArray();

```

```java
//代码演示
// 第一个队伍只要名字为3个字的成员姓名；// 第一个队伍筛选之后只要前3个人；
Stream<String> streamOne = one.stream().filter(s ‐> s.length() == 3).limit(3);
// 第二个队伍只要姓张的成员姓名；// 第二个队伍筛选之后不要前2个人；
Stream<String> streamTwo = two.stream().filter(s ‐> s.startsWith("张")).skip(2);
// 将两个队伍合并为一个队伍；// 根据姓名创建Person对象；// 打印整个队伍的Person对象信息。
Stream.concat(streamOne, streamTwo).map(Person::new).forEach(System.out::println);

```

> 注意：Stream分为三类方法：
>
> 1. 初始操作，将数据源转换为Stream流
> 2. 中间操作，调用之后返回值也是Stream对象
> 3. 终止操作，调用之后返回值不是Streasm对象
>
> 流中的数据**只能被消费一次**，流在操作过程中，如果执行的是初始操作、中间操作，那么实际上**不会对流元素进行处理**，只有在进行Stream的**终止操作的时候才执行**

#### 4. 方法引用

```java
双冒号::为引用运算符，它所在的表达式被称为方法引用，是简化Lambda的书写。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。前提是括号内的所有内容都是依赖于一个对象的某个方法实现的，并不是所有的Lambda表达式都能被简化为方法引用。

```

```java
//代码演示
public static int method(int i, Function<Integer, Integer> f) {
	return f.apply(i);
}
public static void main(String[] args) {
	System.out.println(method(-5, Math::abs));
}
//数组的构造器引用
public static void main(String[] args) {
	int[] ints = createArray(5, int[]::new);
	System.out.println(Arrays.toString(ints));
}
public static int[] createArray(int i, Function<Integer, int[]> f) {
	return f.apply(i);
}
//类的构造器引用
public static void main(String[] args) {
	personBuilder("Eric", (Person::new));
}
public static void personBuilder(String s, Function<String, Person> f) {
	Person p = f.apply(s);
	System.out.println(p);
}

```



## Day14【单元测试、反射、注解】

#### 1. 单元测试

```
测试分类：
	1. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值，不用懂程序的知识也可以进行测试
	2. 白盒测试：需要写代码的，关注程序具体的执行流程。

```

> **白盒测试**步骤：
>
> 1. 定义一个测试类，类名为被测试类名+Test（CalculatorTest）
> 2. 定义一个测试方法，可以独立运行，方法名为test+被测方法名（testAdd() ）
>
> 方法的返回值：void；参数列表：空参
>
> 3. 给方法加@Test
> 4. 导入junit依赖环境

> 注意事项：
>
> 1. 使用断言操作` Assert.assertEquals(期望的结果,运算的结果)`来处理结果
> 2. 红色结果为失败，绿色结果为成功
> 3. @Before：修饰的方法会在测试方法之前被自动执行
> 4. @After：修饰的方法会在测试方法执行之后自动被执行

```java
//代码演示
public class CalculatorTest {
    @Before
    public void before() {
        System.out.println("初始化...");}
    @Test
    public void testAdd(){
        Calculator c = new Calculator();
        int add = c.add(1, 2);
        Assert.assertEquals(3, add);}
    @Test
    public void testSub(){
        Calculator c = new Calculator();
        int sub = c.sub(1, 2);
        Assert.assertEquals(-1, sub);}
    @After
    public void after(){
        System.out.println("释放资源");}}

```

#### 2. 反射

```java
反射：将类的各个组成部分封装为其他对象，这就是反射机制。通过反射，可以在程序运行过程中操作这些对象，是框架的基础。运用反射可以解耦，提高程序的可拓展性。

```

##### 获取Class对象

```java
1. Class.forName("全类名")：用于配置文件
	Class personClass = Class.forName("Reflect.Person");
2. 类名.class：用于参数的传递
	Class personClass = Person.class;
3. 对象.getClass()：用于对象的获取字节码的方式
	Person p = new Person();	Class personClass = p.getClass();

```

##### 操作成员变量对象

```java
//获取成员变量对象
Field getField(String name)：获取指定名称的public修饰的成员变量
Field[] getFields()：获取所有public修饰的成员变量
Field getDeclaredField(String name)：获取指定名称的成员变量，不考虑修饰符
Field[] getDeclaredFields()：获取所有的成员变量，不考虑修饰符
//设置成员变量方法
void set(Object obj, Object value)：设置值
get(Object obj)：获取值
setAccessible(true)：忽略访问权限修饰符的安全检查（暴力反射）

```

##### 操作构造方法对象

```java
//获取构造方法对象
Constructor<T> getConstructor(parameterTypes.class)：获取指定参数列表的public修饰的成员变量
Constructor<?>[] getConstructors()：获取所有public修饰的构造方法 
Constructor<T> getDeclaredConstructor(parameterTypes.class)：获取指定参数列表的成员变量
Constructor<?>[] getDeclaredConstructors()：获取所有的构造方法，不考虑修饰符  
//创建对象的方法
 T newInstance(Object... initargs)

```

##### 操作成员方法对象

```java
//获取成员方法对象
Method getMethod(String name，parameterTypes.class)：获取指定名称和参数列表的public修饰的方法
Method[] getMethods()：获取所有public修饰的成员方法
Method getDeclaredMethod(String name，parameterTypes.class)：获取指定名称和参数列表的成员方法
Method[] getDeclaredMethods()：获取所有的成员方法，不考虑修饰符（含继承的方法）    
//执行方法
method invoke(Object obj)  

```

#### 3. “框架”案例

```java
//	配置文件ClassMessage.properties:
//	className = Reflect.Person
//	methodName = eat
public static void main(String[] args) throws Exception {
	Properties pro = new Properties();
	pro.load(new FileInputStream("ClassMessage.properties"));
	String className = pro.getProperty("className");	//Reflect.Person
	String methodName = pro.getProperty("methodName");	//eat
	Class cls = Class.forName(className);
	Object o = cls.getConstructor().newInstance();
	Method method = cls.getMethod(methodName);
	method.invoke(o);	//调用了Person类中的eat方法
}

```

#### 4. 注解

```
注解（Annotation），也叫元数据。一种代码级别的说明，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。JDK1.5及以后版本引入的特性。
格式：@注解名称

```

> 作用分类：
>
> 1. 编写文档：通过代码里标识的注解生成文档【生成文档doc文档】
> 2. 代码分析：通过代码里标识的注解对代码进行分析【使用反射】
> 3. 编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】

> JDK中预定义的一些注解：
>
> - @override：方法重写注解
> - @Deprecated：过期注解
> - @SuppressWarnings：压制警告，将当前所有的类警告都去除
>
> 一般传递参数all  @SuppressWarnings("all")

#### 5. 自定义注解

```java
//格式：
	元注解
	public @interface 注解名称{
		属性列表;
	}

```

> 注解本质上就是一个接口，该接口**默认继承Annotation接口**：
> `public interface MyAnno extends java.lang.annotation.Annotation {}`

> **注解接口中的要求：**
>
> - **接口中的抽象方法称为属性**，返回值类型为：
>
> ①基本数据类型；②String；③枚举；④注解；⑤以上类型的数组
>
> - 定义了属性，在使用时需要给属性赋值，若定义时已经给了默认值，可以不用赋值，如果只有一个属性需要赋值，并且属性的名称是value，则赋值的时候，value的字样可以省略
> - 数组赋值时，需要使用{}包裹，如果数组中只有一个值，则{}省略

#### 6. 元注解

```
用于描述注解的注解。

```

> **@Target(ElementType)**：描述注解能够作用的位置
>
> ElementType取值：
>
> 1. ElementType.TYPE：可以作用于类上
> 2. ElementType.METHOD：可以作用于方法上
> 3. ElementType.FIELD：可以作用于成员变量上
>
> **@Retention(RetentionPolicy)**：描述注解被保留的阶段
>
> RetentionPolicy取值：
>
> 1. RetentionPolicy.RUNTIME：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到
> 2. RetentionPolicy.CLASS：当前被描述的注解，会保留到class字节码文件中，不会被JVM读取
> 3. RetentionPolicy.SOURCE：当前被描述的注解，不会被class字节码文件保留
>
> **@Documented**：描述注解是否被抽取到api文档中
>
> **@Inherited**：描述注解是否被子类继承

#### 7. ”测试框架“案例

```java
public static void main(String[] args) throws IOException {
	Calculator c = new Calculator();
	Class cls = c.getClass();
	//获取类中的所有方法
    Method[] methods = cls.getMethods();
    //创建输出流和记录异常次数的变量count
    BufferedWriter bw = new BufferedWriter(new FileWriter("error.txt"));
    int count = 0;
    for (Method method : methods) {  //遍历所有方法，筛选出被@Check标记的方法
		if (method.isAnnotationPresent(Check.class)) {
			try {
				method.invoke(c);
			} catch (Exception e) {
				count++;
                //将异常打印到日志文件中
                bw.write(method.getName() + "方法出异常了");
                bw.newLine();
                bw.write("异常的名称" + e.getCause().getClass().getSimpleName());
                bw.newLine();
                bw.write("异常的原因" + e.getCause());
                bw.newLine();
                bw.write("-----------------");
                bw.newLine();}}}
	bw.write("本次测试共出现了" + count + "次异常");
	bw.close();}

```



# 数据库知识点总结

### 1. 数据库的基本概念

```
数据库(DataBase,简称:DB)，用于存储和管理数据的仓库。
类比：数据库：文件夹(仓库)；表：文件（货架子）； 数据：数据（货物）。
```

> 数据库的特点：
>
> 1. 持久化存储数据，数据库就是一个文件系统
> 2. 方便存储和管理数据
> 3. 使用了统一的方式操作数据库 -- SQL

### 2. MySQL配置操作

```sql
服务启动:
	net start mysql：启动mysql的服务
	net stop mysql：关闭mysql服务
登录:
	mysql -u用户名 -p密码
	mysql -hip地址 -u用户名 -p连接目标的密码
退出:
	exit/quit
配置文件 my.ini
```

### 3. SQL概念

```
Structured Query Language：结构化查询语言。
SQL定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。
```

> **SQL通用语法：**
>
> 1. SQL 语句可以单行或多行书写，以分号结尾。
> 2. 可使用空格和缩进来增强语句的可读性。
> 3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。
> 4. 注释：
>    - 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) 
>    - 多行注释: /* 注释 */

> **SQL分类：**
>
> - **DDL（Data Definition Language）**数据定义语言：用来定义数据库对象：数据库，表，列等。
> - **DML（Data Manipulation Language）**数据操作语言：用来对数据库中表的数据进行增删改。
> - **DQL（Data Query Language）**数据查询语言：用来查询数据库中表的记录(数据)。
> - **DCL（Data Control Language）**数据控制语言：用来定义数据库的访问权限和安全级别，创建用户。

### 4. DDL 定义数据库

#### 操作数据库

| 操作 | 代码                                                    | 备注                            |
| ---- | ------------------------------------------------------- | ------------------------------- |
| 创建 | create database `数据库名称`                            | 创建数据库                      |
| 创建 | create database if not exists `数据库名称`              | 创建数据库，判断不存在，再创建  |
| 创建 | create database `数据库名称` character set `字符集名称` | 创建数据库，并指定字符集        |
| 查询 | show databases                                          | 查询所有数据库的名称            |
| 查询 | show create database `数据库名称`                       | 查询某个数据库的字符集/创建语句 |
| 修改 | alter database` 数据库名称` character set `字符集名称`  | 修改数据库的字符集              |
| 删除 | drop database `数据库名称`                              | 删除数据库                      |
| 删除 | drop database if exists `数据库名称`                    | 判断数据库存在，存在再删除      |
| 使用 | select database()                                       | 查询当前正在使用的数据库名称    |
| 使用 | use `数据库名称`                                        | 使用数据库                      |

> **注意：数据库的名称不可修改**

#### 操作表

| 操作 | 代码                                                      | 备注                         |
| ---- | --------------------------------------------------------- | ---------------------------- |
| 创建 | create table `表名(列名1 数据类型1,....列名n 数据类型n)`; | 创建一个表                   |
| 创建 | create table `表名` like `被复制的表名`                   | 复制表                       |
| 查询 | show tables                                               | 查询某个数据库中所有的表名称 |
| 查询 | desc `表名`                                               | 查询表结构                   |
| 修改 | alter table `表名` rename to `新的表名`                   | 修改表名                     |
| 修改 | alter table `表名` character set `字符集名称`             | 修改表的字符集               |
| 修改 | show create table `表名`                                  | 查看表的字符集               |
| 修改 | alter table `表名` add `列名 数据类型`                    | 添加一列                     |
| 修改 | alter table `表名` add `列名 数据类型` after `指定列名`   | 在指定的列后添加一列         |
| 修改 | alter table `表名` change `列名 新列别 新数据类型`        | 修改列名称和数据类型         |
| 修改 | alter table `表名` modify `列名 新数据类型`               | 修改数据类型                 |
| 修改 | alter table `表名` drop `列名`                            | 删除列                       |
| 删除 | drop table `表名`                                         | 删除表                       |
| 删除 | drop table  if exists `表名`                              | 判断表存在，存在再删除       |

> **数据类型：**
>
> 1. **int**：整数类型  `age int`
> 2. **double**：小数类型  `score double(5,2)`
> 3. **date**：日期，只包含年月日  `yyyy-MM-dd`
> 4. **datetime**：日期，包含年月日时分秒  `yyyy-MM-dd HH:mm:ss`
> 	. **timestamp**：时间戳，包含年月日时分秒  `yyyy-MM-dd HH:mm:ss`（默认使用系统当前时间赋值）	
> 6. **varchar**：字符串  `name varchar(20)` （括号里数字为可接收最大字符数）

### 5. DML 增删改表中数据

| 操作 | 代码                                                         | 备注                   |
| ---- | ------------------------------------------------------------ | ---------------------- |
| 添加 | insert into `表名` values `(值1,值2,...值n)`                 | 给表中每一列赋值       |
| 添加 | insert into `表名(列名1,列名2,...列名n) `values`(值1,值2,...值n)` | 选择地给表中某一列赋值 |
| 删除 | delete from `表名 [where 条件]`                              | 删除符合条件的记录     |
| 删除 | truncate table `表名`                                        | 删除整张表             |
| 修改 | update `表名` set `列名1 = 值1, 列名2 = 值2,... [where 条件]` | 修改指定列的数据       |

> **注意：**
>
> 1. 除了数字类型，其他类型需要使用引号(单双都可以)引起来，数值类型加引号也不会报错，但是不推荐加
> 2. 若要删除整表，推荐使用`truncate table`，效率高；`delete from` 内部采用逐个删除，效率低
> 3. 若要修改多条记录，可以指定条件数据范围`in()`

### 6. DQL 查询表中记录

```mysql
语法格式：
	select
		字段列表
	from
		表名列表
	where
		条件列表
	group by
		分组字段
	having
		分组之后的条件
	order by
		排序
	limit
		分页限定
```

#### 基础查询

> 1. 多个字段的查询：`select 字段名1，字段名2... from 表名；`(*来替代查询所有字段)
> 2. 去除重复：`select` **distinct** `字段名1，字段名2... from 表名；`
> 3. 计算列：一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）
> 4. null参与的运算，计算结果都为null。`ifnull(表达式1,表达式2)：`
>
>  表达式1：需要判断是否为null的字段；表达式2：若该字段为null后的替换值
>
> ```
> 5. 起别名：as（as也可以省略）
> ```

#### 条件查询

> 1. where子句后跟条件
>
>    2. 运算符
>
>    - <> (相当于!=)
>    - BETWEEN...AND  
>    - IN( 集合) 
>
>    3. 模糊查询 LIKE：占位符：`_`：单个任意字符；`%`：多个任意字符（含0个）
>    4. IS NULL (是否为空，不能用=null判断) ；IS NOT NULL：不为空

#### 排序查询

> 1. 语法：`order by 排序字段1 排序方式1 ，排序字段2 排序方式2...`
> 2. 排序方式：ASC：升序，默认的；DESC：降序
> 3. 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件

#### 聚合函数

> **将一列数据作为一个整体，进行纵向的计算，需要排除null值**
>
> 1. count：计算个数（`count(*)`：只要该数据有一列不为空）
> 2. max：计算最大值
> 3. min：计算最小值
> 4. sum：计算和
> 5. avg：计算平均值

#### 分组查询

> 语法：group by 分组字段；
>
> 要求：查询条件的字段只能是**分组字段**和**聚合函数**

#### 分页查询

> 1. 语法：limit 要开始显示的索引，每页查询的条数；
> 2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数
> 3. limit 是一个MySQL"方言”

> **where 和 having 的区别？**
>
> 1. where 在分组之前进行限定，如果不满足条件，则不参与分组；having在分组之后进行限定，如果不满足结果，则不会被查询出来。
> 2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。

### 7. 约束

#### 非空约束

```mysql
not null，某一列的值不能为null
```

> 1. 创建表时，添加非空约束：CREATE TABLE stu(id INT,NAME VARCHAR(20) **NOT NULL**);
> 2. 创建表后，添加非空约束：ALTER TABLE stu MODIFY NAME VARCHAR(20) **NOT NULL**;
> 3. 删除非空约束：ALTER TABLE stu **MODIFY** NAME VARCHAR(20);

#### 唯一约束

```mysql
unique，某一列的值不能重复，但可以有多个NULL值
```

> 1. 创建表时，添加唯一约束：CREATE TABLE stu(id INT, NAME VARCHAR(20) **UNIQUE** );
> 2. 创建表后，添加唯一约束：ALTER TABLE stu MODIFY NAME VARCHAR(20) **UNIQUE**;
> 3. 删除唯一约束：ALTER TABLE stu **DROP INDEX** NAME;

#### 主键约束

```mysql
primary key，非空且唯一，一张表只能有一列的值设为主键，是表中记录的唯一标识，一般是数据无关列
```

> 1. 创建表时，添加主键约束：CREATE TABLE stu(id INT **PRIMARY KEY**, NAME VACHAR(20));
> 2. 创建表后，添加主键约束：ALTER TABLE stu MODIFY id INT **PRIMARY KEY**;
> 3. 删除主键约束：ALTER TABLE stu **DROP PRIMARY KEY**;
> 4. 主键约束添加自增长：id INT PRIMARY KEY **AUTO_INCREMENT**；

#### 外键约束

```
foreign key，让表于表产生关系，从而保证数据的正确性

```

> 1. 创建表时，添加外键约束：
>
> **constraint** `外键名称` **foreign key**` (外键列名称)` **references** `主表名称(主键列名称)`  **①**
>
> 外键列名称为**受约束的列**名称，主键列名称为**约束别人的列**名称；
>
> 外键名称可以自定义，起到删除时索引的作用 。一般格式：当前表名 _ 外键表名 _ fk
>
> 2. 创建表之后，添加外键约束：ALTER TABLE stu ADD + ①
> 3. 删除外键约束：ALTER TABLE stu DROP FOREIGN KEY `外键名称`；
> 4. 级联操作：级联更新：ON UPDATE CASCADE ；级联删除：ON DELETE CASCADE 

### 8. 数据库的设计

```mysql
1. 一对一：实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。
2. 一对多(多对一)：实现方式：在多的一方建立外键，指向一的一方的主键。
3. 多对多：实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键。
-- 旅游网案例展示：一个旅游线路分类中有多个旅游线路；一个用户收藏多个线路，一个线路被多个用户收藏。
/*创建旅游线路分类表 tab_category
    cid 旅游线路分类主键，自动增长
    cname 旅游线路分类名称非空，唯一，字符串 100
*/
CREATE TABLE tab_category (
	cid INT PRIMARY KEY AUTO_INCREMENT,
	cname VARCHAR(100) UNIQUE NOT NULL
);

/*创建旅游线路表 tab_route
    rid 旅游线路主键，自动增长
    rname 旅游线路名称非空，唯一，字符串 100
    price 价格
    rdate 上架时间，日期类型
    cid 外键，所属分类
*/
CREATE TABLE tab_route(
	rid INT PRIMARY KEY AUTO_INCREMENT,
	rname VARCHAR(100) NOT NULL UNIQUE,
	price DOUBLE,
	rdate DATE,
	cid INT,
	FOREIGN KEY (cid) REFERENCES tab_category(cid)
);

/*创建用户表 tab_user
    uid 用户主键，自增长
    username 用户名长度 100，唯一，非空
    password 密码长度 30，非空
    name 真实姓名长度 100
    birthday 生日
    sex 性别，定长字符串 1
    telephone 手机号，字符串 11
    email 邮箱，字符串长度 100
*/
CREATE TABLE tab_user (
	uid INT PRIMARY KEY AUTO_INCREMENT,
	username VARCHAR(100) NOT NULL UNIQUE,
	PASSWORD VARCHAR(30) NOT NULL,
	NAME VARCHAR(100),
	birthday DATE,
	sex CHAR(1) DEFAULT '男',
	telephone VARCHAR(11),
	email VARCHAR(100)
);

/*创建收藏表 tab_favorite
    rid 旅游线路 id，外键
    date 收藏时间
    uid 用户 id，外键
    rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次
*/
CREATE TABLE tab_favorite (
	rid INT,
	FOREIGN KEY (rid) REFERENCES tab_route(rid),
	DATE DATETIME,
	uid INT,
	FOREIGN KEY (uid) REFERENCES tab_user(uid),
	PRIMARY KEY (rid,uid)  -- 联合主键
);

```

### 9. 数据库设计范式

```mysql
1. 第一范式（1NF）：每一列都是不可分割的原子数据项
2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除部分函数依赖）
3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）

```

> 几个概念：
>
> 1. 函数依赖：A-->B，如果通过A属性(属性组)的值，可以确定**唯一**B属性的值，则称B依赖于A。
> 2. 完全函数依赖：A-->B， 如果A是一个属性组，则B属性值的确定需要依赖于A属性组中**所有**的属性值。
> 3. 部分函数依赖：A-->B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中**某一些**值即可。
> 4. 传递函数依赖：A-->B, B -- >C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A。
> 5. 码：一张表中，一个属性或属性组，**被其他所有属性所完全依赖**，则称这个属性(属性组)为该表的码。

**第一范式表（1NF）：**原子数据项

| 学号  | 姓名   | 系名   | 系主任 | 课程名称   | 分数 |
| ----- | ------ | ------ | ------ | ---------- | ---- |
| 10010 | 张无忌 | 经济系 | 张三丰 | 高等数学   | 95   |
| 10010 | 张无忌 | 经济系 | 张三丰 | 大学英语   | 87   |
| 10010 | 张无忌 | 经济系 | 张三丰 | 计算机基础 | 65   |
| 10011 | 令狐冲 | 法律系 | 任我行 | 法理学     | 77   |
| 10011 | 令狐冲 | 法律系 | 任我行 | 大学英语   | 87   |
| 10011 | 令狐冲 | 法律系 | 任我行 | 法律社会学 | 65   |
| 10012 | 杨过   | 法律系 | 任我行 | 法律社会学 | 95   |
| 10012 | 杨过   | 法律系 | 任我行 | 法理学     | 97   |
| 10012 | 杨过   | 法律系 | 任我行 | 大学英语   | 99   |

> 存在问题：
>
> 1. 存在非常严重的数据冗余(重复)：姓名、系名、系主任
> 2. 数据添加存在问题：添加新开设的系和系主任时，数据不合法
> 3. 数据删除存在问题：张无忌同学毕业了，删除数据，会将系的数据一起删除。

**第二范式表（2NF）：**消除部分函数依赖

| 学号  | 课程名称   | 分数 | 学号  | 姓名   | 系名   | 系主任 |
| ----- | ---------- | ---- | ----- | ------ | ------ | ------ |
| 10010 | 高等数学   | 95   | 10010 | 张无忌 | 经济系 | 张三丰 |
| 10010 | 大学英语   | 87   | 10011 | 令狐冲 | 法律系 | 任我行 |
| 10010 | 计算机基础 | 65   | 10012 | 杨过   | 法律系 | 任我行 |
| 10011 | 法理学     | 77   |       |        |        |        |
| 10011 | 大学英语   | 87   |       |        |        |        |
| 10011 | 法律社会学 | 65   |       |        |        |        |
| 10012 | 法律社会学 | 95   |       |        |        |        |
| 10012 | 法理学     | 97   |       |        |        |        |
| 10012 | 大学英语   | 99   |       |        |        |        |

**第三范式表（3NF）：**消除传递依赖

| 学号  | 课程名称   | 分数 | 学号  | 姓名   | 系名   | 系名   | 系主任 |
| ----- | ---------- | ---- | ----- | ------ | ------ | ------ | ------ |
| 10010 | 高等数学   | 95   | 10010 | 张无忌 | 经济系 | 经济系 | 张三丰 |
| 10010 | 大学英语   | 87   | 10011 | 令狐冲 | 法律系 | 法律系 | 任我行 |
| 10010 | 计算机基础 | 65   | 10012 | 杨过   | 法律系 |        |        |
| 10011 | 法理学     | 77   |       |        |        |        |        |
| 10011 | 大学英语   | 87   |       |        |        |        |        |
| 10011 | 法律社会学 | 65   |       |        |        |        |        |
| 10012 | 法律社会学 | 95   |       |        |        |        |        |
| 10012 | 法理学     | 97   |       |        |        |        |        |
| 10012 | 大学英语   | 99   |       |        |        |        |        |

### 10. 数据库的备份和还原

> 备份： `mysqldump -u用户名 -p密码 数据库名称 > 保存的路径`
>
> 还原：登录数据库—>创建数据库—>使用数据库—>执行文件 source 文件路径

### 11. 多表查询

#### 隐式内连接

> 使用where条件消除无用数据：`SELECT * FROM emp,dept WHERE emp.dept_id = dept.id`

#### 显式内连接

> 表名1 [inner] join 表名2 on 条件：`SELECT * FROM emp INNER JOIN dept ON emp.dept_id= dept.id`

#### 外链接查询

> 左外连接：查询左表**所有数据**以及其和右表交集部分
>
> 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件
>
> 右外连接与左外连接正好相反：select 字段列表 from 表1 right [outer] join 表2 on 条件；

#### 子查询

```
查询中嵌套查询，称嵌套查询为子查询。

```

> 1. 子查询的结果是**单行单列**的：子查询可以作为条件，使用运算符去判断。 
> 2. 子查询的结果是**多行单列**的：子查询可以作为条件，使用in(结果)来判断。
> 3. 子查询的结果是**多行多列**的：子查询可以作为一张虚拟表参与查询。

### 12. 事务

```
如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。

```

> 基本操作：
>
> 1. 开启事务： `start transaction;`
> 2. 回滚：`rollback;`
> 3. 提交：`commit;`

> 提交方式：
>
> - 自动提交：一条DML(增删改)语句会自动提交一次事务。（mysql）
> - 手动提交：需要先开启事务，再提交。（Oracle）
> - 修改事务的默认提交方式：
>   - 查看事务的默认提交方式：`SELECT @@autocommit;`  1 代表自动提交，0 代表手动提交
>   - 修改默认提交方式： `set @@autocommit = 0;`

#### 四大特征ACID

> 1. **原子性Atomic**：是不可分割的最小操作单位，要么同时成功，要么同时失败。
> 2. **一致性Consistent**：事务操作前后，数据总量不变
> 3. **隔离性Isolated**：多个事务之间。相互独立。
> 4. **持久性Duration**：当事务提交或回滚后，数据库会持久化的保存数据。

#### 隔离级别

```mysql
多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题：
1. 脏读：一个事务，读取到另一个事务中没有提交的数据
2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。
3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。

```

> **四种隔离级别**：
>
> 1. read uncommitted：读未提交。产生的问题：脏读、不可重复读、幻读
> 2. read committed：读已提交 （Oracle）。产生的问题：不可重复读、幻读
> 3. repeatable read：可重复读 （MySQL默认）。产生的问题：幻读
> 4. serializable：串行化。可以解决所有的问题

> 数据库查询隔离级别：`select @@tx_isolation;`
>
> 数据库设置隔离级别：`set global transaction isolation level 级别字符串;`
>
> 注意：隔离级别从小到大安全性越来越高，但是效率越来越低

### 13. DCL 控制用户权限

#### 用户管理

| 操作 | 代码                                                         | 备注         |
| ---- | ------------------------------------------------------------ | ------------ |
| 添加 | CREATE USER `'用户名'@'主机名' `IDENTIFIED BY` '密码'`       | 创建一个用户 |
| 删除 | DROP USER `'用户名'@'主机名'`                                | 删除指定用户 |
| 修改 | UPDATE USER SET PASSWORD = PASSWORD`('新密码')`WHERE USER =` '用户名'` | 修改用户密码 |
| 修改 | SET PASSWORD FOR `'用户名'@'主机名' `= PASSWORD`('新密码')`  | 修改用户密码 |
| 查询 | 切换到mysql数据库后，SELECT * FROM `用户名`                  | 查询用户信息 |

> **重置root用户密码：**
>
> 1. 停止mysql服务：管理员运行cmd -- > net stop mysql 
> 2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables
> 3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功
> 4. 切换到mysql数据库：use mysql;
> 5. 重置密码：update user set password = password('你的新密码') where user = 'root';
> 6. 关闭两个窗口
> 7. 打开任务管理器，手动结束mysqld.exe 的进程
> 8. 启动mysql服务：net start mysql
> 9. 使用新密码登录

#### 权限管理

| 操作 | 代码                                                         | 备注     |
| ---- | ------------------------------------------------------------ | -------- |
| 查询 | SHOW GRANTS FOR `'用户名'@'主机名'`                          | 查询权限 |
| 授予 | grant `权限列表` on` 数据库名.表名` to `'用户名'@'主机名'`   | 授予权限 |
| 撤销 | revoke `权限列表` on` 数据库名.表名` from `'用户名'@'主机名'` | 撤销权限 |

> 通配符： % 表示可以在任意主机使用用户登录数据库；`localhost`主机名仅限于本机使用。
>
> 给user用户授予所有权限，在任意数据库任意表上：
>
> GRANT ALL ON * . * TO 'user' @ '%';

### 14. JDBC

```
Java DataBase Connectivity Java ：数据库连接
本质：官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。

```

> **操作步骤：**
>
> 1. **导入驱动jar包**
>    1. 复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下
>    2. 右键-->Add As Library
> 2. **注册驱动**（mysql5之后的驱动jar包可以省略注册驱动的步骤）
>
>  `Class.forName("com.mysql.jdbc.Driver");`
>
> 3. **获取数据库连接对象 Connection** 
>
>  `Connection conn = DriverManager.getConnection(String url, String user, String password);`
>
> 4. **定义sql语句**
>
> `String sql = "update account set balance = 500 where id = 1";`
>
> 5. **获取执行sql的对象 Statement**
>    ` Statement stmt = conn.createStatement();`
> 6. **执行sql**
>    `int count = stmt.executeUpdate(sql);`
> 7. **处理结果**
>
> `System.out.println(count);`
>
> 8. **释放资源**
>    `stmt.close();
>    conn.close();`

#### Connection 数据库连接对象 

```
Connection conn = DriverManager.getConnection(String url, String user, String password)；
url是指定的连接路径，例如jdbc:mysql://localhost:3306/数据库名称；
如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则可以简写为jdbc:mysql:///数据库名称

```

> 功能：
>
> - 获取执行sql 的对象：
>   - `Statement createStatement()`
>   - ` PreparedStatement prepareStatement(String sql)  `
> - 管理事务：
>   - 开启事务：`setAutoCommit(boolean autoCommit)` ：调用该方法设置参数为false，即开启事务
>   - 提交事务：`commit() `
>   - 回滚事务：`rollback() `

#### Statement 执行sql的对象

> 1. `boolean execute(String sql) `：可以执行任意的sql 
> 2. `int executeUpdate(String sql) `：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句。返回值为影响的行数，可以通过这个影响的行数判断DML语句是否执行成功：返回值>0的则执行成功，反之，则失败。
> 3. `ResultSet executeQuery(String sql)  `：执行DQL（select)语句

#### ResultSet 结果集对象

> 1. `boolean next()`：游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true。
> 2. `getXxx(参数)`：获取数据，XXX如：int getInt()，String getString()
>
> 参数可以是int，代表列的编号，从1开始；也可以是String，代表列名称。

```java
//代码展示,展示指定表中数据
public static void main(String[] args) {
        try (Connection conn = DriverManager.getConnection("jdbc:mysql:///db_day01", 				"root", "root");
             Statement stmt = conn.createStatement();
             ResultSet rs = stmt.executeQuery("select * from dept");)
        {
            while (rs.next()) {
                String DEPTON = rs.getString("DEPTNO");
                String DNAME = rs.getString("DNAME");
                String LOC = rs.getString("LOC");
                System.out.println(DEPTON + "---" + DNAME + "---" + LOC);
            }
        } catch (SQLException e) {
            e.printStackTrace();}}

```

### 15. JDBCUtils 抽取JDBC工具类

```java
//JDBCUtils 代码展示
public class JDBCUtils {
    private static String url;	//配置文件的四个参数
    private static String user;
    private static String password;
    private static String driver;	
    static{ //静态代码块，完成各个参数的赋值，省略了try...catch语句
            Properties pro = new Properties(); 
            InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream
                ("jdbc.properties");	//通过类加载器获得配置文件路径
            pro.load(is); 
            url = pro.getProperty("url");
            user = pro.getProperty("user");
            password = pro.getProperty("password");
            driver = pro.getProperty("driver");
            Class.forName(driver);}
	//获取Connection对象的方法
    public static Connection getConnection() throws SQLException {
        return DriverManager.getConnection(url, user, password);
    }
	//释放资源的方法，两种重载形式
    public static void close(Statement stmt,Connection conn){
        if( stmt != null){
            try {stmt.close();
            } catch (SQLException e) {
                e.printStackTrace();}}
        if( conn != null){
            try {conn.close();
            } catch (SQLException e) {               
                e.printStackTrace();}}}
    
    public static void close(ResultSet rs, Statement stmt, Connection conn){
        if( rs != null){
            try {rs.close();
            } catch (SQLException e) {
                e.printStackTrace();}}
        if( stmt != null){
            try {stmt.close();
            } catch (SQLException e) {
                e.printStackTrace();}}
        if( conn != null){
            try {conn.close();
            } catch (SQLException e) {
                e.printStackTrace();}}}}

```

### 16. 用户登录案例与sql注入问题

```
在拼接sql时，有一些sql的特殊关键字参与字符串的拼接，会造成安全性问题。PreparedStatement对象可以解决这个问题，预编SQL语句时使用“？”作为占位符，可以防止SQL注入，同时效率更高。

```

```java
// 使用JDBCUtils完成登录案例代码展示
public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.println("请输入用户名：");
        String username = sc.nextLine();
        System.out.println("请输入密码：");
        String password = sc.nextLine();
        boolean flag = login(username, password);
        if (flag) {
            System.out.println("登录成功");
        }else{
            System.out.println("用户名或密码错误");
        }}

public static boolean login(String username, String password){
        if (username == null || password == null) {
            return false;
        }
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = JDBCUtils.getConnection();
            /*特殊关键字拼接sql时会造成安全性问题，例如密码：a' or 'a' = 'a
            String sql = "select * from user where 
            	username = '"+username+"' and password = '"+password+"' ";
			stmt = conn.createStatement();
			rs = stmt.executeQuery(sql);
            */
            //使用PreparedStatement对象来解决,参数使用?作为占位符
            String sql = "select * from user where username = ? and password = ?";
            pstmt = conn.prepareStatement(sql);
            pstmt.setString(1, username); //setXXX方法，参数1为第几个问号的位置，参数2为赋值
            pstmt.setString(2, password);
            rs = pstmt.executeQuery();
            
            return rs.next();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            JDBCUtils.close(rs, pstmt, conn);
        }
        return false;}

```

### 17. JDBC事务控制

```java
public static void main(String[] args) {
    Connection conn = null;
    PreparedStatement pstmt1 = null;
    PreparedStatement pstmt2 = null;
    try {
        conn = JDBCUtils.getConnection();
        //开启事务
        conn.setAutoCommit(false);
        //张三 - 500
        String sql1 = "update account set balance = balance - ? where id = ?";
        //李四 + 500
        String sql2 = "update account set balance = balance + ? where id = ?";
        //获取执行sql对象
        pstmt1 = conn.prepareStatement(sql1);
        pstmt2 = conn.prepareStatement(sql2);
        //设置参数
        pstmt1.setDouble(1,500);
        pstmt1.setInt(2,1);
        pstmt2.setDouble(1,500);
        pstmt2.setInt(2,2);
        //执行张三sql
        pstmt1.executeUpdate();
        // 手动制造异常
        int i = 3/0;
        //执行李四sql
        pstmt2.executeUpdate();
        //提交事务
        conn.commit();
    } catch (Exception e) {  //发生任何异常，事务回滚
        try {
            if(conn != null) {
                conn.rollback();
            }
        } catch (SQLException e1) {
            e1.printStackTrace();
        }
        e.printStackTrace();
    }finally {
        JDBCUtils.close(pstmt1,conn);
        JDBCUtils.close(pstmt2,null);
    }

```

### 18. 数据库连接池

```
本质是一个存放数据库连接的容器(集合)。当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。

```

> 好处：针对数据库连接对象的复用，可以节约创建以及销毁数据库连接对象的资源，提高用户访问效率。
>
> 标准接口：DataSource 
>
> 常用方法：获取连接：getConnection()；归还连接：Connection.close()

#### C3P0 数据库连接池技术

```java
//使用步骤：
//1. 导入jar包：【c3p0-0.9.5.2.jar】和【mchange-commons-java-0.2.12.jar】
//2. 定义配置文件：【c3p0.properties】或【c3p0-config.xml】直接放在src目录下
//3. 创建数据库连接池对象
DataSource ds = new ComboPooledDataSource();
//4. 获取连接对象
Connection conn = ds.getConnection();

```

#### Druid 数据库连接池技术

```java
//使用步骤：
//1. 导入jar包【druid-1.0.9.jar】
//2. 定义配置文件：properties文件，可以叫任意名称，放在任意目录下
InputStream is = Demo.class.getClassLoader().getResourceAsStream("druid.properties");
//3. 加载配置文件：
Properties pro = new Properties(); 
pro.load(is);
//4. 获取数据库连接池对象：通过工厂来来获取 
DataSource ds = DruidDataSourceFactory.createDataSource(pro);
//5. 获取连接：
Connection conn = ds.getConnection();

```

```java
//代码展示：根据Druid技术，定义工具类JDBCUtils
private static DataSource ds;
//静态代码块中加载配置文件，生成DataSource对象
static{	
    	Properties pro = new Properties();           	         
        pro.load
            (DruidUtils.class.getClassLoader().getResourceAsStream("druid.properties"));
        ds = DruidDataSourceFactory.createDataSource(pro);
}
//返回DataSource对象的方法，用于SpringJDBC
public static DataSource getDataSource(){
    return ds;
}
//返回Connection对象的方法
public static Connection getConnection() throws SQLException {
    return ds.getConnection();
}
//两个重载的归还连接方法
public static void close(Statement stmt, Connection conn) {
    close(null, stmt, conn);
}
public static void close(ResultSet rs, Statement stmt, Connection conn) {
    if (rs != null) {
        try {rs.close();
            } catch (SQLException e) {
            e.printStackTrace();}}
    if (stmt != null) {
        try {stmt.close();
            } catch (SQLException e) {
            e.printStackTrace();}}
    if (conn != null) {
        try {conn.close();
            } catch (SQLException e) {
            e.printStackTrace();}}}

```

### 19. Spring JDBC

```java
Spring框架对JDBC的简单封装，提供了一个JDBCTemplate对象简化JDBC的开发。

```

> 常用方法：
>
> - 使用数据源DataSource，创建JdbcTemplate对象：
>
> `JdbcTemplate template = new JdbcTemplate(ds);`
>
> - update()：执行DML增、删、改语句：
>
> `int count = template.update(sql);`
>
> - queryForMap()：将列名作为key，值作为value，将一条记录封装为一个map集合
>
> `Map<String, Object> map = template.queryForMap(sql);`
>
> - queryForList()：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中
>
> `List<Map<String, Object>> list = template.queryForList(sql);`
>
> - query()：查询结果，将结果封装为JavaBean对象
>
> `List<T> list = template.query(sql, new BeanPropertyRowMapper<T>(T.class));`
>
> - queryForObject：查询结果，将结果封装为对象，一般用于获取单行单列的数值数据
>
> `String count = template.queryForObject(sql, String.class);`



# Web前端知识点总结

### 1. B/S架构资源

> **静态资源：**使用静态网页开发技术发布的资源
>
> - 所有用户访问，得到的结果是一样的。
> - 如：文本，图片，音频、视频, HTML,CSS,JavaScript。
> - 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏器。
> - 用HTML搭建基础网页， 用CSS美化、布局页面，用JavaScript控制页面的元素，让页面有动态效果。
>
> **动态资源：**使用动态网页及时发布的资源
>
> - 所有用户访问，得到的结果可能不一样。
> - 如：jsp/servlet,php,asp...。
> - 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器。

### 2. HTML

```
Hyper Text Markup Language 超文本标记语言，是最基础的网页开发语言
```

> **超文本**：用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本
>
> **标记语言**：由标签<标签名称> 构成的语言，如html、xml，不属于编程语言。
>
> **标签**：标签可以嵌套，不区分大小写，建议用小写，分为两类：
>
> - 围堵标签：有开始标签和结束标签。如 <html> </html>
> - 自闭标签：开始标签和结束标签在一起。如 < br/>

| 标签                     | 说明                                               | 属性                   |
| :----------------------- | -------------------------------------------------- | ---------------------- |
| < html>                  | 文档的根标签                                       |                        |
| < head>                  | 头标签，用于指定html文档的一些属性，引入外部的资源 |                        |
| < title>                 | 标题标签                                           |                        |
| < body>                  | 体标签                                             |                        |
| < !DOCTYPE html >        | html5中定义该文档是html文档                        |                        |
| < !-- 注释内容 -- >      | 注释                                               |                        |
| < h1> to < h6>           | 标题标签，h1到h6字体大小逐渐递减                   |                        |
| < p>                     | 段落标签                                           |                        |
| < br/>                   | 换行标签                                           |                        |
| < hr>                    | 展示一条水平线                                     | color/width/size/align |
| < b>                     | 字体加粗                                           |                        |
| < i>                     | 字体斜体                                           |                        |
| < font>                  | 字体标签                                           | color/face/size        |
| < center>                | 文本居中                                           |                        |
| < img src=" " alt=" ">   | 展示图片（src为图片URL，alt为图片替代文本）        | align/height/width     |
| < ol> < li>< /li> < /ol> | 有序列表                                           | type                   |
| < ul> < li>< /li> < /ul> | 无序列表                                           | type                   |
| < a href="">< /a>        | 超链接标签                                         | target( _self/ _blank) |
| < div>                   | 块级标签                                           |                        |
| < span>                  | 行内标签                                           |                        |
| < header>                | 页眉                                               |                        |
| < footer>                | 页脚                                               |                        |

> **超链接的功能**：1. 生成可以被点击的样式；	2. 点击后跳转到href指定的url
>
> 若需要保留1功能，去掉2功能，则：`href = "javascript:void(0)"`

### 3. 表格标签

> **table**：定义表格
>
> - width：宽度
> - border：边框
> - cellpadding：定义内容和单元格的距离
> - cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条
> - bgcolor：背景色
> - align：对齐方式
>
> **tr**：定义行
>
> - bgcolor：背景色
> - align：对齐方式
>
> **td**：定义单元格
>
> - colspan：合并列
> - rowspan：合并行
>
> **th**：定义表头单元格

### 4. 表单标签

```
用于采集用户输入的数据，和服务器进行交互的标签。
```

> **action**：指定提交数据的URL，若是写一个#，那么就是提交到本页面
>
> **method**：指定提交方式，表单项中的数据要想被提交，必须指定其name属性
>
> - get：请求参数会在地址栏中显示，参数大小不能超过255， 不太安全
> - post：请求参数不会在地址栏中显示，参数的大小没有限制，多用于提交视频和图片，比较安全
>
> **input**：可以通过type属性值，改变元素展示的样式
>
> - text：文本输入框，默认值（参数placeholder：指定输入框的提示信息）
> - password：密码输入框
> - radio：单选框，多个单选框的name属性值必须一样，在value属性中指定其被选中后提交的值
> - checkbox：在value属性中指定其被选中后提交的值
> - file：文件选择框
> - hidden：隐藏域，用于提交一些信息，不需要用户输入
> - submit：提交按钮，可以提交表单
> 	 image：图片提交按钮，src属性指定图片的路径	
>
> **label**：label的for属性一般会和input的id属性值对应。点击label区域，会让对应的input输入框获取焦点
>
> **select**：下拉列表，子元素option为指定列表项
>
> **textarea**：文本域，cols：指定列数， rows：默认多少行

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>FormTest</title>
</head>
<body>

<form action="#" method="get">
    姓名：<input type="text" placeholder="请输入姓名" name = "username"> <br>
    密码：<input type="password" placeholder="请输入密码" name="password"> <br>
    性别：<input type="radio" name = "gender" value="男"> 男
          <input type="radio" name = "gender" value="女"> 女<br>
    爱好：<input type="checkbox" name = "hobby" value = 1> 小米
          <input type="checkbox" name = "hobby" value = 2> 华为
          <input type="checkbox" name = "hobby" value = 3> 锤子<br>
    <label for="file">文件</label>：<input type="file" id="file"><br>
    隐藏：<input type="hidden"><br>
    提交：<input type="submit" value="提交"><br>
	图片提交：<input type="image" src="baidu.png"><br>
    地区：<select name="place" id="place" ><br>
    <option>请选择地区</option>
    <option value ="北京">北京</option>
    <option value="深圳">深圳</option>
    <option value="厦门">厦门</option>
    </select>
</form>
</body>
</html>
```

### 5. CCS

```
Cascading Style Sheets 层叠样式表，多个样式可以作用在同一个html的元素上，用于页面美化和布局控制
好处：功能强大，将内容展示和样式控制分离，易于分工合作，提高效率，同时可以使页面中的样式得以复用。
```

> **CCS与Html的结合：**
>
> 1. 内联样式：在标签内使用style属性指定css代码：
>
> `<div style="color:red;">hello css</div>`
>
> 2. 内部样式： 在head标签内，定义style标签，style标签的标签体内容就是css代码：
>
> ```html
> <head>
>     <style>
>         div{color:blue;}
>     </style>
> </head>
> <body>
> 	<div>hello css</div>
> </body>
> ```
>
> 3. 外部样式：先定义css资源文件，再在head标签内，定义link标签，引入外部的资源文件
>
> `<link rel="stylesheet" href="css/a.css">`
>
> （也可以写为：`<style>  @import "a.css";  </style>`）

### 6. CCS选择器

```
选择器：筛选具有相似特征的元素
选择器 {
		属性名1:属性值1;
		属性名2:属性值2;
		...
		}
```

> **基础选择器：**
>
> 1. **id选择器**：选择具体的id属性值的元素，建议在一个html页面中id值唯一。语法：`#id属性值{}`
> 2. **类选择器**：选择具有相同的class属性值的元素。语法：`.class属性值{}`
> 3. **元素选择器**：选择具有相同标签名称的元素。语法：`标签名称{}`
>
> **扩展选择器：**
>
> 1. 选择所有元素。语法：` *{}`
> 2. 并集选择器：同时筛选多个选择器。语法：`选择器1,选择器2{}`
> 3. 子选择器：筛选选择器1元素下的选择器2元素。 语法：`选择器1 选择器2{}`
> 4. 直系父选择器：筛选选择器2的父元素选择器1。语法：`选择器1 > 选择器2{}`
> 5. 属性选择器：选择元素名称，属性名=属性值的元素。语法：`元素名称[属性名="属性值"]{}`
> 6. 伪类选择器：选择一些元素具有的状态。语法：`元素：状态{}`  如：超链接标签 < a>：
>    - `a:link{}`：初始化的状态
>    - `a:visited{}`：被访问过的状态
>    - `a:active{}`：正在访问状态
>    - `a:hover{}`：鼠标悬浮状态

### 7. CCS属性

> 1. 字体、文本：
>    - `font-size`：字体大小
>    - `color`：文本颜色
>    - `text-align`：对齐方式
>    - `line-height`：行高 
> 2. 背景`background`：可以设置背景色或填充图片
> 3. 边框`border`：设置边框，符合属性
> 4. 尺寸`width`：宽度height：高度
> 5. 盒子模型：控制布局
>    - `margin`：外边距
>    - `padding`：内边距，默认情况下内边距会影响整个盒子的大小
>    - `box-sizing: border-box`;  设置盒子的属性，让width和height就是最终盒子的大小
> 6. 浮动：`float`，脱离文档流布局（靠左：left；靠右：right）

### 8. JavaScript基本语法

```
JavaScript是一门客户端脚本语言，运行在客户端的浏览器中，每一个浏览器都有JavaScript的解析引擎。
JS可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。
脚本语言：不需要编译，可以直接被浏览器内核解析执行的语言。
客户端脚本语言的标准：ECMAScript，统一了所有客户端脚本语言的编码方式。
```

#### 结合html

- 内部JS：定义< script>，标签体内容就是js代码
- 外部JS： 定义< script>，通过src属性引入外部的js文件

> 注意： < script>可以定义多个，可以定义在html页面的任何地方，但是定义的位置会影响执行顺序。
>
> 建议书写位置：1. head标题中   2. body最下方

#### 数据类型

> - 原始数据类型：五种
>   1. number：数字。包含整数、小数、NaN(Not a Number,代表不是数字的数字类型)
>   2. string：字符串。 "abc"、 "a"、 'abc'
>   3. boolean：true和false
>   4. null：一个对象为空的占位符(注意：null运算是其typeof类型为object，属设计错误)
>   5. undefined：未定义。一个没有初始化的变量，会被默认赋值为undefined
> - 引用数据类型：对象

#### 变量

```
JavaScript是弱类型语言，定义变量的语法：var 变量名 = 初始化值
```

> - 强类型：在开辟变量存储空间时，定义了空间将来存储数据的数据类型。只能存储固定类型的数据。
> - 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。

#### 运算符

> - 被正负号修饰的运算数（+(-)）会自动转换为number类型，如果字面值不是数字，则转为NaN，true转为1，false转为0。
> - ==：直接比较字面值，类型不同时，先进行类型转换，再比较
>
> ===：全等于，在比较之前，先判断类型，如果类型不一样，则直接返回false
>
> - 进行逻辑运算时：
>   1. number：0或NaN为假，其他为真
>   2. string：除了空字符串("")，其他都是true
>   3. null&undefined:都是false
>   4. 对象：所有对象都为true

### 9. JavaScript基本对象

#### Function:函数对象

> - 创建：
>   1. var fun = new Function(形式参数列表,方法体)；
>   2. function 方法名称(形式参数列表){
>      方法体
>      }
>   3. var 方法名 = function(形式参数列表){
>      方法体
>      }
> - 方法：
>
> 		length:代表形参的个数
>
> - 特点：
>   1. JS中不存在方法重载，方法的调用只与方法的名称有关，和参数列表无关
>   2. 方法是一个对象，如果定义名称相同的方法，后执行的方法会覆盖之前的方法
>   3. 第二种创建方法执行优先级较高，若定义名称相同，会被第三种创建方法覆盖
>   4. 在方法声明中有一个隐藏的内置对象（数组）arguments，封装所有的实际参数

#### Array:数组对象

> - 创建：
>   1. var arr = new Array(元素列表);
>   2. var arr = new Array(默认长度);
>   3. var arr = [元素列表]
> - 方法：
>   1. join(参数)：将数组中的元素按照指定的分隔符拼接为字符串
>   2. push(参数)：向数组的末尾添加一个或更多元素，并返回新的数组长度
> - 特点：
>
> JS中的数组长度可变，元素类型也可变。

#### Date:日期对象

> - 创建：var date = new Date();
> - 方法：
>   toLocaleString()：返回当前date对象对应的时间本地字符串格式
>   getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差

#### RegExp:正则表达式对象

```
正则表达式也是一个字符串，是专门解决字符串规则匹配的工具，用来定义匹配规则

```

> - 创建：
>   1. var reg = new RegExp("正则表达式");
>   2. var reg = /正则表达式/; （表达式不需要双引号，不需要加转义字符）
> - 方法：
>   1. test(参数)：验证指定的字符串是否符合正则定义的规范	
>   2. match(参数)：可以匹配正则，返回的是匹配正则的内容

|  表达式  |                     含义                     |
| :------: | :------------------------------------------: |
|    x     |                    字符 x                    |
|   \\\    |                  反斜线字符                  |
|  [abc]   |             a、b 或 c（简单类）              |
|  [^abc]  |       任何字符，除了 a、b 或 c（否定）       |
| [a-zA-Z] | a 到 z 或 A 到 Z，两头的字母包括在内（范围） |
|    \w    |            单词字符：[a-zA-Z_0-9]            |
|    X?    |             X，一次或一次也没有              |
|    X*    |                X，零次或多次                 |
|    X+    |                X，一次或多次                 |
|   X{n}   |                 X，恰好 n 次                 |
|  X{n,}   |                 X，至少 n 次                 |
|  X{n,m}  |        X，至少 n 次，但是不超过 m 次         |
|    ^     |                     开始                     |
|    $     |                     结束                     |

#### Global:全局对象

```
Global中封装的方法不需要对象就可以直接调用

```

> 方法：
>
> 1. encodeURI()：url编码
> 2. decodeURI()：url解码
> 3. encodeURIComponent()：url编码（编码的字符范围更大）
> 4. decodeURIComponent()：url解码
> 5. parseInt()：将字符串转为数字（逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number）
> 6. isNaN()：判断一个值是否是NaN（NaN六亲不认，连自己都不认。NaN参与的==比较全部问false）
> 7. eval()：将一个字符串转换为JS代码，并把它作为脚本代码来执行

### 10. BOM

```
Browser Object Model 浏览器对象模型：将浏览器的各个组成部分封装成为对象

```

#### Window:窗口对象

> - 弹出框相关方法：
>
>   1. alert()：显示带有一段消息和一个确认按钮的警告框
>   2. confirm()：显示带有一段消息以及确认按钮和取消按钮的对话框。
>      - 如果用户点击确定按钮，则方法返回true
>      - 如果用户点击取消按钮，则方法返回false
>   3. prompt()：显示可提示用户输入的对话框，返回用户输入的值。
>
> - 打开关闭窗口相关方法：
>
>   1. close()：关闭调用此方法的浏览器窗口
>   2. open()：打开一个新的浏览器窗口，返回新的window对象
>
> - 定时器相关方法：
>
>   1. setTimeout(js代码或者方法对象，毫秒值)：在指定的毫秒数后调用函数或计算表达式
>
>      返回值：唯一标识，用于取消定时器
>
>   2. clearTimeout()：取消由 setTimeout() 方法设置的 timeout
>
>   3. setInterval()：按照指定的周期（以毫秒计）来调用函数或计算表达式
>
>   4. clearInterval()：取消由 setInterval() 设置的 timeout

> **注意**：Window可以获取其他BOM对象【history/location/navigator/screen】，DOM对象【document】。
>
> Window对象不需要创建可以直接使用，window.方法名()，且window本身可省略

#### Location:地址栏对象

> - 方法：reload()：重新加载当前文档，同刷新

#### History:历史记录对象

> - 方法：
>   1. back()：加载 history 列表中的前一个 URL
>   2. forward()：加载 history 列表中的下一个 URL
>   3. go(参数)：加载 history 列表中的某个具体页面（参数：前进(正数)或后退(负数)几个历史记录）
>   4. length：返回当前窗口历史列表中的 URL 数量。

#### Navigator:浏览器对象

#### Screen:显示器屏幕对象

### 11. DOM

```
Document Object Model 文档对象模型：将标记语言文档的各个组成部分封装为对象。可以使用这些对象对标记语言文档进行CRUD的动态操作。
W3C标准中，DOM被分为三个不同的部分：
1. 核心DOM -针对任何结构化文档的标准模型
2. XML DOM -针对XML文档的标准模型
3. HTML DOM -针对HTML文档的标准模型

```

#### Document:文档对象   

> - 获取：在HTML DOM模型中可以通过window对象来获取
> - 获取Element对象方法：
>   1. getElementBy**Id**()：根据id属性值获取元素对象。
>   2. getElementsBy**TagName**()：根据标签名称获取元素对象们，返回值是一个数组
>   3. getElementsBy**ClassName**()：根据Class属性值获取元素对象们，返回值是一个数组
>   4. getElementsBy**Name**()：根据name属性值获取元素对象们，返回值是一个数组
> - 创建其他DOM对象方法：
>   1. createAttribute(name)：创建Attribute属性对象
>   2. createComment()：创建Comment注释对象
>   3. createElement()：创建Element元素对象
>   4. createTextNode()：创建Text文本对象

#### Element:元素对象

> - 属性：
>   1. previousSibling：获取该元素的前一个节点
>   2. nextSibling：获取该元素的后一个节点
>   3. innerHTML：可以获取标签内所有的内容，包括标签
>   4. innerText：可以获取标签内所有的文本内容，不包括标签
> - 方法：
>   1. removeAttribute()：删除属性
>   2. setAttribute()：设置属性

#### Node:节点对象

> - 特点：所有dom对象都可以被认为是一个节点
> - 属性：parentNode 返回节点的父节点
> - 方法：
>   1. appendChild()：向节点的子节点列表的结尾添加新的子节点。
>   2. removeChild()：删除（并返回）当前节点的指定子节点。
>   3. replaceChild()：用新节点替换一个子节点。

#### Attribute:属性对象

#### Text:文本对象

#### Comment:注释对象

### 12. 事件监听机制

```
概念：某些组件（按钮，文本输入框...）被执行了某些操作（单击，双击，键盘按下，鼠标移动...）后，触发某些代码的执行。	

```

> 常见的事件：
>
> 1. 点击事件：
>    - onclick：单击事件
>    - ondblclick：双击事件
> 2. 焦点事件：（input框里面有光标的时候，叫获取焦点）
>    - onblur：失去焦点
>    - onfocus：元素获得焦点
> 3. 加载事件：
>    - onload：在页面当中所有的内容加载完之后触发，常作为入口函数
>
>   `window.onload = function(){}`
>
> 4. 鼠标事件：
>    - onmousedown	鼠标按钮被按下
>    	 onmouseup	     鼠标按键被松开
>    	 onmousemove	鼠标被移动
>    	 onmouseover	  鼠标移到某元素之上
>    	 onmouseout	    鼠标从某元素移开
> 5. 键盘事件：
>    - onkeydown	某个键盘按键被按下
>    	 onkeyup	 	某个键盘按键被松开
>    	 onkeypress	某个键盘按键被按下并松开
> 6. 选择和改变：
>    - onchange	域的内容被改变。失焦后触发
>    	 onselect	   文本被选中
> 7. 表单事件：
>    - onsubmit	确认按钮被点击
>    	 onreset	     重置按钮被点击

### 13. 综合案例

#### 动态表格

```html
<head>
    <meta charset="UTF-8">
    <title>动态表格</title>
    <style>
        table{
            border: 1px solid;
            margin: auto;
            width: 500px;
        }
        td,th{
            text-align: center;
            border: 1px solid;
        }
        div{
            text-align: center;
            margin: 50px;
        }
    </style>
</head>
<body>

<div>
    <input type="text" id="id" placeholder="请输入编号">
    <input type="text" id="name"  placeholder="请输入姓名">
    <input type="text" id="gender"  placeholder="请输入性别">
    <input type="button" value="添加" id="btn_add">
</div>

<table>
    <caption>学生信息表</caption>
    <tr>
        <th>编号</th>
        <th>姓名</th>
        <th>性别</th>
        <th>操作</th>
    </tr>
</table>

<script>
//给添加按钮绑定单击事件
document.getElementById("btn_add").onclick = function () {
	//获取文本框内容
    var id = document.getElementById("id").value;
    var name = document.getElementById("name").value;
    var gender = document.getElementById("gender").value;
    //将输入的内容添加到表格    
	var table = document.getElementsByTagName("table")[0];
	table.innerHTML += '<tr>\n' +'<td>'+ id +'</td>\n' +
		'<td>'+ name +'</td>\n' +'<td>'+ gender +'</td>\n' +
		'<td><a href="javascript:void(0)" onclick="delTr(this)">删除</a></td>\n' +'</tr>';
}
//定义删除方法
function delTr(obj) {  //节点关系：a -> td -> tr -> table
	var table = obj.parentNode.parentNode.parentNode;
	var tr = obj.parentNode.parentNode;
	table.removeChild(tr);
}
</script>

```

#### 表单校验

```html
<script>
// 校验name的方法
function checkName() {
	var name = document.getElementById("name").value;
	var flag = /^[a-zA-Z]{1,12}$/.test(name);
	var name_add = document.getElementById("span_name");
	if(flag) {
		name_add.innerHTML = "<img height = '25' width = '35' " +"src = 'img/gou.png'>"
	}else{
		name_add.innerHTML = "姓名格式有误";
	}
	return flag;
}
</script>
<!--表单校验的第一种方式-->
var form = document.getElementById("form");
form.onsubmit = checkName;
<!--表单校验的第二种方式-->
<form action="#" id="form" onsubmit="return checkName()">
    ...
</form>

```

### 14. Bootstrap

```
一个前端开发的响应式布局框架，基于HTML、CSS、JavaScript开发，简洁灵活，使得 Web 开发更加快捷。

```

```html
<!--快速入门：导入Bootstrap文件和jQuery包，创建html页面，引入必要的资源文件： -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- 上述3个meta标签*必须*放在最前面，任何其他内容都必须跟随其后！ -->
    <title>Index</title>

    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <!-- Bootstrap中js插件都是依赖于jquery的，要第一步引入-->
    <script src="js/jquery-3.2.1.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="js/bootstrap.min.js"></script>
</head>
<body>
	<h1>Hello World！</h1>
</body>
</html>

```

#### 响应式布局

```
响应式布局可以使同一套页面兼容不同分辨率的设备。
实现方式依赖于栅格系统：将一行平均分成12个格子，可以指定元素占几个格子。

```

> 实现步骤：
>
> 1. 定义容器：作用相当于< table>，样式：< div>
>
> 容器分类：1. container：两边留白；     2. container-fluid：每一种设备都是100%宽度
>
> 2. 定义行：作用相当于< tr>，样式：< row>
> 3. 定义元素：指定元素使用的设备和格子数目，样式：col-设备代号-格子数目
>
> 设备代号：
>
> - xs：超小屏幕 手机 (<768px)
> - sm：小屏幕 平板 (≥768px)
> - md：中等屏幕 桌面显示器 (≥992px)
> - lg：大屏幕 大桌面显示器 (≥1200px)
>
> 注意：
>
> 1. 一行中如果格子数目超过12，则超出部分自动换行
> 2. 栅格类属性可以向上兼容，小尺寸设备代号兼容大尺寸设备显示
> 3. 如果设备真实宽度小于栅格指定的设备代码的临界值，会一个元素占满一整行



# Web核心知识点总结

### 1. XML概述

```
Extensible Markup Language 可扩展标记语言，自定义标签，使用标记语言的特性描述数据结构，主要作为配置文件用于数据的存储以及传输。
```

> **语法特点：**
>
> 1. 文档后缀名：xml
> 2. 第一行必须定义为文档声明
> 3. 文档中有且仅有一个根标签，所有标签必须闭合，区分大小写
> 4. 属性值必须加引号
>
> **文档声明：**
>
> 1. 格式：`<?xml version="1.0" encoding = "UTF-8" standalone = "yes"?>`
> 2. version 版本号是必须的属性；
> 3. encoding 告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1 不支持汉
> 4. standalone 是否独立，取值yes为不依赖其他文件，取值no为依赖其他文件
>
> **指令：**
>
> 1. 结合CSS指令：` < ?xml-stylesheet type="text/css" href="a.css" ?>`
> 2. CDATA区（数据原样展示，不被解析）：` <![CDATA[ 数据 ]]>`

### 2. XML约束

```
规定xml文档的书写规则，不影响解析，主要有两种技术：
DTD:一种简单的约束技术，约束的内容较为简单；Schema:一种复杂的约束技术，约束的内容较为详细
```

> **DTD引入：**
>
> - 内部dtd：将约束规则定义在xml文档中
> - 外部dtd：将约束的规则定义在外部的dtd文件中
>
> 本地：`< !DOCTYPE 根标签名 SYSTEM "dtd文件的位置">`
>
> 网络：`< !DOCTYPE 根标签名 PUBLIC "dtd文件名字" "dtd文件的位置URL">`
>
> **Schema引入：**
>
> ```
> 1. 填写xml文档的根元素:
> 	<beans
> 2. 引入xsd约束的标准，并声明前缀xsi：
> 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance
> 3. 给xsi的location参数赋值，说明引入的xsd文件路径，路径前是xsd文件的命名空间：
> 	xsi:schemaLocation="
>      http://www.springframework.org/schema/beans（命名空间） 		
>      http://www.springframework.org/schema/beans/spring-beans.xsd（文件路径）
>      http://www.springframework.org/schema/context （命名空间）
>      http://www.springframework.org/schema/context/spring-context.xsd（文件路径）
>      http://www.springframework.org/schema/mvc（命名空间）
>      http://www.springframework.org/schema/mvc/spring-mvc.xsd"（文件路径）
> 4. 为每一个xsd约束声明一个前缀，作为标识：
> 	xmlns="http://www.springframework.org/schema/beans"（无前缀为默认）
> 	xmlns:context="http://www.springframework.org/schema/context"（前缀context）
> 	xmlns:mvc="http://www.springframework.org/schema/mvc"（前缀mvc）>	
> ```

### 3. XML解析

```
操作xml文档，将文档中的数据读取到内存中
```

> **解析的方式：**
>
> 1. DOM：将标记语言文档一次性加载进内存，在内存中形成一颗DOM树
>
> 优点：操作方便，可以对文档进行CRUD操作；缺点：占内存
>
> 2. SAX：逐行读取，基于事件驱动
>
> 优点：不占内存；缺点：只能读取，不能增删改
>
> **常见解析器**：
>
> 1. JAXP：sun公司提供的解析器，支持dom和sax两种思想
> 2. DOM4J：一款非常优秀的解析器。应用广泛，对XPath支持度高
> 3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据
> 4. PULL：Android操作系统内置的解析器，sax方式的

#### Jsoup解析器

> Jsoup方法：
>
> 1. parse解析，返回Document：
>    - parse(File in, String charsetName)：解析xml或html文件的
>    - parse(String html)：解析xml或html字符串
>    - parse(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象
> 2. 通过Document的方法获取Elements对象：
>    - getElementById(String id)：根据id属性值获取唯一的element对象
>    - getElementsByTag(String tagName)：根据标签名称获取元素对象集合
>    - getElementsByAttribute(String key)：根据属性名称获取元素对象集合
>    - getElementsByAttributeValue(String key, String value)：根据属性名和属性值获取元素对象集合
> 3. 通过Elements集合获取元素Element（Elements可当做ArrayList使用）：
>    - String attr(String key)：根据属性名称获取属性值
>    - String text():获取文本内容
>    - String html():获取标签体的所有内容(包括子标签及其字符串内容)
> 4. selector选择器：
>    - document.select(String cssQuery)，返回Elements
>    - cssQuery语法参考Selector类中定义的语法：
>
> ```java
>    //示例：获取student标签并且number属性值为heima_0001的age子标签
>   	document.select("student[number=\"heima_0001\"] > age");
> ```

```java
//Jsoup使用步骤
//0.导入jar包：jsoup-1.11.2.jar
//1.获取要解析文件的路径
String path = Demo01Jsoup.class.getClassLoader().getResource("url").getPath();
//2.通过Jsoup的方法解析，加载文档进内存，获取Document对象
Document document = Jsoup.parse(new File(path), "utf-8");
//3.获取元素对象集合
Elements elements = document.getElementsByTag("name");
//4.获取单个元素对象
Element element = elements.get(1);
System.out.println(element.html());	//获取标签体的所有内容(包括子标签)
System.out.println(element.text());	//获取文本内容
```

#### Xpath路径语言

```
XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言，使用Jsoup的Xpath需要额外导入jar包，Jsoup只支持XPath1.0。
```

```java
//XPath使用演示：
//1.获取要解析文件的路径
String path = Demo01Jsoup.class.getClassLoader().getResource("url").getPath();
//2.通过Jsoup的方法解析，加载文档进内存，获取Document对象
Document document = Jsoup.parse(new File(path), "utf-8");
//3.根据document对象，创建JXDocument对象
JXDocument jxDocument = new JXDocument(document);
//4.结合xpath语法查询符合条件的结果并输出
List<JXNode> jxNodes = jxDocument.selN("条件");
for (JXNode jxNode : jxNodes) {
    System.out.println(jxNode);}
//条件示范：
//查询所有student标签：
jxDocument.selN("//student"); 
//查询所有student标签下的name标签：
jxDocument.selN("//student/name"); 
//查询student标签下带有id属性的name标签：
jxDocument.selN("//student/name[@id]"); 
//查询student标签下带有id属性的name标签，并且id属性值为itcast：
jxDocument.selN("//student/name[@id='itcast']"); 
```

### 4. web服务器软件

```
web服务器软件搭载在服务器上，可以部署web项目，让用户通过浏览器来访问这些项目
常见的java相关的web服务器软件：
	webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费。
	webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费。
	JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费。
	Tomcat：Apache基金组织，中小型的JavaEE服务器，支持少量的JavaEE规范servlet/jsp，开源，免费。
```

#### Tomcat介绍

> 启动：打开bin/startup.bat
>
> 关闭：打开bin/shutdown.bat或在命令行ctrl+c
>
> 部署项目的三种方式：
>
> 1. 将项目打包成war(zip)包，放到`webapps`目录下即可
>
> war包会自动解压缩，若需部署多个项目，可以放到虚拟目录中区分不同的项目。
>
> 2. 配置`conf/server.xm`l文件
>    - docBase:项目存放的路径  
>    - path：虚拟目录
> 3. 在`conf\Catalina\localhost`创建xml文件
>
> xml文件名为虚拟目录名
>
> xml文件中编写<Context docBase="D:\hello" />

### 5. Servlet接口

```
Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。
Java类只要实现了这个接口，那么这个类就可以被浏览器访问到（让该类代码执行）。
```

#### 访问原理

> 1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径
>    2. 查找web.xml文件，是否有对应的<url-pattern>标签体内容。
>    3. 如果有，则在找到对应的<servlet-class>全类名
>    4. tomcat会将字节码文件加载进内存，并且通过反射机制创建其对象
>    5. 调用其方法

#### 使用步骤

> 1. 创建JavaEE项目
> 2. 定义一个类，实现Servlet接口`public class ServletDemo1 implements Servle`
> 3. 实现接口中的抽象方法
> 4. **配置Servlet**
>
> ```java
> //方法一： 
> 在web.xml中配置：
> 	<!--配置Servlet -->
> 	<servlet>
> 	        <servlet-name>demo1</servlet-name>
> 	        <servlet-class>cn.itcast.web.servlet.ServletDemo1</servlet-class>
> 	</servlet>
> 	
> 	<servlet-mapping>
> 		<servlet-name>demo1</servlet-name>
> 		<url-pattern>/demo1</url-pattern>
> 	</servlet-mapping>
> 	/*在<servlet>标签下配置 <load-on-startup>，赋值：
> 		值为负数：第一次被访问时创建
> 	    值为非负数：在服务器启动时创建*/    
> //方法二：
> 在类上使用@WebServlet("/资源路径")注解，进行配置 (Servlet3.0版本以上)
> //一个Servlet可以定义多个访问路径 ： @WebServlet({"/d4","/dd4","/ddd4"})
> //路径定义规则：
>       1. /xxx/xxx:多层路径，目录结构
>       2. *.do：扩展名匹配(任何以.do结尾都可以匹配到)                             
> ```

#### 内部方法

> ```java
> @Override
> public void init(ServletConfig servletConfig) throws ServletException {
> 	//Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的
> }
> @Override
> public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException {
>  //每次访问Servlet时，Service方法都会被调用一次。
> }
> @Override
> public void destroy() {
> 	//destroy方法在Servlet服务器正常关闭之前才会执行，一般用于释放资源。
> }
> @Override
> public String getServletInfo() {   //不常用
>  return null;
> }
> @Override
> public ServletConfig getServletConfig() {   //不常用
>  return null;  
> }
> ```

#### 体系结构

```flow
op1=>operation: Servlet -- 接口
op2=>operation: GenericServlet -- 抽象类
op3=>operation: HttpServlet  -- 抽象类
op1->op2->op3
```

> - GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象。继承后实现service()方法即可。
> - HttpServlet：对http协议的一种封装，简化操作。复写doGet/doPost方法。

### 6. HTTP协议

```
Hyper Text Transfer Protocol 超文本传输协议：定义了，客户端和服务器端通信时，发送数据的格式
客户端和服务器必须同时遵守HTTP协议，才能通信
```

> 特点：
>
> 1. 基于TCP/IP的高级协议
> 2. 默认端口号:80
> 3. 基于请求/响应模型的:一次请求对应一次响应
> 4. 无状态的：每次请求之间相互独立，不能交互数据

> 版本：
>
> - 1.0：每一次请求响应都会建立新的连接Connection，较耗费资源
> - 1.1：复用连接，Connection复用，省略了重复创建连接所耗费的资源
> - 2.0：1.X版本都是使用文本传输数据，2.0开始使用字节传输，多路复用，速率提升

### 7. 请求消息数据格式

```html
POST /login.html	HTTP/1.1  <!--1.请求行：请求方式+请求url+请求协议/版本-->
Host: localhost     <!--2.请求头：IP地址+User-Agent浏览器信息+Referer来源+...-->
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,;q=0.8
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate
Referer: http://localhost/login.html<!--告诉服务器请求的来源-->
Connection: keep-alive
Upgrade-Insecure-Requests: 1	<!--2.请求头-->
<!--3.请求空行：分割请求头和请求体-->
username=zhangsan	<!--4.请求体(正文)：封装POST请求消息的请求参数的-->
```

> 常见的请求头：
>
> 1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息。服务器端可以获取该信息，针对不同浏览器设置参数，解决浏览器的兼容性问题。
> 2. Referer：http://localhost/login.html：告诉服务器当前请求的来源。作用：防盗链，统计工作。

### 8. Request对象

```
request对象用来获取请求消息，response对象用来设置响应消息，request和response对象都是由服务器创建的。
```

> **request对象继承体系结构：**
>
> ​			    	    ServletRequest 接口
> ​		  				           |	继承
> ​			     HttpServletRequest 接口
> ​			    			         |	实现
> org.apache.catalina.connector.RequestFacade 类(tomcat)
> 在用户发出请求的时候 会自动的创建RequestFacade对象

#### 获取请求消息数据的方法

```java
//获取请求方式 
String method = request.getMethod();	// GET
//获取虚拟目录 
String contextPath = request.getContextPath();	// day03
//获取Servlet路径 
String servletPath = request.getServletPath();	// /Demo01Servlet
//获取get方式请求参数 
String queryString = request.getQueryString();	// username=zhangsan
//获取请求URI、URL
String requestURI = request.getRequestURI();	// /day03/Demo01Servlet
StringBuffer requestURL = request.getRequestURL();
//http://localhost:8080/day03/Demo01Servlet
//获取协议及版本 
String protocol = request.getProtocol();	// HTTP/1.1
//获取客户机的IP地址 
String remoteAddr = request.getRemoteAddr();	// 0:0:0:0:0:0:0:1	
```

> - URL：统一资源定位符：http://localhost/day14/demo1	（中华人民共和国）
> 	 URI：统一资源标识符：/day14/demo1		（共和国）

#### 获取请求头数据的方法

```java
String getHeader(String name):通过请求头的名称获取请求头的值
Enumeration<String> getHeaderNames():获取所有的请求头名称，封装为键值对
    //使用示范：
    Enumeration<String> headerNames = request.getHeaderNames();
        while (headerNames.hasMoreElements()) {
            String name = headerNames.nextElement();
            String value = request.getHeader(name);
            System.out.println(name + "------" + value);}
    /*输出结果：
    host------localhost:8080
    connection------keep-alive
    cache-control------max-age=0
    upgrade-insecure-requests------1
    user-agent------Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML,     like Gecko) Chrome/74.0.3729.108 Safari/537.36
    accept-----text/html,application/xhtml+xml,application/xml;
    accept-encoding------gzip, deflate, br
    accept-language------zh-CN,zh;q=0.9
    cookie------_xsrf=2|50c9000a|7b65bf12b3842e1198f0522667c61f08|1554439214; */
```

#### 获取请求体数据的方法

```java
//请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数
//步骤：1. 获取流对象
	BufferedReader getReader()：获取字符输入流，只能操作字符数据
	ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据
	//2. 再从流对象中拿数据
```

#### 获取请求参数通用方式

```java
1. String getParameter(String name):根据参数名称获取参数值 
2. String[] getParameterValues(String name):根据参数名称获取参数值的数组  
3. Enumeration<String> getParameterNames():获取所有请求的参数名称
4. Map<String,String[]> getParameterMap():获取所有参数的map集合
```

> 中文乱码问题：post方式会乱码，我们在获取前端传递的参数之前，都进行设置编码
>
> `request.setCharacterEncoding("utf-8");`

#### 请求转发的方法

```java
request.getRequestDispatcher("String path").forward(request,response);
```

> 1. 浏览器地址栏路径不发生变化
> 2. 只能转发到当前服务器内部资源中
> 3. 转发是一次请求，多个资源用的是同一个请求

#### 共享数据的方法

```java
1. void setAttribute(String name,Object obj):存储数据
2. Object getAttitude(String name):通过键获取值
3. void removeAttribute(String name):通过键移除键值对
```

> - 域对象：一个有作用范围的对象，可以在范围内共享数据
> - request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据

### 9. BeanUtils工具类

```
用于封装标准JavaBean的工具类，按照属性进行映射。
属性：setter和getter方法截取后的产物例，如：getUsername() --> Username--> username
```

> 方法：
>
> 1. setProperty()
> 2. getProperty()
> 3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中

### 10. 响应消息数据格式

```html
HTTP/1.1 200 OK  	<!--1.响应行：协议/版本+响应状态码+状态码描述-->
Content-Type: text/html;charset=UTF-8<!--2.响应头：协议/版本+响应状态码+状态码描述-->
Content-Length: 101
Date: Wed, 06 Jun 2018 07:08:42 GMT
	<!--3.响应空行-->
<html>			<!--4.响应体:传输的数据-->
	<head>
		<title>$Title$</title>
	</head>
	<body>
		hello , response
	</body>
</html>			<!--4.响应体:传输的数据-->
```

> - 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态，状态码都是3位数字。
>   - 1xx：服务器接收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码
>   - 2xx：成功。代表：200
>   - 3xx：重定向。代表：302(重定向)，304(访问缓存)
>   - 4xx：客户端错误。代表：404(请求路径没有对应的资源)，405：(请求方式没有对应的doXxx方法)
>   - 5xx：服务器端错误。代表：500(服务器内部出现异常，写的代码有bug)
> - 常见的响应头：
>   - Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式
>   - Content-disposition：服务器告诉客户端以什么格式打开响应体数据
>     - in-line：默认值，在当前页面内打开
>     - attachment；filename=xxx：以附件形式打开响应体：文件下载

### 11. Response对象

```
request对象和response对象由tomcat创建，每次请求相互独立
```

> **Response方法**：
>
> - 设置状态码：`setStatus(int sc) `
> - 设置响应头：`setHeader(String name, String value) `
> - 设置响应体：
> - 字符输出流：`PrintWriter getWriter()`
> - 字节输出流：`ServletOutputStream getOutputStream()`
> - 设置输出流的编码：`response.setContentType("text/html;charset=utf-8");`
>
> 	etContentType方法同时起到两个作用：1. 设置该流的默认编码	2. 告诉浏览器响应体使用的编码

### 12. 重定向

```java
重定向：资源跳转的方式
//基本的重定向方法：1. 设置状态码为302；2.设置响应头location
response.setStatus(302);
response.setHeader("location","/responseDemo2");
//简化的重定向方法：
response.sendRedirect("/responseDemo2");
```

> **转发(forward)和重定向(redirect)的特点：** 
>
> - 转发的特点：
>   1. 转发地址栏路径不变
>   2. 转发只能访问当前服务器下的资源
>   3. 转发是一次请求，可以使用request对象来共享数据
>   4. 跳转路径**不需要加虚拟目录**
> - 重定向的特点
>   1. 重定向地址栏路径变化
>   2. 重定向可以访问其他站点(服务器)的资源
>   3. 重定向是两次独立的请求，不能使用request对象来共享数据
>   4. 跳转路径**需要加虚拟目录**

### 13. ServletContext对象

```
代表整个web应用，可以和程序的容器(服务器)来通信
```

> **ServletContext方法**：
>
> - 获取ServletContext：
>   1. 通过request对象获取：`equest.getServletContext();`
>   2. 通过HttpServlet获取：`this.getServletContext();`
> - 获取MIME类型：
>   1. MIME类型:在互联网通信过程中定义的一种文件数据类型（大类型/小类型：image/jpeg）
>   2. `String getMimeType(String file)  `
> - 域对象：共享数据（对象范围：所有用户所有请求的数据）
>   1. `setAttribute(String name,Object value)`
>   2. `getAttribute(String name)`
>   3. `removeAttribute(String name)`
>
> （由于ServletContext域对象范围太大，一般不用）
>
> - 获取文件的真实(**服务器**)路径：`String getRealPath(String path)`
>   1. 获取web目录下资源：`getRealPath("/a.txt");`
>   2. 获取WEB-INF目录下资源：`getRealPath("/WEB-INF/a.txt");`
>   3. 获取src目录下资源：`getRealPath("/WEB-INF/classes/a.txt");`

### 14. 案例：文件下载

```java
	//获取请求参数中的文件名称，找到该文件的真实路径，关联给字节输入流
	String filename = request.getParameter("filename");	
    ServletContext servletContext = this.getServletContext();
    String realPath = servletContext.getRealPath("/img/" + filename);
    FileInputStream fis = new FileInputStream(realPath);	
	
	//设置response响应头的"content-type"参数为图片的Mime格式
    String mimeType = servletContext.getMimeType(filename);	
    response.setHeader("content-type", mimeType);

	//通过工具将filename改造成对应浏览器能够解读的格式
    String userAgent = request.getHeader("user-agent");	
    filename = DownLoadUtils.getFileName(userAgent, filename);
	//设置response响应头的"content-disposition"参数为附件形式
    response.setHeader("content-disposition","attachment;filename=" + filename);

    //将输入流的数据写出到输出流中
    ServletOutputStream sos = response.getOutputStream();
    byte[] buff = new byte[1024 * 8];
    int len = 0;
    while ((len = fis.read(buff)) != -1) {
        sos.write(buff, 0, len);
    }
    fis.close();
```



### 15.cookie&Session

```
1. 会话技术
	1. Cookie
	2. Session
2. JSP：入门学习
```



#### 会话技术

```
1. 会话：一次会话中包含多次请求和响应。
	* 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止
2. 功能：在一次会话的范围内的多次请求间，共享数据
3. 方式：
	1. 客户端会话技术：Cookie
	2. 服务器端会话技术：Session
```

#### Cookie：

```
1. 概念：客户端会话技术，将数据保存到客户端

2. 快速入门：
	* 使用步骤：
		1. 创建Cookie对象，绑定数据
			* new Cookie(String name, String value) 
		2. 发送Cookie对象
			* response.addCookie(Cookie cookie) 
		3. 获取Cookie，拿到数据
			* Cookie[]  request.getCookies()  
```

```
3. 实现原理
	* 基于响应头set-cookie和请求头cookie实现

4. cookie的细节
	1. 一次可不可以发送多个cookie?
		* 可以
		* 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。
	2. cookie在浏览器中保存多长时间？
		1. 默认情况下，当浏览器关闭后，Cookie数据被销毁
		2. 持久化存储：
			* setMaxAge(int seconds)
				1. 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效
				2. 负数：默认值
				3. 零：删除cookie信息
	3. cookie能不能存中文？
		* 在tomcat 8 之前 cookie中不能直接存储中文数据。
			* 需要将中文数据转码---一般采用URL编码(%E3)
		* 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析
	4. cookie共享问题？
		1. 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？
			* 默认情况下cookie不能共享

			* setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录
				* 如果要共享，则可以将path设置为"/"
```

​			
	2. 不同的tomcat服务器间cookie共享问题？
	* setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享
	* setDomain(".baidu.com"),那么tieba.baidu.com和news.baidu.com中cookie可以共享

```
5. Cookie的特点和作用
	1. cookie存储数据在客户端浏览器
	2. 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个)

	* 作用：
		1. cookie一般用于存出少量的不太敏感的数据
		2. 在不登录的情况下，完成服务器对客户端的身份识别

6. 案例：记住上一次访问时间
	1. 需求：
		1. 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。
		2. 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串

	2. 分析：
		1. 可以采用Cookie来完成
		2. 在服务器中的Servlet判断是否有一个名为lastTime的cookie
			1. 有：不是第一次访问
				1. 响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20
				2. 写回Cookie：lastTime=2018年6月10日11:50:01
			2. 没有：是第一次访问
				1. 响应数据：您好，欢迎您首次访问
				2. 写回Cookie：lastTime=2018年6月10日11:50:01

	3. 代码实现：
		package cn.itcast.cookie;

		import javax.servlet.ServletException;
		import javax.servlet.annotation.WebServlet;
		import javax.servlet.http.Cookie;
		import javax.servlet.http.HttpServlet;
		import javax.servlet.http.HttpServletRequest;
		import javax.servlet.http.HttpServletResponse;
		import java.io.IOException;
		import java.net.URLDecoder;
		import java.net.URLEncoder;
		import java.text.SimpleDateFormat;
		import java.util.Date;
```

```
	@WebServlet("/cookieTest")
	public class CookieTest extends HttpServlet {
	    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	        //设置响应的消息体的数据格式以及编码
	        response.setContentType("text/html;charset=utf-8");
	
	        //1.获取所有Cookie
	        Cookie[] cookies = request.getCookies();
	        boolean flag = false;//没有cookie为lastTime
	        //2.遍历cookie数组
	        if(cookies != null && cookies.length > 0){
	            for (Cookie cookie : cookies) {
	                //3.获取cookie的名称
	                String name = cookie.getName();
	                //4.判断名称是否是：lastTime
	                if("lastTime".equals(name)){
	                    //有该Cookie，不是第一次访问
	
	                    flag = true;//有lastTime的cookie
	
	                    //设置Cookie的value
	                    //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie
	                    Date date  = new Date();
	                    SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
	                    String str_date = sdf.format(date);
	                    System.out.println("编码前："+str_date);
	                    //URL编码
	                    str_date = URLEncoder.encode(str_date,"utf-8");
	                    System.out.println("编码后："+str_date);
	                    cookie.setValue(str_date);
	                    //设置cookie的存活时间
	                    cookie.setMaxAge(60 * 60 * 24 * 30);//一个月
	                    response.addCookie(cookie);
```

​		
		                    //响应数据
		                    //获取Cookie的value，时间
		                    String value = cookie.getValue();
		                    System.out.println("解码前："+value);
		                    //URL解码：
		                    value = URLDecoder.decode(value,"utf-8");
		                    System.out.println("解码后："+value);
		                    response.getWriter().write("<h1>欢迎回来，您上次访问时间为:"+value+"</h1>");
		

```
	                    break;
	
	                }
	            }
	        }
```

​		
		        if(cookies == null || cookies.length == 0 || flag == false){
		            //没有，第一次访问
		

```
	            //设置Cookie的value
	            //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie
	            Date date  = new Date();
	            SimpleDateFormat sdf = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss");
	            String str_date = sdf.format(date);
	            System.out.println("编码前："+str_date);
	            //URL编码
	            str_date = URLEncoder.encode(str_date,"utf-8");
	            System.out.println("编码后："+str_date);
	
	            Cookie cookie = new Cookie("lastTime",str_date);
	            //设置cookie的存活时间
	            cookie.setMaxAge(60 * 60 * 24 * 30);//一个月
	            response.addCookie(cookie);
	
	            response.getWriter().write("<h1>您好，欢迎您首次访问</h1>");
	        }
```

​		
		    }
		

```
	    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	        this.doPost(request, response);
	    }
	}
```

#### JSP：入门学习

```
1. 概念：
	* Java Server Pages： java服务器端页面
		* 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码
		* 用于简化书写！！！
```

```
2. 原理
	* JSP本质上就是一个Servlet

3. JSP的脚本：JSP定义Java代码的方式
	1. <%  代码 %>：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。
	2. <%! 代码 %>：定义的java代码，在jsp转换后的java类的成员位置。
	3. <%= 代码 %>：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。
```

```
4. JSP的内置对象：
	* 在jsp页面中不需要获取和创建，可以直接使用的对象
	* jsp一共有9个内置对象。
	* 今天学习3个：
		* request
		* response
		* out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似
			* response.getWriter()和out.write()的区别：
				* 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。
				* response.getWriter()数据输出永远在out.write()之前
			
5. 案例:改造Cookie案例
```



#### Session：主菜

```
request session servletcontext三个都是域对象
```

​	

```
1. 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession
2. 快速入门：
	1. 获取HttpSession对象：
		HttpSession session = request.getSession();
	2. 使用HttpSession对象：
		Object getAttribute(String name)  
		void setAttribute(String name, Object value)
		void removeAttribute(String name)  

3. 原理
	* Session的实现是依赖于Cookie的。
```

​	
	4. 细节：
		1. 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？
			* 默认情况下。不是。
			* 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。
				 Cookie c = new Cookie("JSESSIONID",session.getId());
		         c.setMaxAge(60*60);
		         response.addCookie(c);
	

```
	2. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？
		* 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作
			* session的钝化：
				* 在服务器正常关闭之前，将session对象系列化到硬盘上
			* session的活化：
				* 在服务器启动后，将session文件转化为内存中的session对象即可。
			
	3. session什么时候被销毁？
		1. 服务器关闭
		2. session对象调用invalidate() 。
		3. session默认失效时间 30分钟
			选择性配置修改	
			<session-config>
		        <session-timeout>30</session-timeout>
		    </session-config>

 5. session的特点
	 1. session用于存储一次会话的多次请求的数据，存在服务器端
	 2. session可以存储任意类型，任意大小的数据

	* session与Cookie的区别：
		1. session存储数据在服务器端，Cookie在客户端
		2. session没有数据大小限制，Cookie有
		3. session数据安全，Cookie相对于不安全
```

#### 案例：验证码

```
1. 案例需求：
	1. 访问带有验证码的登录页面login.jsp
	2. 用户输入用户名，密码以及验证码。
		* 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误
		* 如果验证码输入有误，跳转登录页面，提示：验证码错误
		* 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您
```

```
2. 分析：
```

​



### 16.EL&JSTL

```
1. JSP:
	1. 指令
	2. 注释
	3. 内置对象

2. MVC开发模式
3. EL表达式
4. JSTL标签
5. 三层架构
```



#### JSP:

```
1. 指令
	* 作用：用于配置JSP页面，导入资源文件
	* 格式：
		<%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %>
	* 分类：
		1. page		： 配置JSP页面的
			* contentType：等同于response.setContentType()
				1. 设置响应体的mime类型以及字符集
				2. 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集）
			* import：导包
			* errorPage：当前页面发生异常后，会自动跳转到指定的错误页面
			* isErrorPage：标识当前也是是否是错误页面。
				* true：是，可以使用内置对象exception
				* false：否。默认值。不可以使用内置对象exception
```

```
		2. include	： 页面包含的。导入页面的资源文件
			* <%@include file="top.jsp"%>
		3. taglib	： 导入资源
			* <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
				* prefix：前缀，自定义的
2. 注释:
	1. html注释：
		<!-- -->:只能注释html代码片段
	2. jsp注释：推荐使用
		<%-- --%>：可以注释所有
```

```
3. 内置对象
	* 在jsp页面中不需要创建，直接使用的对象
	* 一共有9个：
			变量名					真实类型						作用
		* pageContext				PageContext					当前页面共享数据，还可以获取其他八个内置对象
		* request					HttpServletRequest			一次请求访问的多个资源(转发)
		* session					HttpSession					一次会话的多个请求间
		* application				ServletContext				所有用户间共享数据
		* response					HttpServletResponse			响应对象
		* page						Object						当前页面(Servlet)的对象  this
		* out						JspWriter					输出对象，数据输出到页面上
		* config					ServletConfig				Servlet的配置对象
		* exception					Throwable					异常对象
```

​	

#### MVC：开发模式

```
1. jsp演变历史
	1. 早期只有servlet，只能使用response输出标签数据，非常麻烦
	2. 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作
	3. 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性

2. MVC：
	1. M：Model，模型。JavaBean
		* 完成具体的业务操作，如：查询数据库，封装对象
	2. V：View，视图。JSP
		* 展示数据
	3. C：Controller，控制器。Servlet
		* 获取用户的输入
		* 调用模型
		* 将数据交给视图进行展示
```

```
	* 优缺点：
		1. 优点：
			1. 耦合性低，方便维护，可以利于分工协作
			2. 重用性高

		2. 缺点：
			1. 使得项目架构变得复杂，对开发人员要求高
```





#### EL表达式

```
1. 概念：Expression Language 表达式语言
2. 作用：替换和简化jsp页面中java代码的编写
3. 语法：${表达式}
4. 注意：
	* jsp默认支持el表达式的。如果要忽略el表达式
		1. 设置jsp中page指令中：isELIgnored="true" 忽略当前jsp页面中所有的el表达式
		2. \${表达式} ：忽略当前这个el表达式
```

```
5. 使用：
	1. 运算：
		* 运算符：
			1. 算数运算符： + - * /(div) %(mod)
			2. 比较运算符： > < >= <= == !=
			3. 逻辑运算符： &&(and) ||(or) !(not)
			4. 空运算符： empty
				* 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0
				* ${empty list}:判断字符串、集合、数组对象是否为null或者长度为0
				* ${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度>0
	2. 获取值
		1. el表达式只能从域对象中获取值
		2. 语法：
			1. ${域名称.键名}：从指定域中获取指定键的值
				* 域名称：
					1. pageScope		--> pageContext
					2. requestScope 	--> request
					3. sessionScope 	--> session
					4. applicationScope --> application（ServletContext）
				* 举例：在request域中存储了name=张三
				* 获取：${requestScope.name}

			2. ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。
```

​				
​				

```
			3. 获取对象、List集合、Map集合的值
				1. 对象：${域名称.键名.属性名}
					* 本质上会去调用对象的getter方法

				2. List集合：${域名称.键名[索引]}

				3. Map集合：
					* ${域名称.键名.key名称}
					* ${域名称.键名["key名称"]}
```

```
	3. 隐式对象：
		* el表达式中有11个隐式对象
		* pageContext：
			* 获取jsp其他八个内置对象
				* ${pageContext.request.contextPath}：动态获取虚拟目录
```

​	

#### JSTL

```
1. 概念：JavaServer Pages Tag Library  JSP标准标签库
	* 是由Apache组织提供的开源的免费的jsp标签		<标签>

2. 作用：用于简化和替换jsp页面上的java代码		

3. 使用步骤：
	1. 导入jstl相关jar包
	2. 引入标签库：taglib指令：  <%@ taglib %>
	3. 使用标签

4. 常用的JSTL标签
	1. if:相当于java代码的if语句
		1. 属性：
            * test 必须属性，接受boolean表达式
                * 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容
                * 一般情况下，test属性值会结合el表达式一起使用
   		 2. 注意：
       		 * c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签
	2. choose:相当于java代码的switch语句
		1. 使用choose标签声明         			相当于switch声明
        2. 使用when标签做判断         			相当于case
        3. 使用otherwise标签做其他情况的声明    	相当于default

	3. foreach:相当于java代码的for语句

5. 练习：
	* 需求：在request域中有一个存有User对象的List集合。需要使用jstl+el将list集合数据展示到jsp页面的表格table中
```





#### 三层架构：软件设计架构

```
1. 界面层(表示层)：用户看的得界面。用户可以通过界面上的组件和服务器进行交互
2. 业务逻辑层：处理业务逻辑的。
3. 数据访问层：操作数据存储文件。
```







#### 案例：用户信息列表展示

```
1. 需求：用户信息的增删改查操作
2. 设计：
	1. 技术选型：Servlet+JSP+MySQL+JDBCTempleat+Duird+BeanUtilS+tomcat
	2. 数据库设计：
		create database day17; -- 创建数据库
		use day17; 			   -- 使用数据库
		create table user(   -- 创建表
			id int primary key auto_increment,
			name varchar(20) not null,
			gender varchar(5),
			age int,
			address varchar(32),
			qq	varchar(20),
			email varchar(50)
		);

3. 开发：
	1. 环境搭建
		1. 创建数据库环境
		2. 创建项目，导入需要的jar包

	2. 编码
```

```
4. 测试
5. 部署运维
```







### 17.Filter&Listener

```
1. Filter：过滤器
2. Listener：监听器
```



#### Filter：过滤器

```
1. 概念：
	* 生活中的过滤器：净水器,空气净化器，土匪、
	* web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。
	* 过滤器的作用：
		* 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤...

2. 快速入门：
	1. 步骤：
		1. 定义一个类，实现接口Filter
		2. 复写方法
		3. 配置拦截路径
			1. web.xml
			2. 注解
	2. 代码：
		@WebFilter("/*")//访问所有资源之前，都会执行该过滤器
		public class FilterDemo1 implements Filter {
		    @Override
		    public void init(FilterConfig filterConfig) throws ServletException {
		
		    }
		
		    @Override
		    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
		        System.out.println("filterDemo1被执行了....");
```

​			

```
		        //放行
		        filterChain.doFilter(servletRequest,servletResponse);
		
		    }
		
		    @Override
		    public void destroy() {
		
		    }
		}
```

```
3. 过滤器细节：
	1. web.xml配置	
		<filter>
	        <filter-name>demo1</filter-name>
	        <filter-class>cn.itcast.web.filter.FilterDemo1</filter-class>
	    </filter>
	    <filter-mapping>
	        <filter-name>demo1</filter-name>
			<!-- 拦截路径 -->
	        <url-pattern>/*</url-pattern>
	    </filter-mapping>
	2. 过滤器执行流程
		1. 执行过滤器
		2. 执行放行后的资源
		3. 回来执行过滤器放行代码下边的代码
	3. 过滤器生命周期方法
		1. init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源
		2. doFilter:每一次请求被拦截资源时，会执行。执行多次
		3. destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源
	4. 过滤器配置详解
		* 拦截路径配置：
			1. 具体资源路径： /index.jsp   只有访问index.jsp资源时，过滤器才会被执行
			2. 拦截目录： /user/*	访问/user下的所有资源时，过滤器都会被执行
			3. 后缀名拦截： *.jsp		访问所有后缀名为jsp资源时，过滤器都会被执行
			4. 拦截所有资源：/*		访问所有资源时，过滤器都会被执行
		* 拦截方式配置：资源被访问的方式
			* 注解配置：
				* 设置dispatcherTypes属性
					1. REQUEST：默认值。浏览器直接请求资源
					2. FORWARD：转发访问资源
					3. INCLUDE：包含访问资源
					4. ERROR：错误跳转资源
					5. ASYNC：异步访问资源
			* web.xml配置
				* 设置<dispatcher></dispatcher>标签即可
			
	5. 过滤器链(配置多个过滤器)
		* 执行顺序：如果有两个过滤器：过滤器1和过滤器2
			1. 过滤器1
			2. 过滤器2
			3. 资源执行
			4. 过滤器2
			5. 过滤器1 

		* 过滤器先后顺序问题：
			1. 注解配置：按照类名的字符串比较规则比较，值小的先执行
				* 如： AFilter 和 BFilter，AFilter就先执行了。
			2. web.xml配置： <filter-mapping>谁定义在上边，谁先执行
4. 案例：
	1. 案例1_登录验证
		* 需求：
			1. 访问day17_case案例的资源。验证其是否登录
			2. 如果登录了，则直接放行。
			3. 如果没有登录，则跳转到登录页面，提示"您尚未登录，请先登录"。
```

​	

```
	2. 案例2_敏感词汇过滤
		* 需求：
			1. 对day17_case案例录入的数据进行敏感词汇过滤
			2. 敏感词汇参考《敏感词汇.txt》
			3. 如果是敏感词汇，替换为 *** 

		* 分析：
			1. 对request对象进行增强。增强获取参数相关方法
			2. 放行。传递代理对象
```

```
		* 增强对象的功能：
			* 设计模式：一些通用的解决固定问题的方式
			1. 装饰模式
			2. 代理模式
				* 概念：
					1. 真实对象：被代理的对象
					2. 代理对象：
					3. 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的
			 	* 实现方式：
				 	1. 静态代理：有一个类文件描述代理模式
				 	2. 动态代理：在内存中形成代理类
						* 实现步骤：
							1. 代理对象和真实对象实现相同的接口
							2. 代理对象 = Proxy.newProxyInstance();
							3. 使用代理对象调用方法。
							4. 增强方法

						* 增强方式：
							1. 增强参数列表
							2. 增强返回值类型
							3. 增强方法体执行逻辑	
```

#### Listener：监听器

```
* 概念：web的三大组件之一。
	* 事件监听机制
		* 事件	：一件事情
		* 事件源 ：事件发生的地方
		* 监听器 ：一个对象
		* 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码
```

```xml
* ServletContextListener:监听ServletContext对象的创建和销毁
	* 方法：
		* void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法
		* void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法
	* 步骤：
		1. 定义一个类，实现ServletContextListener接口
		2. 复写方法
		3. 配置
			1. web.xml
<listener>
 <listener-class>cn.itcast.web.listener.ContextLoaderListener</listener-class>
 </listener>
```

   						

```
				* 指定初始化参数<context-param>
			2. 注解：
				* @WebListener
```





### 18.JQuery 基础：

```
1. 概念： 一个JavaScript框架。简化JS开发
	* jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨	是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。
	* JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已
2. 快速入门
	1. 步骤：
		1. 下载JQuery
			* 目前jQuery有三个大版本：
				1.x：兼容ie678,使用最为广泛的，官方只做BUG维护，
					 功能不再新增。因此一般项目来说，使用1.x版本就可以了，
					 最终版本：1.12.4 (2016年5月20日)
				2.x：不兼容ie678，很少有人使用，官方只做BUG维护，
					 功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，
					 最终版本：2.2.4 (2016年5月20日)
				3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求，
					 一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。
					 目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日）
			* jquery-xxx.js 与 jquery-xxx.min.js区别：
				1. jquery-xxx.js：开发版本。给程序员看的，有良好的缩进和注释。体积大一些
				2. jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快

		2. 导入JQuery的js文件：导入min.js文件
		3. 使用
			var div1 = $("#div1");
				alert(div1.html());
```

   			

```
3. JQuery对象和JS对象区别与转换
	1. JQuery对象在操作时，更加方便。
    2. JQuery对象和js对象方法不通用的.
    3. 两者相互转换
        * jq -- > js : jq对象[索引] 或者 jq对象.get(索引)
        * js -- > jq : $(js对象)
```

```
4. 选择器：筛选具有相似特征的元素(标签)

	1. 基本操作学习：
		1. 事件绑定
			//1.获取b1按钮
            $("#b1").click(function(){
                alert("abc");
            });
		2. 入口函数
			 $(function () {
	           
   			 });
			 window.onload  和 $(function) 区别
                 * window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉
                 * $(function)可以定义多次的。
		3. 样式控制：css方法
			 // $("#div1").css("background-color","red");
      		$("#div1").css("backgroundColor","pink");
```

```
	2. 分类
		1. 基本选择器
			1. 标签选择器（元素选择器）
				* 语法： $("html标签名") 获得所有匹配标签名称的元素
			2. id选择器 
				* 语法： $("#id的属性值") 获得与指定id属性值匹配的元素
			3. 类选择器
				* 语法： $(".class的属性值") 获得与指定的class属性值匹配的元素
			4. 并集选择器：
				* 语法： $("选择器1,选择器2....") 获取多个选择器选中的所有元素
		2. 层级选择器
			1. 后代选择器
				* 语法： $("A B ") 选择A元素内部的所有B元素		
			2. 子选择器
				* 语法： $("A > B") 选择A元素内部的所有B子元素
		3. 属性选择器
			1. 属性名称选择器 
				* 语法： $("A[属性名]") 包含指定属性的选择器
			2. 属性选择器
				* 语法： $("A[属性名='值']") 包含指定属性等于指定值的选择器
			3. 复合属性选择器
				* 语法： $("A[属性名='值'][]...") 包含多个属性条件的选择器
		4. 过滤选择器
			1. 首元素选择器 
				* 语法： :first 获得选择的元素中的第一个元素
			2. 尾元素选择器 
				* 语法： :last 获得选择的元素中的最后一个元素
			3. 非元素选择器
				* 语法： :not(selector) 不包括指定内容的元素
			4. 偶数选择器
				* 语法： :even 偶数，从 0 开始计数
			5. 奇数选择器
				* 语法： :odd 奇数，从 0 开始计数
			6. 等于索引选择器
				* 语法： :eq(index) 指定索引元素
			7. 大于索引选择器 
				* 语法： :gt(index) 大于指定索引元素
			8. 小于索引选择器 
				* 语法： :lt(index) 小于指定索引元素
			9. 标题选择器
				* 语法： :header 获得标题（h1~h6）元素，固定写法
		5. 表单过滤选择器
			1. 可用元素选择器 
				* 语法： :enabled 获得可用元素
			2. 不可用元素选择器 
				* 语法： :disabled 获得不可用元素
			3. 选中选择器 
				* 语法： :checked 获得单选/复选框选中的元素
			4. 选中选择器 
				* 语法： :selected 获得下拉框选中的元素

5. DOM操作
	1. 内容操作
		1. html(): 获取/设置元素的标签体内容   <a><font>内容</font></a>  --> <font>内容</font>
		2. text(): 获取/设置元素的标签体纯文本内容   <a><font>内容</font></a> --> 内容
		3. val()： 获取/设置元素的value属性值
	2. 属性操作
		1. 通用属性操作
			1. attr(): 获取/设置元素的属性
			2. removeAttr():删除属性
			3. prop():获取/设置元素的属性
			4. removeProp():删除属性

			* attr和prop区别？
				1. 如果操作的是元素的固有属性，则建议使用prop
				2. 如果操作的是元素自定义的属性，则建议使用attr
		2. 对class属性操作
			1. addClass():添加class属性值
			2. removeClass():删除class属性值
			3. toggleClass():切换class属性
				* toggleClass("one"): 
					* 判断如果元素对象上存在class="one"，则将属性值one删除掉。  如果元素对象上不存在class="one"，则添加
			4. css():
	3. CRUD操作:
		1. append():父元素将子元素追加到末尾
			* 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾
		2. prepend():父元素将子元素追加到开头
			* 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头
		3. appendTo():
			* 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾
		4. prependTo()：
			* 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头
```

```
		5. after():添加元素到元素后边
			* 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系
		6. before():添加元素到元素前边
			* 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系
		7. insertAfter()
			* 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系
		8. insertBefore()
			* 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系

		9. remove():移除元素
			* 对象.remove():将对象删除掉
		10. empty():清空元素的所有后代元素。
			* 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点
```

```
6. 案例
```



​			

### 19.JQuery 高级

```
1. 动画
	1. 三种方式显示和隐藏元素
		1. 默认显示和隐藏方式
			1. show([speed,[easing],[fn]])
				1. 参数：
					1. speed：动画的速度。三个预定义的值("slow","normal", "fast")或表示动画时长的毫秒数值(如：1000)
					2. easing：用来指定切换效果，默认是"swing"，可用参数"linear"
						* swing：动画执行时效果是 先慢，中间快，最后又慢
						* linear：动画执行时速度是匀速的
					3. fn：在动画完成时执行的函数，每个元素执行一次。

			2. hide([speed,[easing],[fn]])
			3. toggle([speed],[easing],[fn])
		
		2. 滑动显示和隐藏方式
			1. slideDown([speed],[easing],[fn])
			2. slideUp([speed,[easing],[fn]])
			3. slideToggle([speed],[easing],[fn])

		3. 淡入淡出显示和隐藏方式
			1. fadeIn([speed],[easing],[fn])
			2. fadeOut([speed],[easing],[fn])
			3. fadeToggle([speed,[easing],[fn]])

2. 遍历
	1. js的遍历方式
		* for(初始化值;循环结束条件;步长)
	2. jq的遍历方式
		1. jq对象.each(callback)
			1. 语法：
				jquery对象.each(function(index,element){});
					* index:就是元素在集合中的索引
					* element：就是集合中的每一个元素对象

					* this：集合中的每一个元素对象
			2. 回调函数返回值：
				* true:如果当前function返回为false，则结束循环(break)。
				* false:如果当前function返回为true，则结束本次循环，继续下次循环(continue)
		2. $.each(object, [callback])
		3. for..of: jquery 3.0 版本之后提供的方式
			for(元素对象 of 容器对象)
	
3. 事件绑定
	1. jquery标准的绑定方式
		* jq对象.事件方法(回调函数)；
		* 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。
			* 表单对象.submit();//让表单提交
	2. on绑定事件/off解除绑定
		* jq对象.on("事件名称",回调函数)
		* jq对象.off("事件名称")
			* 如果off方法不传递任何参数，则将组件上的所有事件全部解绑
	3. 事件切换：toggle
		* jq对象.toggle(fn1,fn2...)
			* 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2.....
			
		* 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。
			 <script src="../js/jquery-migrate-1.0.0.js" type="text/javascript" charset="utf-8"></script>

4. 案例
	1. 广告显示和隐藏
		<!DOCTYPE html>
		<html>
		<head>
		    <meta charset="UTF-8">
		    <title>广告的自动显示与隐藏</title>
		    <style>
		        #content{width:100%;height:500px;background:#999}
		    </style>
		
		    <!--引入jquery-->
		    <script type="text/javascript" src="../js/jquery-3.3.1.min.js"></script>
		    <script>
		        /*
		            需求：
		                1. 当页面加载完，3秒后。自动显示广告
		                2. 广告显示5秒后，自动消失。
		
		            分析：
		                1. 使用定时器来完成。setTimeout (执行一次定时器)
		                2. 分析发现JQuery的显示和隐藏动画效果其实就是控制display
		                3. 使用  show/hide方法来完成广告的显示
		         */
		
		        //入口函数，在页面加载完成之后，定义定时器，调用这两个方法
		        $(function () {
		           //定义定时器，调用adShow方法 3秒后执行一次
		           setTimeout(adShow,3000);
		           //定义定时器，调用adHide方法，8秒后执行一次
		            setTimeout(adHide,8000);
		        });
		        //显示广告
		        function adShow() {
		            //获取广告div，调用显示方法
		            $("#ad").show("slow");
		        }
		        //隐藏广告
		        function adHide() {
		            //获取广告div，调用隐藏方法
		            $("#ad").hide("slow");
		        }
```

​			
			    </script>
			</head>
			<body>
			<!-- 整体的DIV -->
			<div>
			    <!-- 广告DIV -->
			    <div id="ad" style="display: none;">
			        <img style="width:100%" src="D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/day21/img/adv.jpg" />
			    </div>
			

```
		    <!-- 下方正文部分 -->
		    <div id="content">
		        正文部分
		    </div>
		</div>
		</body>
		</html>
```

```
	2. 抽奖
		<!DOCTYPE html>
		<html>
		<head>
		    <meta charset="UTF-8">
		    <title>jquery案例之抽奖</title>
		    <script type="text/javascript" src="../js/jquery-3.3.1.min.js"></script>
		
		    <script language='javascript' type='text/javascript'>
		
		        /*
		            分析：
		                1. 给开始按钮绑定单击事件
		                    1.1 定义循环定时器
		                    1.2 切换小相框的src属性
		                        * 定义数组，存放图片资源路径
		                        * 生成随机数。数组索引
```

```
		                2. 给结束按钮绑定单击事件
		                    1.1 停止定时器
		                    1.2 给大相框设置src属性
		
		         */
		        var imgs = ["../img/man00.jpg",
		                    "../img/man01.jpg",
		                    "../img/man02.jpg",
		                    "../img/man03.jpg",
		                    "../img/man04.jpg",
		                    "../img/man05.jpg",
		                    "../img/man06.jpg",
		                    ];
		        var startId;//开始定时器的id
		        var index;//随机角标
		        $(function () {
		            //处理按钮是否可以使用的效果
		            $("#startID").prop("disabled",false);
		            $("#stopID").prop("disabled",true);
```

```
		           //1. 给开始按钮绑定单击事件
		            $("#startID").click(function () {
		                // 1.1 定义循环定时器 20毫秒执行一次
		                startId = setInterval(function () {
		                    //处理按钮是否可以使用的效果
		                    $("#startID").prop("disabled",true);
		                    $("#stopID").prop("disabled",false);
```

```
		                    //1.2生成随机角标 0-6
		                    index = Math.floor(Math.random() * 7);//0.000--0.999 --> * 7 --> 0.0-----6.9999
		                    //1.3设置小相框的src属性
		                    $("#img1ID").prop("src",imgs[index]);
		
		                },20);
		            });
```

```
		            //2. 给结束按钮绑定单击事件
		            $("#stopID").click(function () {
		                //处理按钮是否可以使用的效果
		                $("#startID").prop("disabled",false);
		                $("#stopID").prop("disabled",true);
```

```
		               // 1.1 停止定时器
		                clearInterval(startId);
		               // 1.2 给大相框设置src属性
		                $("#img2ID").prop("src",imgs[index]).hide();
		                //显示1秒之后
		                $("#img2ID").show(1000);
		            });
		        });
```

​			
​			
			    </script>
			

```
		</head>
		<body>
		
		<!-- 小像框 -->
		<div style="border-style:dotted;width:160px;height:100px">
		    <img id="img1ID" src="../img/man00.jpg" style="width:160px;height:100px"/>
		</div>
		
		<!-- 大像框 -->
		<div
		        style="border-style:double;width:800px;height:500px;position:absolute;left:500px;top:10px">
		    <img id="img2ID" src="../img/man00.jpg" width="800px" height="500px"/>
		</div>
		
		<!-- 开始按钮 -->
		<input
		        id="startID"
		        type="button"
		        value="点击开始"
		        style="width:150px;height:150px;font-size:22px">
		
		<!-- 停止按钮 -->
		<input
		        id="stopID"
		        type="button"
		        value="点击停止"
		        style="width:150px;height:150px;font-size:22px">
```

```
		</body>
		</html>

5. 插件：增强JQuery的功能
	1. 实现方式：
		1. $.fn.extend(object) 
			* 增强通过Jquery获取的对象的功能  $("#id")
		2. $.extend(object)
			* 增强JQeury对象自身的功能  $/jQuery
```







### 20.AJAX&JSON

#### AJAX：

```
1. 概念： ASynchronous JavaScript And XML	异步的JavaScript 和 XML
	1. 异步和同步：客户端和服务器端相互通信的基础上
		* 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。
		* 客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。

		Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 [1] 
		通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。
		传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。

		提升用户的体验

2. 实现方式：
	1. 原生的JS实现方式（了解）
				 //1.创建核心对象
	            var xmlhttp;
	            if (window.XMLHttpRequest)
	            {// code for IE7+, Firefox, Chrome, Opera, Safari
	                xmlhttp=new XMLHttpRequest();
	            }
	            else
	            {// code for IE6, IE5
	                xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
	            }
	
	            //2. 建立连接
	            /*
	                参数：
	                    1. 请求方式：GET、POST
	                        * get方式，请求参数在URL后边拼接。send方法为空参
	                        * post方式，请求参数在send方法中定义
	                    2. 请求的URL：
	                    3. 同步或异步请求：true（异步）或 false（同步）
	
	             */
	            xmlhttp.open("GET","ajaxServlet?username=tom",true);
	
	            //3.发送请求
	            xmlhttp.send();
	
	            //4.接受并处理来自服务器的响应结果
	            //获取方式 ：xmlhttp.responseText
	            //什么时候获取？当服务器响应成功后再获取
	
	            //当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。
	            xmlhttp.onreadystatechange=function()
	            {
	                //判断readyState就绪状态是否为4，判断status响应状态码是否为200
	                if (xmlhttp.readyState==4 && xmlhttp.status==200)
	                {
	                   //获取服务器的响应结果
	                    var responseText = xmlhttp.responseText;
	                    alert(responseText);
	                }
	            }
	2. JQeury实现方式
		1. $.ajax()
			* 语法：$.ajax({键值对});
			 //使用$.ajax()发送异步请求
	            $.ajax({
	                url:"ajaxServlet1111" , // 请求路径
	                type:"POST" , //请求方式
	                //data: "username=jack&age=23",//请求参数
	                data:{"username":"jack","age":23},
	                success:function (data) {
	                    alert(data);
	                },//响应成功后的回调函数
	                error:function () {
	                    alert("出错啦...")
	                },//表示如果请求响应出现错误，会执行的回调函数
	
	                dataType:"text"//设置接受到的响应数据的格式
	            });
		2. $.get()：发送get请求
			* 语法：$.get(url, [data], [callback], [type])
				* 参数：
					* url：请求路径
					* data：请求参数
					* callback：回调函数
					* type：响应结果的类型

		3. $.post()：发送post请求
			* 语法：$.post(url, [data], [callback], [type])
				* 参数：
					* url：请求路径
					* data：请求参数
					* callback：回调函数
					* type：响应结果的类型
```



#### JSON：

```
1. 概念： JavaScript Object Notation		JavaScript对象表示法
	Person p = new Person();
	p.setName("张三");
	p.setAge(23);
	p.setGender("男");

	var p = {"name":"张三","age":23,"gender":"男"};

	* json现在多用于存储和交换文本信息的语法
	* 进行数据的传输
	* JSON 比 XML 更小、更快，更易解析。

2. 语法：
	1. 基本规则
		* 数据在名称/值对中：json数据是由键值对构成的
			* 键用引号(单双都行)引起来，也可以不使用引号
			* 值得取值类型：
				1. 数字（整数或浮点数）
				2. 字符串（在双引号中）
				3. 逻辑值（true 或 false）
				4. 数组（在方括号中）	{"persons":[{},{}]}
				5. 对象（在花括号中） {"address":{"province"："陕西"....}}
				6. null
		* 数据由逗号分隔：多个键值对由逗号分隔
		* 花括号保存对象：使用{}定义json 格式
		* 方括号保存数组：[]
	2. 获取数据:
		1. json对象.键名
		2. json对象["键名"]
		3. 数组对象[索引]
		4. 遍历
				 //1.定义基本格式
		        var person = {"name": "张三", age: 23, 'gender': true};
		
		        var ps = [{"name": "张三", "age": 23, "gender": true},
		            {"name": "李四", "age": 24, "gender": true},
		            {"name": "王五", "age": 25, "gender": false}];
```

​			
​			
​			

```
		        //获取person对象中所有的键和值
		        //for in 循环
		       /* for(var key in person){
		            //这样的方式获取不行。因为相当于  person."name"
		            //alert(key + ":" + person.key);
		            alert(key+":"+person[key]);
		        }*/
		
		       //获取ps中的所有值
		        for (var i = 0; i < ps.length; i++) {
		            var p = ps[i];
		            for(var key in p){
		                alert(key+":"+p[key]);
		            }
		        }
```

```
3. JSON数据和Java对象的相互转换

	* JSON解析器：
		* 常见的解析器：Jsonlib，Gson，fastjson，jackson
	
	1. JSON转为Java对象
		1. 导入jackson的相关jar包
		2. 创建Jackson核心对象 ObjectMapper
		3. 调用ObjectMapper的相关方法进行转换
			1. readValue(json字符串数据,Class)
	2. Java对象转换JSON
		1. 使用步骤：
			1. 导入jackson的相关jar包
			2. 创建Jackson核心对象 ObjectMapper
			3. 调用ObjectMapper的相关方法进行转换
				1. 转换方法：
					* writeValue(参数1，obj):
	                    参数1：
	                        File：将obj对象转换为JSON字符串，并保存到指定的文件中
	                        Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中
	                        OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中
	                * writeValueAsString(obj):将对象转为json字符串

				2. 注解：
					1. @JsonIgnore：排除属性。
					2. @JsonFormat：属性值得格式化
						* @JsonFormat(pattern = "yyyy-MM-dd")

				3. 复杂java对象转换
					1. List：数组
					2. Map：对象格式一致
```

#### 案例：

```
* 校验用户名是否存在
	1. 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案：
		1. $.get(type):将最后一个参数type指定为"json"
		2. 在服务器端设置MIME类型
			response.setContentType("application/json;charset=utf-8");
```





### 21.Redis

#### Redis内容

```
1. redis
	1. 概念
	2. 下载安装
	3. 命令操作
		1. 数据结构
	4. 持久化操作
	5. 使用Java客户端操作redis

```



```
1. 概念： redis是一款高性能的NOSQL系列的非关系型数据库
```

```
	1.1.什么是NOSQL
		NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。
		随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。

		1.1.1.	NOSQL和关系型数据库比较
			优点：
				1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。
				2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。
				3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。
				4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。

			缺点：
				1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。
				2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。
				3）不提供关系型数据库对事务的处理。

		1.1.2.	非关系型数据库的优势：
			1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。
			2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。

		1.1.3.	关系型数据库的优势：
			1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。
			2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。

		1.1.4.	总结
			关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，
			让NoSQL数据库对关系型数据库的不足进行弥补。
			一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据

	1.2.主流的NOSQL产品
		•	键值(Key-Value)存储数据库
				相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB
				典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 
				数据模型： 一系列键值对
				优势： 快速查询
				劣势： 存储的数据缺少结构化
		•	列存储数据库
				相关产品：Cassandra, HBase, Riak
				典型应用：分布式的文件系统
				数据模型：以列簇式存储，将同一列数据存在一起
				优势：查找速度快，可扩展性强，更容易进行分布式扩展
				劣势：功能相对局限
		•	文档型数据库
				相关产品：CouchDB、MongoDB
				典型应用：Web应用（与Key-Value类似，Value是结构化的）
				数据模型： 一系列键值对
				优势：数据结构要求不严格
				劣势： 查询性能不高，而且缺乏统一的查询语法
		•	图形(Graph)数据库
				相关数据库：Neo4J、InfoGrid、Infinite Graph
				典型应用：社交网络
				数据模型：图结构
				优势：利用图结构相关算法。
				劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。
	1.3 什么是Redis
		Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：
			1) 字符串类型 string
			2) 哈希类型 hash
			3) 列表类型 list
			4) 集合类型 set
			5) 有序集合类型 sortedset
		1.3.1 redis的应用场景
			•	缓存（数据查询、短连接、新闻内容、商品内容等等）
			•	聊天室的在线好友列表
			•	任务队列。（秒杀、抢购、12306等等）
			•	应用排行榜
			•	网站访问统计
			•	数据过期处理（可以精确到毫秒
			•	分布式集群架构中的session分离
```

```
2. 下载安装
	1. 官网：https://redis.io
	2. 中文网：http://www.redis.net.cn/
	3. 解压直接可以使用：
		* redis.windows.conf：配置文件
		* redis-cli.exe：redis的客户端
		* redis-server.exe：redis服务器端
	
3. 命令操作
	1. redis的数据结构：
		* redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构
			* value的数据结构：
				1) 字符串类型 string
				2) 哈希类型 hash ： map格式  
				3) 列表类型 list ： linkedlist格式。支持重复元素
				4) 集合类型 set  ： 不允许重复元素
				5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序 也称为zset
	
	2. 字符串类型 string
		1. 存储： set key value
			127.0.0.1:6379> set username zhangsan
			OK
		2. 获取： get key
			127.0.0.1:6379> get username
			"zhangsan"
		3. 删除： del key
			127.0.0.1:6379> del age
			(integer) 1
	3. 哈希类型 hash
		1. 存储： hset key field value
			127.0.0.1:6379> hset myhash username lisi
			(integer) 1
			127.0.0.1:6379> hset myhash password 123
			(integer) 1
		2. 获取： 
			* hget key field: 获取指定的field对应的值
				127.0.0.1:6379> hget myhash username
				"lisi"
			* hgetall key：获取所有的field和value
				127.0.0.1:6379> hgetall myhash
				1) "username"
				2) "lisi"
				3) "password"
				4) "123"
				
		3. 删除： hdel key field
			127.0.0.1:6379> hdel myhash username
			(integer) 1
	
	4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边）
		1. 添加：
			1. lpush key value: 将元素加入列表左表
				
			2. rpush key value：将元素加入列表右边
				
				127.0.0.1:6379> lpush myList a
				(integer) 1
				127.0.0.1:6379> lpush myList b
				(integer) 2
				127.0.0.1:6379> rpush myList c
				(integer) 3
		2. 获取：
			* lrange key start end ：范围获取
				127.0.0.1:6379> lrange myList 0 -1
				1) "b"
				2) "a"
				3) "c"
		3. 删除：
			* lpop key： 删除列表最左边的元素，并将元素返回
			* rpop key： 删除列表最右边的元素，并将元素返回
```

```
	5. 集合类型 set ： 不允许重复元素
		1. 存储：sadd key value
			127.0.0.1:6379> sadd myset a
			(integer) 1
			127.0.0.1:6379> sadd myset a
			(integer) 0
		2. 获取：smembers key:获取set集合中所有元素
			127.0.0.1:6379> smembers myset
			1) "a"
		3. 删除：srem key value:删除set集合中的某个元素	
			127.0.0.1:6379> srem myset a
			(integer) 1
	6. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。

		1. 存储：zadd key score value
			127.0.0.1:6379> zadd mysort 60 zhangsan
			(integer) 1
			127.0.0.1:6379> zadd mysort 50 lisi
			(integer) 1
			127.0.0.1:6379> zadd mysort 80 wangwu
			(integer) 1
		2. 获取：zrange key start end [withscores]
			127.0.0.1:6379> zrange mysort 0 -1
			1) "lisi"
			2) "zhangsan"
			3) "wangwu"

			127.0.0.1:6379> zrange mysort 0 -1 withscores
			1) "zhangsan"
			2) "60"
			3) "wangwu"
			4) "80"
			5) "lisi"
			6) "500"
		3. 删除：zrem key value
			127.0.0.1:6379> zrem mysort lisi
			(integer) 1

	7. 通用命令
		1. keys * : 查询所有的键
		2. type key ： 获取键对应的value的类型
		3. del key：删除指定的key value
```

```
4. 持久化
	1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。
	2. redis持久化机制：
		1. RDB：默认方式，不需要进行配置，默认就使用这种机制
		*RDB里的数据将会保存到dump.rdb文件中，如果AOF关闭，RDB启动则将读取这个文件
			* 在一定的间隔时间中，检测key的变化情况，然后持久化数据
			1. 编辑redis.windwos.conf文件
				#   after 900 sec (15 min) if at least 1 key changed
				save 900 1
				#   after 300 sec (5 min) if at least 10 keys changed
				save 300 10
				#   after 60 sec if at least 10000 keys changed
				save 60 10000
				
			2. 重新启动redis服务器，并指定配置文件名称
				D:\JavaWeb2018\day23_redis\资料\redis\windows-64\redis-2.8.9>redis-server.exe redis.windows.conf	
			
		2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据
		
		*如果RDB关闭，AOF启动时，将读取appendonly.aof文件中的信息。
			1. 编辑redis.windwos.conf文件
				appendonly no（关闭aof） --> appendonly yes （开启aof）
				
				# appendfsync always ： 每一次操作都进行持久化
				appendfsync everysec ： 每隔一秒进行一次持久化
				# appendfsync no	 ： 不进行持久化

5. Java客户端 Jedis
	* Jedis: 一款java操作redis数据库的工具.
	* 使用步骤：
		1. 下载jedis的jar包
		2. 使用
			//1. 获取连接
    		Jedis jedis = new Jedis("localhost",6379);
   			//2. 操作
   			jedis.set("username","zhangsan");
    		//3. 关闭连接
    		jedis.close();
```

​		
		* Jedis操作各种redis中的数据结构
			1) 字符串类型 string
				set
				get
				

```
			 //1. 获取连接
	        Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口
	        //2. 操作
	        //存储
	        jedis.set("username","zhangsan");
	        //获取
	        String username = jedis.get("username");
	        System.out.println(username);
	
	        //可以使用setex()方法存储可以指定过期时间的 key value
	        jedis.setex("activecode",20,"hehe");//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对
	
	        //3. 关闭连接
	        jedis.close();

		2) 哈希类型 hash ： map格式  
			hset
			hget
			hgetAll
			//1. 获取连接
	        Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口
	        //2. 操作
	        // 存储hash
	        jedis.hset("user","name","lisi");
	        jedis.hset("user","age","23");
	        jedis.hset("user","gender","female");
	
	        // 获取hash
	        String name = jedis.hget("user", "name");
	        System.out.println(name);
```

​		
		        // 获取hash的所有map中的数据
		        Map<String, String> user = jedis.hgetAll("user");
		

```
	        // keyset
	        Set<String> keySet = user.keySet();
	        for (String key : keySet) {
	            //获取value
	            String value = user.get(key);
	            System.out.println(key + ":" + value);
	        }
	
	        //3. 关闭连接
	        jedis.close();
```

```
		3) 列表类型 list ： linkedlist格式。支持重复元素
			lpush / rpush
			lpop / rpop
			lrange start end : 范围获取
			
			 //1. 获取连接
	        Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口
	        //2. 操作
	        // list 存储
	        jedis.lpush("mylist","a","b","c");//从左边存
	        jedis.rpush("mylist","a","b","c");//从右边存
	
	        // list 范围获取
	        List<String> mylist = jedis.lrange("mylist", 0, -1);
	        System.out.println(mylist);
	        
	        // list 弹出
	        String element1 = jedis.lpop("mylist");//c
	        System.out.println(element1);
	
	        String element2 = jedis.rpop("mylist");//c
	        System.out.println(element2);
	
	        // list 范围获取
	        List<String> mylist2 = jedis.lrange("mylist", 0, -1);
	        System.out.println(mylist2);
	
	        //3. 关闭连接
	        jedis.close();
```

```
		4) 集合类型 set  ： 不允许重复元素
			sadd
			smembers:获取所有元素

			//1. 获取连接
	        Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口
	        //2. 操作
```

​		
		        // set 存储
		        jedis.sadd("myset","java","php","c++");
		

```java
	        // set 获取
	        Set<String> myset = jedis.smembers("myset");
	        System.out.println(myset);
	
	        //3. 关闭连接
	        jedis.close();
		5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序
			zadd
			zrange

			//1. 获取连接
	        Jedis jedis = new Jedis();//如果使用空参构造，默认值 "localhost",6379端口
	        //2. 操作
	        // sortedset 存储
	        jedis.zadd("mysortedset",3,"亚瑟");
	        jedis.zadd("mysortedset",30,"后裔");
	        jedis.zadd("mysortedset",55,"孙悟空");
	
	        // sortedset 获取
	        Set<String> mysortedset = jedis.zrange("mysortedset", 0, -1);
	
	        System.out.println(mysortedset);
	           //3. 关闭连接

		        jedis.close();

```

​		
		     

​		
​		* jedis连接池： JedisPool
			* 使用：
				1. 创建JedisPool连接池对象
				2. 调用方法 getResource()方法获取Jedis连接
					//0.创建一个配置对象
			        JedisPoolConfig config = new JedisPoolConfig();
			        config.setMaxTotal(50);
			        config.setMaxIdle(10);
			

```java
		        //1.创建Jedis连接池对象
		        JedisPool jedisPool = new JedisPool(config,"localhost",6379);
		
		        //2.获取连接
		        Jedis jedis = jedisPool.getResource();
		        //3. 使用
		        jedis.set("hehe","heihei");
		        //4. 关闭 归还到连接池中

			     jedis.close();

```

​			
			 
​			

```java
		* 连接池工具类
			public class JedisPoolUtils {

			    private static JedisPool jedisPool;
			
			    static{
			        //读取配置文件
			        InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream("jedis.properties");
			        //创建Properties对象
			        Properties pro = new Properties();
			        //关联文件
			        try {
			            pro.load(is);
			        } catch (IOException e) {
			            e.printStackTrace();
			        }
			        //获取数据，设置到JedisPoolConfig中
			        JedisPoolConfig config = new JedisPoolConfig();
			        config.setMaxTotal(Integer.parseInt(pro.getProperty("maxTotal")));
			        config.setMaxIdle(Integer.parseInt(pro.getProperty("maxIdle")));
			
			        //初始化JedisPool
			        jedisPool = new JedisPool(config,pro.getProperty("host"),Integer.parseInt(pro.getProperty("port")));
			        			    }

				

				    /**

				     * 获取连接方法

				     */

				    public static Jedis getJedis(){

				        return jedisPool.getResource();

				    }

				}

```

​				


#### 案例：

```
案例需求：
	1. 提供index.html页面，页面中有一个省份 下拉列表
	2. 当 页面加载完成后 发送ajax请求，加载所有省份
```

```
* 注意：使用redis缓存一些不经常发生变化的数据。
	* 数据库的数据一旦发生改变，则需要更新缓存。
		* 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入
		* 在service对应的增删改方法中，将redis数据删除。
```







### 22.MAVEN

#### 	 Maven 的两个精典作用 

1. Maven 的依赖管理 

   只需要在pom文件中引入坐标，maven将自动将需要的包下载到maven本地仓库中。

2. 2.项目的一键构建 

   项目从编译、测试、运行、打包、安装 ，部署整个过程都交给 maven 进行管理，这个 过程称为构建。 









# 框架



## ​	Mybatis



## 一.Mybatis简介

#### 1.1原始jdbc操作（查询数据）

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day01/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%871.png)

#### 1.2原始jdbc操作（插入数据）

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day01/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%872.png)

#### 1.3 原始jdbc操作的分析

原始jdbc开发存在的问题如下：

①数据库连接创建、释放频繁造成系统资源浪费从而影响系统性能

②sql 语句在代码中硬编码，造成代码不易维护，实际应用 sql 变化的可能较大，sql 变动需要改变java代码。

③查询操作时，需要手动将结果集中的数据手动封装到实体中。插入操作时，需要手动将实体的数据设置到sql语句的占位符位置



应对上述问题给出的解决方案：

①使用数据库连接池初始化连接资源

②将sql语句抽取到xml配置文件中

③使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射

#### 1.4 什么是Mybatis

​	mybatis 是一个优秀的基于java的持久层框架，它内部封装了jdbc，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。

mybatis通过xml或注解的方式将要执行的各种 statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句。

最后mybatis框架执行sql并将结果映射为java对象并返回。采用ORM思想解决了实体和数据库映射的问题，对jdbc 进行了封装，屏蔽了jdbc api 底层访问细节，使我们不用与jdbc api 打交道，就可以完成对数据库的持久化操作。

### 2.Mybatis的快速入门

#### 2.1 MyBatis开发步骤

MyBatis官网地址：<http://www.mybatis.org/mybatis-3/> 

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day01/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%873.png)

**MyBatis开发步骤：**

①添加MyBatis的坐标

②创建user数据表

③编写User实体类 

④编写映射文件UserMapper.xml

⑤编写核心文件SqlMapConfig.xml

⑥编写测试类

#### 2.2 环境搭建

1)导入MyBatis的坐标和其他相关坐标

```xml
<!--mybatis坐标-->
<dependency>
    <groupId>org.mybatis</groupId>
    <artifactId>mybatis</artifactId>
    <version>3.4.5</version>
</dependency>
<!--mysql驱动坐标-->
<dependency>    
    <groupId>mysql</groupId>   
    <artifactId>mysql-connector-java</artifactId>    
    <version>5.1.6</version>    
    <scope>runtime</scope>
</dependency>
<!--单元测试坐标-->
<dependency>    
    <groupId>junit</groupId>    
    <artifactId>junit</artifactId>    
    <version>4.12</version>    
    <scope>test</scope>
</dependency>
<!--日志坐标-->
<dependency>    
    <groupId>log4j</groupId>    
    <artifactId>log4j</artifactId>    
    <version>1.2.12</version>
</dependency>
```

2)  创建user数据表

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day01/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%875.png)

3) 编写User实体

```java
public class User {    
	private int id;    
	private String username;    
	private String password;
    //省略get个set方法
}
```

4)编写UserMapper映射文件

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper        
	PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"        
	"http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="userMapper">    
	<select id="findAll" resultType="com.itheima.domain.User">        
		select * from User    
	</select>
</mapper>
```

5) 编写MyBatis核心文件

```xml
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN“ "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>    
	<environments default="development">        
		<environment id="development">            
			<transactionManager type="JDBC"/>            
			<dataSource type="POOLED">                
				<property name="driver" value="com.mysql.jdbc.Driver"/>
				<property name="url" value="jdbc:mysql:///test"/>                
				<property name="username" value="root"/>
				<property name="password" value="root"/>            
			</dataSource>        
		</environment>    
	</environments>    
	
	<mappers> 
		<mapper resource="com/itheima/mapper/UserMapper.xml"/> 
	</mappers>
</configuration>

```

#### 2.3 编写测试代码

```java
//加载核心配置文件
InputStream resourceAsStream = Resources.getResourceAsStream("SqlMapConfig.xml");
//获得sqlSession工厂对象
SqlSessionFactory sqlSessionFactory = new            
                           SqlSessionFactoryBuilder().build(resourceAsStream);
//获得sqlSession对象
SqlSession sqlSession = sqlSessionFactory.openSession();
//执行sql语句
List<User> userList = sqlSession.selectList("userMapper.findAll");
//打印结果
System.out.println(userList);
//释放资源
sqlSession.close();
```

#### 2.4 知识小结

**MyBatis开发步骤：**

①添加MyBatis的坐标

②创建user数据表

③编写User实体类 

④编写映射文件UserMapper.xml

⑤编写核心文件SqlMapConfig.xml

⑥编写测试类

### 3. MyBatis的映射文件概述

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day01/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%876.png)

### 4. MyBatis的增删改查操作

#### 4.1 MyBatis的插入数据操作

**1)编写UserMapper映射文件**

```xml
<mapper namespace="userMapper">    
	<insert id="add" parameterType="com.itheima.domain.User">        
		insert into user values(#{id},#{username},#{password})    
	</insert>
</mapper>
```

**2)编写插入实体User的代码**

```java
InputStream resourceAsStream = Resources.getResourceAsStream("SqlMapConfig.xml");
SqlSessionFactory sqlSessionFactory = new 
                        SqlSessionFactoryBuilder().build(resourceAsStream);
SqlSession sqlSession = sqlSessionFactory.openSession();
int insert = sqlSession.insert("userMapper.add", user);
System.out.println(insert);
//提交事务
sqlSession.commit();
sqlSession.close();
```

**3)插入操作注意问题**

• 插入语句使用insert标签

• 在映射文件中使用parameterType属性指定要插入的数据类型

•Sql语句中使用#{实体属性名}方式引用实体中的属性值

•插入操作使用的API是sqlSession.insert(“命名空间.id”,实体对象);

•插入操作涉及数据库数据变化，所以要使用sqlSession对象显示的提交事务，即sqlSession.commit() 

#### 4.2 MyBatis的修改数据操作

**1)编写UserMapper映射文件**

```xml
<mapper namespace="userMapper">
    <update id="update" parameterType="com.itheima.domain.User">
        update user set username=#{username},password=#{password} where id=#{id}
    </update>
</mapper>

```

**2)编写修改实体User的代码**

```java
InputStream resourceAsStream = Resources.getResourceAsStream("SqlMapConfig.xml");
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);
SqlSession sqlSession = sqlSessionFactory.openSession();
int update = sqlSession.update("userMapper.update", user);
System.out.println(update);
sqlSession.commit();
sqlSession.close();
```

**3)修改操作注意问题**

• 修改语句使用update标签

• 修改操作使用的API是sqlSession.update(“命名空间.id”,实体对象);

#### 4.3 MyBatis的删除数据操作

**1)编写UserMapper映射文件**

```xml
<mapper namespace="userMapper">
    <delete id="delete" parameterType="java.lang.Integer">
        delete from user where id=#{id}
    </delete>
</mapper>

```

**2)编写删除数据的代码**

```java
InputStream resourceAsStream = Resources.getResourceAsStream("SqlMapConfig.xml");
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);
SqlSession sqlSession = sqlSessionFactory.openSession();
int delete = sqlSession.delete("userMapper.delete",3);
System.out.println(delete);
sqlSession.commit();
sqlSession.close();
```

**3)删除操作注意问题**

• 删除语句使用delete标签

•Sql语句中使用#{任意字符串}方式引用传递的单个参数

•删除操作使用的API是sqlSession.delete(“命名空间.id”,Object);

#### 4.4 知识小结

```java
增删改查映射配置与API：
查询数据： List<User> userList = sqlSession.selectList("userMapper.findAll");
    <select id="findAll" resultType="com.itheima.domain.User">
        select * from User
    </select>
添加数据： sqlSession.insert("userMapper.add", user);
    <insert id="add" parameterType="com.itheima.domain.User">
        insert into user values(#{id},#{username},#{password})
    </insert>
修改数据： sqlSession.update("userMapper.update", user);
    <update id="update" parameterType="com.itheima.domain.User">
        update user set username=#{username},password=#{password} where id=#{id}
    </update>
删除数据：sqlSession.delete("userMapper.delete",3);
    <delete id="delete" parameterType="java.lang.Integer">
        delete from user where id=#{id}
    </delete>
```

### 5. MyBatis核心配置文件概述

#### 5.1 MyBatis核心配置文件层级关系

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day01/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%877.png)



#### 5.2 MyBatis常用配置解析

**1)environments标签**

数据库环境的配置，支持多环境配置

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day01/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%878.png)

其中，事务管理器（transactionManager）类型有两种：

•JDBC：这个配置就是直接使用了JDBC 的提交和回滚设置，它依赖于从数据源得到的连接来管理事务作用域。

•MANAGED：这个配置几乎没做什么。它从来不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接，然而一些容器并不希望这样，因此需要将 closeConnection 属性设置为 false 来阻止它默认的关闭行为。

其中，数据源（dataSource）类型有三种：

•UNPOOLED：这个数据源的实现只是每次被请求时打开和关闭连接。

•POOLED：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来。

•JNDI：这个数据源的实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。

**2)mapper标签**

该标签的作用是加载映射的，加载方式有如下几种：

•使用相对于类路径的资源引用，例如：

<mapper resource="org/mybatis/builder/AuthorMapper.xml"/>

•使用完全限定资源定位符（URL），例如：

<mapper url="file:///var/mappers/AuthorMapper.xml"/>

•使用映射器接口实现类的完全限定类名，例如：

<mapper class="org.mybatis.builder.AuthorMapper"/>

•将包内的映射器接口实现全部注册为映射器，例如：

<package name="org.mybatis.builder"/>

**3)Properties标签**

实际开发中，习惯将数据源的配置信息单独抽取成一个properties文件，该标签可以加载额外配置的properties文件

  ![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day01/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%879.png)

**4)typeAliases标签**

类型别名是为Java 类型设置一个短的名字。原来的类型名称配置如下

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day01/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%8710.png)

配置typeAliases，为com.itheima.domain.User定义别名为user

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day01/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%8711.png)

上面我们是自定义的别名，mybatis框架已经为我们设置好的一些常用的类型的别名

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day01/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%8712.png)

#### 5.3 知识小结

**核心配置文件常用配置：**

properties标签：该标签可以加载外部的properties文件

```xml
<properties resource="jdbc.properties"></properties>
```

typeAliases标签：设置类型别名

```xml
<typeAlias type="com.itheima.domain.User" alias="user"></typeAlias>
```

mappers标签：加载映射配置

```xml
<mapper resource="com/itheima/mapper/UserMapping.xml"></mapper>
```

environments标签：数据源环境配置标签

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day01/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%8713.png)

### 6.MyBatis相应API

#### 6.1 SqlSession工厂构建器SqlSessionFactoryBuilder

常用API：SqlSessionFactory  build(InputStream inputStream)

通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象

```java
String resource = "org/mybatis/builder/mybatis-config.xml"; 
InputStream inputStream = Resources.getResourceAsStream(resource); 
SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder(); 
SqlSessionFactory factory = builder.build(inputStream);
```

其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或一个 web URL 中加载资源文件。

#### 6.2 SqlSession工厂对象SqlSessionFactory

SqlSessionFactory 有多个个方法创建SqlSession 实例。常用的有如下两个：

![1552653723002](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day01/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%8714.png)

#### 6.3 SqlSession会话对象

SqlSession 实例在 MyBatis 中是非常强大的一个类。在这里你会看到所有执行语句、提交或回滚事务和获取映射器实例的方法。

执行语句的方法主要有：

```java
<T> T selectOne(String statement, Object parameter) 
<E> List<E> selectList(String statement, Object parameter) 
int insert(String statement, Object parameter) 
int update(String statement, Object parameter) 
int delete(String statement, Object parameter)

```

操作事务的方法主要有：

```java
void commit()  
void rollback() 
```



## 二.Mybatis具体实现

### 1.Mybatis的Dao层实现

#### 1.1 传统开发方式

##### 1.1.1编写UserDao接口

```java
public interface UserDao {
    List<User> findAll() throws IOException;
}
```

##### 1.1.2.编写UserDaoImpl实现

```java
public class UserDaoImpl implements UserDao {
    public List<User> findAll() throws IOException {
        InputStream resourceAsStream = 
                    Resources.getResourceAsStream("SqlMapConfig.xml");
        SqlSessionFactory sqlSessionFactory = new 
                    SqlSessionFactoryBuilder().build(resourceAsStream);
        SqlSession sqlSession = sqlSessionFactory.openSession();
        List<User> userList = sqlSession.selectList("userMapper.findAll");
        sqlSession.close();
        return userList;
    }
}
```

##### 1.1.3 测试传统方式

```java
@Test
public void testTraditionDao() throws IOException {
    UserDao userDao = new UserDaoImpl();
    List<User> all = userDao.findAll();
    System.out.println(all);
}

```

#### 1.2 代理开发方式

##### 1.2.1 代理开发方式介绍

采用 Mybatis 的代理开发方式实现 DAO 层的开发，这种方式是我们后面进入企业的主流。

Mapper 接口开发方法只需要程序员编写Mapper 接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。

Mapper 接口开发需要遵循以下规范：

**1) Mapper.xml文件中的namespace与mapper接口的全限定名相同**

**2) Mapper接口方法名和Mapper.xml中定义的每个statement的id相同**

**3) Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同**

**4) Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同**



##### 1.2.2 编写UserMapper接口

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day02/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE1.png)

##### 1.2.3测试代理方式

```java
@Test
public void testProxyDao() throws IOException {
    InputStream resourceAsStream = Resources.getResourceAsStream("SqlMapConfig.xml");
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resourceAsStream);
    SqlSession sqlSession = sqlSessionFactory.openSession();
    //获得MyBatis框架生成的UserMapper接口的实现类
  UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    User user = userMapper.findById(1);
    System.out.println(user);
    sqlSession.close();
}
```

#### 1.3 知识小结

MyBatis的Dao层实现的两种方式：

手动对Dao进行实现：传统开发方式

**代理方式对Dao进行实现：**

```
 **UserMapper userMapper = sqlSession.getMapper(UserMapper.class);**
```

### 2.MyBatis映射文件深入

#### 2.1 动态sql语句

##### 2.1.1动态sql语句概述

Mybatis 的映射文件中，前面我们的 SQL 都是比较简单的，有些时候业务逻辑复杂时，我们的 SQL是动态变化的，此时在前面的学习中我们的 SQL 就不能满足要求了。

参考的官方文档，描述如下：

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day02/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%872.png)

##### 2.1.2动态 SQL  之<**if>**

我们根据实体类的不同取值，使用不同的 SQL语句来进行查询。比如在 id如果不为空时可以根据id查询，如果username 不同空时还要加入用户名作为条件。这种情况在我们的多条件组合查询中经常会碰到。

```xml
<select id="findByCondition" parameterType="user" resultType="user">
    select * from User
    <where>
        <if test="id!=0">
            and id=#{id}
        </if>
        <if test="username!=null">
            and username=#{username}
        </if>
    </where>
</select>

```

当查询条件id和username都存在时，控制台打印的sql语句如下：

```java
     … … …
     //获得MyBatis框架生成的UserMapper接口的实现类
  UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
    User condition = new User();
    condition.setId(1);
    condition.setUsername("lucy");
    User user = userMapper.findByCondition(condition);
    … … …
```

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day02/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%873.png)



当查询条件只有id存在时，控制台打印的sql语句如下：

```java
 … … …
 //获得MyBatis框架生成的UserMapper接口的实现类
UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
User condition = new User();
condition.setId(1);
User user = userMapper.findByCondition(condition);
… … …

```

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day02/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%874.png)



##### 2.1.3 动态 SQL  之<**foreach>**

循环执行sql的拼接操作，例如：SELECT * FROM USER WHERE id IN (1,2,5)。

```xml
<select id="findByIds" parameterType="list" resultType="user">
    select * from User
    <where>
        <foreach collection="array" open="id in(" close=")" item="id" separator=",">
            #{id}
        </foreach>
    </where>
</select>
```

测试代码片段如下：

```java
 … … …
 //获得MyBatis框架生成的UserMapper接口的实现类
UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
int[] ids = new int[]{2,5};
List<User> userList = userMapper.findByIds(ids);
System.out.println(userList);
… … …

```

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day02/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%875.png)

foreach标签的属性含义如下：

<foreach>标签用于遍历集合，它的属性：

•collection：代表要遍历的集合元素，注意编写时不要写#{}

•open：代表语句的开始部分

•close：代表结束部分

•item：代表遍历集合的每个元素，生成的变量名

•sperator：代表分隔符

#### 2.2 SQL片段抽取

Sql 中可将重复的 sql 提取出来，使用时用 include 引用即可，最终达到 sql 重用的目的

```xml
<!--抽取sql片段简化编写-->
<sql id="selectUser" select * from User</sql>
<select id="findById" parameterType="int" resultType="user">
    <include refid="selectUser"></include> where id=#{id}
</select>
<select id="findByIds" parameterType="list" resultType="user">
    <include refid="selectUser"></include>
    <where>
        <foreach collection="array" open="id in(" close=")" item="id" separator=",">
            #{id}
        </foreach>
    </where>
</select>
```

#### 2.3 知识小结

MyBatis映射文件配置：

<select>：查询

<insert>：插入

<update>：修改

<delete>：删除

<where>：where条件

<if>：if判断

<foreach>：循环

<sql>：sql片段抽取



### 3. MyBatis核心配置文件深入

#### 3.1typeHandlers标签

无论是 MyBatis 在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用类型处理器将获取的值以合适的方式转换成 Java 类型。下表描述了一些默认的类型处理器（截取部分）。

 ![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day02/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%876.png)

你可以重写类型处理器或创建你自己的类型处理器来处理不支持的或非标准的类型。具体做法为：实现 org.apache.ibatis.type.TypeHandler 接口， 或继承一个很便利的类 org.apache.ibatis.type.BaseTypeHandler， 然后可以选择性地将它映射到一个JDBC类型。例如需求：一个Java中的Date数据类型，我想将之存到数据库的时候存成一个1970年至今的毫秒数，取出来时转换成java的Date，即java的Date与数据库的varchar毫秒值之间转换。

开发步骤：

①定义转换类继承类BaseTypeHandler<T>

②覆盖4个未实现的方法，其中setNonNullParameter为java程序设置数据到数据库的回调方法，getNullableResult为查询时 mysql的字符串类型转换成 java的Type类型的方法

③在MyBatis核心配置文件中进行注册

测试转换是否正确

```java
public class MyDateTypeHandler extends BaseTypeHandler<Date> {
    public void setNonNullParameter(PreparedStatement preparedStatement, int i, Date date, JdbcType type) {
        preparedStatement.setString(i,date.getTime()+"");
    }
    public Date getNullableResult(ResultSet resultSet, String s) throws SQLException {
        return new Date(resultSet.getLong(s));
    }
    public Date getNullableResult(ResultSet resultSet, int i) throws SQLException {
        return new Date(resultSet.getLong(i));
    }
    public Date getNullableResult(CallableStatement callableStatement, int i) throws SQLException {
        return callableStatement.getDate(i);
    }
}
```



```xml
<!--注册类型自定义转换器-->
<typeHandlers>
    <typeHandler handler="com.itheima.typeHandlers.MyDateTypeHandler"></typeHandler>
</typeHandlers>
```

测试添加操作：

```java
user.setBirthday(new Date());
userMapper.add2(user);
```

数据库数据：

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day02/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%877.png)

测试查询操作：

​    

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day02/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%878.png)

#### 3.2 plugins标签

MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即可获得分页的相关数据

开发步骤：

①导入通用PageHelper的坐标

②在mybatis核心配置文件中配置PageHelper插件

③测试分页数据获取



##### ①导入通用PageHelper坐标

```xml
<!-- 分页助手 -->
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper</artifactId>
    <version>3.7.5</version>
</dependency>
<dependency>
    <groupId>com.github.jsqlparser</groupId>
    <artifactId>jsqlparser</artifactId>
    <version>0.9.1</version>
</dependency>

```

##### ②在mybatis核心配置文件中配置PageHelper插件

```xml
<!-- 注意：分页助手的插件  配置在通用馆mapper之前 -->
<plugin interceptor="com.github.pagehelper.PageHelper">
    <!-- 指定方言 -->
    <property name="dialect" value="mysql"/>
</plugin>
```

##### ③测试分页代码实现

```java
@Test
public void testPageHelper(){
    //设置分页参数
    PageHelper.startPage(1,2);

    List<User> select = userMapper2.select(null);
    for(User user : select){
        System.out.println(user);
    }
}
```

**获得分页相关的其他参数**

```java
//其他分页的数据
PageInfo<User> pageInfo = new PageInfo<User>(select);
System.out.println("总条数："+pageInfo.getTotal());
System.out.println("总页数："+pageInfo.getPages());
System.out.println("当前页："+pageInfo.getPageNum());
System.out.println("每页显示长度："+pageInfo.getPageSize());
System.out.println("是否第一页："+pageInfo.isIsFirstPage());
System.out.println("是否最后一页："+pageInfo.isIsLastPage());

```

#### 3.3 知识小结

MyBatis核心配置文件常用标签：

1、properties标签：该标签可以加载外部的properties文件

2、typeAliases标签：设置类型别名

3、environments标签：数据源环境配置标签

4、typeHandlers标签：配置自定义类型处理器

5、plugins标签：配置MyBatis的插件

```
"
```





### 1.Mybatis多表查询

#### 1.1 一对一查询

##### 1.1.1 一对一查询的模型

用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户

一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day03/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%871.png)

##### 1.1.2一对一查询的语句

对应的sql语句：select *  from orders o,user u where o.uid=u.id;

查询的结果如下：

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day03/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%872.png)

##### 1.1.3 创建Order和User实体

```java
public class Order {

    private int id;
    private Date ordertime;
    private double total;

    //代表当前订单从属于哪一个客户
    private User user;
}

public class User {
    
    private int id;
    private String username;
    private String password;
    private Date birthday;

}
```

##### 1.1.4 创建OrderMapper接口

```java
public interface OrderMapper {
    List<Order> findAll();
}
```

##### 1.1.5 配置OrderMapper.xml

```xml
<mapper namespace="com.itheima.mapper.OrderMapper">
    <resultMap id="orderMap" type="com.itheima.domain.Order">
        <result column="uid" property="user.id"></result>
        <result column="username" property="user.username"></result>
        <result column="password" property="user.password"></result>
        <result column="birthday" property="user.birthday"></result>
    </resultMap>
    <select id="findAll" resultMap="orderMap">
        select * from orders o,user u where o.uid=u.id
    </select>
</mapper>
```

其中<resultMap>还可以配置如下：

```xml
<resultMap id="orderMap" type="com.itheima.domain.Order">
    <result property="id" column="id"></result>
    <result property="ordertime" column="ordertime"></result>
    <result property="total" column="total"></result>
    <association property="user" javaType="com.itheima.domain.User">
        <result column="uid" property="id"></result>
        <result column="username" property="username"></result>
        <result column="password" property="password"></result>
        <result column="birthday" property="birthday"></result>
    </association>
</resultMap>
```

##### 1.1.6 测试结果

```java
OrderMapper mapper = sqlSession.getMapper(OrderMapper.class);
List<Order> all = mapper.findAll();
for(Order order : all){
    System.out.println(order);
}
```

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day03/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%873.png)

#### 1.2 一对多查询

##### 1.2.1 一对多查询的模型

用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户

一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单

  ![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day03/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%874.png)

##### 1.2.2 一对多查询的语句

对应的sql语句：select *,o.id oid from user u left join orders o on u.id=o.uid;

查询的结果如下：

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day03/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%875.png)

##### 1.2.3 修改User实体

```java
public class Order {

    private int id;
    private Date ordertime;
    private double total;

    //代表当前订单从属于哪一个客户
    private User user;
}

public class User {
    
    private int id;
    private String username;
    private String password;
    private Date birthday;
    //代表当前用户具备哪些订单
    private List<Order> orderList;
}

```

##### 1.2.4 创建UserMapper接口

```java
public interface UserMapper {
    List<User> findAll();
}

```

##### 1.2.5 配置UserMapper.xml

```xml
<mapper namespace="com.itheima.mapper.UserMapper">
    <resultMap id="userMap" type="com.itheima.domain.User">
        <result column="id" property="id"></result>
        <result column="username" property="username"></result>
        <result column="password" property="password"></result>
        <result column="birthday" property="birthday"></result>
        <collection property="orderList" ofType="com.itheima.domain.Order">
            <result column="oid" property="id"></result>
            <result column="ordertime" property="ordertime"></result>
            <result column="total" property="total"></result>
        </collection>
    </resultMap>
    <select id="findAll" resultMap="userMap">
        select *,o.id oid from user u left join orders o on u.id=o.uid
    </select>
</mapper>
```

##### 1.2.6 测试结果

```java
UserMapper mapper = sqlSession.getMapper(UserMapper.class);
List<User> all = mapper.findAll();
for(User user : all){
    System.out.println(user.getUsername());
    List<Order> orderList = user.getOrderList();
    for(Order order : orderList){
        System.out.println(order);
    }
    System.out.println("----------------------------------");
}
```

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day03/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%876.png)

#### 1.3 多对多查询

##### 1.3.1 多对多查询的模型

用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用

多对多查询的需求：查询用户同时查询出该用户的所有角色

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day03/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%877.png)

##### 1.3.2 多对多查询的语句

对应的sql语句：select u.*,r.*,r.id rid from user u left join user_role ur on u.id=ur.user_id

 inner join role r on ur.role_id=r.id;

查询的结果如下：

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day03/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%878.png)

##### 1.3.3 创建Role实体，修改User实体

```java
public class User {
    private int id;
    private String username;
    private String password;
    private Date birthday;
    //代表当前用户具备哪些订单
    private List<Order> orderList;
    //代表当前用户具备哪些角色
    private List<Role> roleList;
}

public class Role {

    private int id;
    private String rolename;

}

```

##### 1.3.4  添加UserMapper接口方法

```java
List<User> findAllUserAndRole();
```

##### 1.3.5 配置UserMapper.xml

```xml
<resultMap id="userRoleMap" type="com.itheima.domain.User">
    <result column="id" property="id"></result>
    <result column="username" property="username"></result>
    <result column="password" property="password"></result>
    <result column="birthday" property="birthday"></result>
    <collection property="roleList" ofType="com.itheima.domain.Role">
        <result column="rid" property="id"></result>
        <result column="rolename" property="rolename"></result>
    </collection>
</resultMap>
<select id="findAllUserAndRole" resultMap="userRoleMap">
    select u.*,r.*,r.id rid from user u left join user_role ur on u.id=ur.user_id
    inner join role r on ur.role_id=r.id
</select>
```

##### 1.3.6 测试结果

```java
UserMapper mapper = sqlSession.getMapper(UserMapper.class);
List<User> all = mapper.findAllUserAndRole();
for(User user : all){
    System.out.println(user.getUsername());
    List<Role> roleList = user.getRoleList();
    for(Role role : roleList){
        System.out.println(role);
    }
    System.out.println("----------------------------------");
}
```

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day03/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%879.png)

#### 1.4 知识小结

MyBatis多表配置方式：

**一对一配置：使用<resultMap>做配置**

**一对多配置：使用<resultMap>+<collection>做配置**

**多对多配置：使用<resultMap>+<collection>做配置**



### 2.Mybatis的注解开发

#### 2.1 MyBatis的常用注解

这几年来注解开发越来越流行，Mybatis也可以使用注解开发方式，这样我们就可以减少编写Mapper

映射文件了。我们先围绕一些基本的CRUD来学习，再学习复杂映射多表操作。

@Insert：实现新增

@Update：实现更新

@Delete：实现删除

@Select：实现查询

@Result：实现结果集封装

@Results：可以与@Result 一起使用，封装多个结果集

@One：实现一对一结果集封装

@Many：实现一对多结果集封装

#### 2.2 MyBatis的增删改查

我们完成简单的user表的增删改查的操作

```java
private UserMapper userMapper;

@Before
public void before() throws IOException {
    InputStream resourceAsStream = Resources.getResourceAsStream("SqlMapConfig.xml");
    SqlSessionFactory sqlSessionFactory = new 
                 SqlSessionFactoryBuilder().build(resourceAsStream);
    SqlSession sqlSession = sqlSessionFactory.openSession(true);
    userMapper = sqlSession.getMapper(UserMapper.class);
}

@Test
public void testAdd() {
    User user = new User();
    user.setUsername("测试数据");
    user.setPassword("123");
    user.setBirthday(new Date());
    userMapper.add(user);
}
@Test
public void testUpdate() throws IOException {
    User user = new User();
    user.setId(16);
    user.setUsername("测试数据修改");
    user.setPassword("abc");
    user.setBirthday(new Date());
    userMapper.update(user);
}

@Test
public void testDelete() throws IOException {
    userMapper.delete(16);
}
@Test
public void testFindById() throws IOException {
    User user = userMapper.findById(1);
    System.out.println(user);
}
@Test
public void testFindAll() throws IOException {
    List<User> all = userMapper.findAll();
    for(User user : all){
        System.out.println(user);
    }
}

```

修改MyBatis的核心配置文件，我们使用了注解替代的映射文件，所以我们只需要加载使用了注解的Mapper接口即可

```xml
<mappers>
    <!--扫描使用注解的类-->
    <mapper class="com.itheima.mapper.UserMapper"></mapper>
</mappers>
```

或者指定扫描包含映射关系的接口所在的包也可以

```xml
<mappers>
    <!--扫描使用注解的类所在的包-->
    <package name="com.itheima.mapper"></package>
</mappers>
```

#### 2.3 MyBatis的注解实现复杂映射开发

实现复杂关系映射之前我们可以在映射文件中通过配置<resultMap>来实现，使用注解开发后，我们可以使用@Results注解，@Result注解，@One注解，@Many注解组合完成复杂关系的配置

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day03/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%8710.png)

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day03/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%8711.png)

#### 2.4 一对一查询

##### 2.4.1 一对一查询的模型

用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户

一对一查询的需求：查询一个订单，与此同时查询出该订单所属的用户

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day03/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%8712.png)

##### 2.4.2 一对一查询的语句

对应的sql语句：

```
select * from orders;

select * from user where id=查询出订单的uid;
```

查询的结果如下：

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day03/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%8713.png)

##### 2.4.3 创建Order和User实体

```java
public class Order {

    private int id;
    private Date ordertime;
    private double total;

    //代表当前订单从属于哪一个客户
    private User user;
}

public class User {
    
    private int id;
    private String username;
    private String password;
    private Date birthday;

}
```

##### 2.4.4 创建OrderMapper接口

```java
public interface OrderMapper {
    List<Order> findAll();
}
```

##### 2.4.5 使用注解配置Mapper

```java
public interface OrderMapper {
    @Select("select * from orders")
    @Results({
            @Result(id=true,property = "id",column = "id"),
            @Result(property = "ordertime",column = "ordertime"),
            @Result(property = "total",column = "total"),
            @Result(property = "user",column = "uid",
                    javaType = User.class,
                    one = @One(select = "com.itheima.mapper.UserMapper.findById"))
    })
    List<Order> findAll();
}
```

```java
public interface UserMapper {

    @Select("select * from user where id=#{id}")
    User findById(int id);
    
}
```

##### 2.4.6 测试结果

```java
@Test
public void testSelectOrderAndUser() {
    List<Order> all = orderMapper.findAll();
    for(Order order : all){
        System.out.println(order);
    }
}
```

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day03/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%8714.png)

#### 2.5 一对多查询

##### 2.5.1 一对多查询的模型

用户表和订单表的关系为，一个用户有多个订单，一个订单只从属于一个用户

一对多查询的需求：查询一个用户，与此同时查询出该用户具有的订单

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day03/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%8715.png)

##### 2.5.2 一对多查询的语句

对应的sql语句：

```
select * from user;

select * from orders where uid=查询出用户的id;
```

查询的结果如下：

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day03/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%8716.png)

##### 2.5.3 修改User实体

```java
public class Order {

    private int id;
    private Date ordertime;
    private double total;

    //代表当前订单从属于哪一个客户
    private User user;
}

public class User {
    
    private int id;
    private String username;
    private String password;
    private Date birthday;
    //代表当前用户具备哪些订单
    private List<Order> orderList;
}
```

##### 2.5.4 创建UserMapper接口

```java
List<User> findAllUserAndOrder();
```

##### 2.5.5 使用注解配置Mapper

```java
public interface UserMapper {
    @Select("select * from user")
    @Results({
            @Result(id = true,property = "id",column = "id"),
            @Result(property = "username",column = "username"),
            @Result(property = "password",column = "password"),
            @Result(property = "birthday",column = "birthday"),
            @Result(property = "orderList",column = "id",
                    javaType = List.class,
                    many = @Many(select = "com.itheima.mapper.OrderMapper.findByUid"))
    })
    List<User> findAllUserAndOrder();
}

public interface OrderMapper {
    @Select("select * from orders where uid=#{uid}")
    List<Order> findByUid(int uid);

}
```

##### 2.5.6 测试结果

```java
List<User> all = userMapper.findAllUserAndOrder();
for(User user : all){
    System.out.println(user.getUsername());
    List<Order> orderList = user.getOrderList();
    for(Order order : orderList){
        System.out.println(order);
    }
    System.out.println("-----------------------------");
}
```

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day03/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%8717.png)

#### 2.6 多对多查询

##### 2.6.1 多对多查询的模型

用户表和角色表的关系为，一个用户有多个角色，一个角色被多个用户使用

多对多查询的需求：查询用户同时查询出该用户的所有角色

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day03/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%8718.png)

##### 2.6.2 多对多查询的语句

对应的sql语句：

```
select * from user;

select * from role r,user_role ur where r.id=ur.role_id and ur.user_id=用户的id
```

查询的结果如下：

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day03/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%8719.png)

##### 2.6.3 创建Role实体，修改User实体

```java
public class User {
    private int id;
    private String username;
    private String password;
    private Date birthday;
    //代表当前用户具备哪些订单
    private List<Order> orderList;
    //代表当前用户具备哪些角色
    private List<Role> roleList;
}

public class Role {

    private int id;
    private String rolename;

}
```

##### 2.6.4 添加UserMapper接口方法

```java
List<User> findAllUserAndRole();
```

##### 2.6.5 使用注解配置Mapper

```java
public interface UserMapper {
    @Select("select * from user")
    @Results({
        @Result(id = true,property = "id",column = "id"),
        @Result(property = "username",column = "username"),
        @Result(property = "password",column = "password"),
        @Result(property = "birthday",column = "birthday"),
        @Result(property = "roleList",column = "id",
                javaType = List.class,
                many = @Many(select = "com.itheima.mapper.RoleMapper.findByUid"))
})
List<User> findAllUserAndRole();}



public interface RoleMapper {
    @Select("select * from role r,user_role ur where r.id=ur.role_id and ur.user_id=#{uid}")
    List<Role> findByUid(int uid);
}

```

##### 2.6.6 测试结果

```java
UserMapper mapper = sqlSession.getMapper(UserMapper.class);
List<User> all = mapper.findAllUserAndRole();
for(User user : all){
    System.out.println(user.getUsername());
    List<Role> roleList = user.getRoleList();
    for(Role role : roleList){
        System.out.println(role);
    }
    System.out.println("----------------------------------");
}
```

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day03/%E7%AC%94%E8%AE%B0/img/%E5%9B%BE%E7%89%8720.png)



### SSM框架整合

#### 1.1 原始方式整合

##### 1.准备工作

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day03/%E7%AC%94%E8%AE%B0/img/7.png)



##### 2.创建Maven工程

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day03/%E7%AC%94%E8%AE%B0/img/8.png)



##### 3.导入Maven坐标

参考：**素材/配置文件/pom.xml文件**

##### 4.编写实体类

```java
public class Account {
    private int id;
    private String name;
    private double money;
    //省略getter和setter方法
}
```

##### 5.编写Mapper接口

```java
public interface AccountMapper {
    //保存账户数据
    void save(Account account);
    //查询账户数据
    List<Account> findAll();
}
```



##### 6.编写Service接口

```java
public interface AccountService {
    void save(Account account); //保存账户数据
    List<Account> findAll(); //查询账户数据
}
```



##### 7.编写Service接口实现

```java
@Service("accountService")
public class AccountServiceImpl implements AccountService {
    public void save(Account account) {
        SqlSession sqlSession = MyBatisUtils.openSession();
        AccountMapper accountMapper = sqlSession.getMapper(AccountMapper.class);
        accountMapper.save(account);
        sqlSession.commit();
        sqlSession.close();
    }
    public List<Account> findAll() {
        SqlSession sqlSession = MyBatisUtils.openSession();
        AccountMapper accountMapper = sqlSession.getMapper(AccountMapper.class);
        return accountMapper.findAll();
    }
}
```



##### 8.编写Controller

```java
@Controller
public class AccountController {
    @Autowired
    private AccountService accountService;
    @RequestMapping("/save")
    @ResponseBody
    public String save(Account account){
        accountService.save(account);
        return "save success";
    }
    @RequestMapping("/findAll")
    public ModelAndView findAll(){
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.setViewName("accountList");
        modelAndView.addObject("accountList",accountService.findAll());
        return modelAndView;
    }
}
```



##### 9.编写添加页面

```html
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
    <h1>保存账户信息表单</h1>
    <form action="${pageContext.request.contextPath}/save.action" method="post">
        用户名称<input type="text" name="name"><br/>
        账户金额<input type="text" name="money"><br/>
        <input type="submit" value="保存"><br/>
    </form>
</body>
</html>
```



##### 10.编写列表页面

```html
<table border="1">
    <tr>
        <th>账户id</th>
        <th>账户名称</th>
        <th>账户金额</th>
    </tr>
    <c:forEach items="${accountList}" var="account">
        <tr>
            <td>${account.id}</td>
            <td>${account.name}</td>
            <td>${account.money}</td>
        </tr>
    </c:forEach>
</table>
```



##### 11.编写相应配置文件(文件参考目录：素材/配置文件)

•Spring配置文件：[applicationContext.xml](配置文件/applicationContext.xml)

•SprngMVC配置文件：[spring-mvc.xml](配置文件/spring-mvc.xml)

•MyBatis映射文件：[AccountMapper.xml](配置文件/AccountMapper.xml)

•MyBatis核心文件：[sqlMapConfig.xml](配置文件/sqlMapConfig.xml)

•数据库连接信息文件：[jdbc.properties](配置文件/jdbc.properties)

•Web.xml文件：[web.xml](配置文件/web.xml)

•日志文件：[log4j.xml](

##### 12.测试添加账户

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day03/%E7%AC%94%E8%AE%B0/img/9.jpg)

##### 13.测试账户列表

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day03/%E7%AC%94%E8%AE%B0/img/10.png)

#### 1.2 Spring整合MyBatis

##### 1.整合思路

![](D:/JAVAusertool/%E5%AD%A6%E4%B9%A0day%E6%96%87%E4%BB%B6/mybatis/mybatis-day03/%E7%AC%94%E8%AE%B0/img/11.png)



##### 2.将SqlSessionFactory配置到Spring容器中

```xml
<!--加载jdbc.properties-->
<context:property-placeholder location="classpath:jdbc.properties"/>
<!--配置数据源-->
<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
    <property name="driverClass" value="${jdbc.driver}"/>
    <property name="jdbcUrl" value="${jdbc.url}"/>
    <property name="user" value="${jdbc.username}"/>
    <property name="password" value="${jdbc.password}"/>
</bean>
<!--配置MyBatis的SqlSessionFactory-->
<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
    <property name="dataSource" ref="dataSource"/>
    <property name="configLocation" value="classpath:sqlMapConfig.xml"/>
</bean>
```



##### 3.扫描Mapper，让Spring容器产生Mapper实现类

```xml
<!--配置Mapper扫描-->
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
    <property name="basePackage" value="com.itheima.mapper"/>
</bean>
```



##### 4.配置声明式事务控制

```xml
<!--配置声明式事务控制-->
<bean id="transacionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
</bean>
<tx:advice id="txAdvice" transaction-manager="transacionManager">
    <tx:attributes>
        <tx:method name="*"/>
    </tx:attributes>
</tx:advice>
<aop:config>
    <aop:pointcut id="txPointcut" expression="execution(* com.itheima.service.impl.*.*(..))"/>
    <aop:advisor advice-ref="txAdvice" pointcut-ref="txPointcut"/>
</aop:config>
```



##### 5.修改Service实现类代码

```java
@Service("accountService")
public class AccountServiceImpl implements AccountService {

    @Autowired
    private AccountMapper accountMapper;

    public void save(Account account) {
        accountMapper.save(account);
    }
    public List<Account> findAll() {
        return accountMapper.findAll();
    }
}
```



## Spring

### 1.spring 是什么 

Spring是分层的 Java SE/EE应用 full-stack 轻量级开源框架，以 IoC（Inverse Of Control： 反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多 著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架





#### 1.1 IOC控制反转

Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。在Java开发中，Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：

谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。

为何是反转，哪些方面反转了：有反转就有正传，传统应用程序是有我们自己在对象中主动控制区主动创建和获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；

为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接收依赖对象，所以是反转；哪些方面反转了？一依赖对象的获取被反转了。



![1563853100050](C:\Users\lenovo\AppData\Local\Temp\1563853100050.png)



#### 1.2 IoC和DI

DI—Dependency Injection，即“依赖注入”：是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。

理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：

●谁依赖于谁：当然是应用程序依赖于IoC容器；

●为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源；

●谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象；

●注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。

IOC和DI之间的关系：其实他们是同一个概念的不同角度描述，由于控制反转概念比较含糊，相对IOC而言，“依赖注入”明确描述了“被注入对象依赖IOC容器配置依赖对象”。



注入只能注入set方法或构造器注入

 构造函数注入 
顾名思义，就是使用类中的构造函数，给成员变量赋值。注意，赋值的操作不是我们自己做的，而是通过配置
的方式，让 spring 框架来为我们注入。具体代码如下：

```java
 /**  */
public class AccountServiceImpl implements IAccountService {  
    private String name;  
    private Integer age; 
    private Date birthday;   
    public AccountServiceImpl(String name, Integer age, Date birthday) { 
        this.name = name; 
        this.age = age;  
        this.birthday = birthday; 
    } 

 @Override  public void saveAccount() { 
     System.out.println(name+","+age+","+birthday); 
 }
} 
```



```xml
<!-- 使用构造函数的方式，给 service 中的属性传值  要求：   类中需要提供一个对应参数列表的构造函数。  涉及的标签：   constructor-arg    属性：     index:指定参数在构造函数参数列表的索引位置     type:指定参数在构造函数中的数据类型 
name:指定参数在构造函数中的名称     用这个找给谁赋值      
    =======上面三个都是找给谁赋值，下面两个指的是赋什么值的==============      
    value:它能赋的值是基本数据类型和 String 类型     ref:它能赋的值是其他 bean 类型，也就是说，必须得是在配置文件中配置过的 bean   --> <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"> 
 <constructor-arg name="name" value=" 张三 "></constructor-arg>  <constructor-arg name="age" value="18"></constructor-arg> 
 <constructor-arg name="birthday" ref="now"></constructor-arg> </bean> 

<bean id="now" class="java.util.Date"></bean> 
```

 *  set 方法注入 

    ```java
    /** */ public class AccountServiceImpl implements IAccountService {  
        private String name;
        private Integer age; 
        private Date birthday;  
        public void setName(String name) { 
            this.name = name; 
        } 
        public void setAge(Integer age) { 
            this.age = age; 
        } 
        public void setBirthday(Date birthday) { 
            this.birthday = birthday; 
        } 
     
     @Override  public void saveAccount() { 
         System.out.println(name+","+age+","+birthday); 
     }
    } 
     
    
    ```

    配置文件代码

    ```xml
    <!-- 通过配置文件给 bean 中的属性传值：使用 set 方法的方式  涉及的标签：   property
    属性：    name：找的是类中 set 方法后面的部分    ref：给属性赋值是其他 bean 类型的    value：给属性赋值是基本数据类型和 string 类型的  实际开发中，此种方式用的较多。 --> 					<bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"> 
        <property name="name" value="test"></property> 
      <property name="age" value="21"></property>  
        <property name="birthday" ref="now"></property> 
    </bean> 
    <bean id="now" class="java.util.Date"></bean>
    ```

    



#### 2.AOP

面向切面编程，核心原理是**使用动态代理模式在方法执行前后或出现异常时加入相关逻辑。**

1.代理模式。

2.静态代理原理及实践。

3.动态代理原理及实践。

4.Spring AOP原理及实战。

##### 


## **1.代理模式**

代理模式：为其他对象提供一种代理以控制对这个对象的访问。这段话比较官方，但我更倾向于用自己的语言理解：比如A对象要做一件事情，在没有代理前，自己来做，在对A代理后，由A的代理类B来做。代理其实是在原实例前后加了一层处理，这也是AOP的初级轮廓。

## **2.静态代理原理及实践**

静态代理模式：静态代理说白了就是在程序运行前就已经存在代理类的字节码文件，代理类和原始类的关系在运行前就已经确定。废话不多说，我们看一下代码，为了方便阅读，博主把单独的class文件合并到接口中，读者可以直接复制代码运行：

```
package test.staticProxy;
// 接口
public interface IUserDao {
 void save();
 void find();
}
//目标对象
class UserDao implements IUserDao{
 @Override
 public void save() {
   System.out.println("模拟：保存用户！");
 }
 @Override
 public void find() {
   System.out.println("模拟：查询用户");
 }
}
/**
   静态代理
         特点：
 1. 目标对象必须要实现接口
 2. 代理对象，要实现与目标对象一样的接口
*/
class UserDaoProxy implements IUserDao{
 // 代理对象，需要维护一个目标对象
 private IUserDao target = new UserDao();
 @Override
 public void save() {
   System.out.println("代理操作： 开启事务...");
   target.save();   // 执行目标对象的方法
   System.out.println("代理操作：提交事务...");
 }
 @Override
 public void find() {
   target.find();
 }
}
```

测试结果：

​                               ![640?](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaINcWuial6ZVHTpuAOjIOGxZRHFHFoRQA7ic60sSlicpCWBXVsjichDVAYwiagdd9gWWC5ibQgysHTC7kyow/640?)

静态代理虽然保证了业务类只需关注逻辑本身，代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理。再者，如果增加一个方法，除了实现类需要实现这个方法外，所有的代理类也要实现此方法。增加了代码的维护成本。那么要如何解决呢?答案是使用动态代理。

## **3.动态代理原理及实践**

动态代理模式:动态代理类的源码是在程序运行期间通过JVM反射等机制动态生成，代理类和委托类的关系是运行时才确定的。实例如下:

```
package test.dynamicProxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
// 接口
public interface IUserDao {
 void save();
 void find();
}
//目标对象
class UserDao implements IUserDao{
 @Override
 public void save() {
   System.out.println("模拟： 保存用户！");
 }
 @Override
 public void find() {
   System.out.println("查询");
 }
}
/**
* 动态代理：
*    代理工厂，给多个目标对象生成代理对象！
*
*/
class ProxyFactory {
 // 接收一个目标对象
 private Object target;
 public ProxyFactory(Object target) {
   this.target = target;
 }
 // 返回对目标对象(target)代理后的对象(proxy)
 public Object getProxyInstance() {
   Object proxy = Proxy.newProxyInstance(
     target.getClass().getClassLoader(),  // 目标对象使用的类加载器
     target.getClass().getInterfaces(),   // 目标对象实现的所有接口
     new InvocationHandler() {      // 执行代理对象方法时候触发
       @Override
       public Object invoke(Object proxy, Method method, Object[] args)
           throws Throwable {
         
         // 获取当前执行的方法的方法名
         String methodName = method.getName();
         // 方法返回值
         Object result = ;
         if ("find".equals(methodName)) {
           // 直接调用目标对象方法
           result = method.invoke(target, args);
         } else {
           System.out.println("开启事务...");
           // 执行目标对象方法
           result = method.invoke(target, args);
           System.out.println("提交事务...");
         }
         return result;
       }
     }
   );
   return proxy;
 }
}
```

测试结果如下:

![640?](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaINcWuial6ZVHTpuAOjIOGxZRkanfGVaIibcaGZU9qHP4vPCNLjLdTC5KeU1uCN7HJ6vmccveeEL9K8A/640?)

在运行测试类中创建测试类对象代码中

```
IUserDao proxy = (IUserDao)new ProxyFactory(target).getProxyInstance();
```

其实是JDK动态生成了一个类去实现接口,隐藏了这个过程:

```
class $jdkProxy implements IUserDao{}
```

**使用jdk生成的动态代理的前提是目标类必须有实现的接口**。但这里又引入一个问题,如果某个类没有实现接口,就不能使用JDK动态代理,所以Cglib代理就是解决这个问题的。

Cglib是以动态生成的子类继承目标的方式实现，在运行期动态的在内存中构建一个子类，如下:

```
public class UserDao{}
//Cglib是以动态生成的子类继承目标的方式实现,程序执行时,隐藏了下面的过程
public class $Cglib_Proxy_class  extends UserDao{}
```

**Cglib使用的前提是目标类不能为final修饰**。因为final修饰的类不能被继承。

现在，我们可以看看AOP的定义：面向切面编程，核心原理是**使用动态代理模式在方法执行前后或出现异常时加入相关逻辑。**

通过定义和前面代码我们可以发现3点：

​    1.AOP是基于动态代理模式。

​    2.AOP是方法级别的（要测试的方法不能为static修饰，因为接口中不能存在静态方法，编译就会报错）。

​    3.AOP可以分离业务代码和关注点代码（重复代码），在执行业务代码时，动态的注入关注点代码。切面就是关注点代码形成的类。

## **4.spring AOP原理及实战**

前文提到JDK代理和Cglib代理两种动态代理，优秀的Spring框架把两种方式在底层都集成了进去,我们无需担心自己去实现动态生成代理。那么，Spring是如何生成代理对象的？：

​    1.创建容器对象的时候，根据切入点表达式拦截的类，生成代理对象。

​    2.如果目标对象有实现接口，使用jdk代理。如果目标对象没有实现接口，则使用Cglib代理。然后从容器获取代理后的对象，在运行期植入"切面"类的方法。通过查看Spring源码，我们在DefaultAopProxyFactory类中，找到这样一段话。

![640?](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaINcWuial6ZVHTpuAOjIOGxZRcBreK91U3XJWa4rJfwmNy7IibLvOaWKp0gjN018R70HrZVyKGSKEHIQ/640?)

简单的从字面意思看出,如果有接口,则使用Jdk代理,反之使用Cglib，这刚好印证了前文所阐述的内容。Spring AOP综合两种代理方式的使用前提有会如下结论：**如果目标类没有实现接口，且class为final修饰的，则不能进行Spring AOP****编程！**

知道了原理，现在我们将自己手动实现Spring的AOP：

```
package test.spring_aop_anno;

import org.aspectj.lang.ProceedingJoinPoint;

public interface IUserDao {
 void save();
}
//用于测试Cglib动态代理
class OrderDao {
 public void save() {
   //int i =1/0;用于测试异常通知
   System.out.println("保存订单...");
 }
}
//用于测试jdk动态代理
class UserDao implements IUserDao {
 public void save() {
   //int i =1/0;用于测试异常通知
   System.out.println("保存用户...");
 }
}
//切面类
class TransactionAop {
 public void beginTransaction() {
   System.out.println("[前置通知]  开启事务..");
 }
 public void commit() {
   System.out.println("[后置通知] 提交事务..");
 }
 public void afterReturing(){
   System.out.println("[返回后通知]");
 }
 public void afterThrowing(){
   System.out.println("[异常通知]");
 }
 public void arroud(ProceedingJoinPoint pjp) throws Throwable{
   System.out.println("[环绕前：]");
   pjp.proceed();             // 执行目标方法
   System.out.println("[环绕后：]");
 }
}
```

Spring的xml配置文件:

```xml
xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
   xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xmlns:context="http://www.springframework.org/schema/context"
   xmlns:aop="http://www.springframework.org/schema/aop"
   xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd">
 
 <bean id="userDao" class="test.spring_aop_anno.UserDao">bean>
 
 
 <bean id="orderDao" class="test.spring_aop_anno.OrderDao">bean>
 
 
 <bean id="transactionAop" class="test.spring_aop_anno.TransactionAop">bean>
 
 
 <aop:config>
   
   <aop:pointcut expression="execution(* test.spring_aop_anno.*Dao.*(..))" id="transactionPointcut"/>
   
   <aop:aspect ref="transactionAop">
     
     <aop:around method="arroud" pointcut-ref="transactionPointcut"/>
     
     <aop:before method="beginTransaction" pointcut-ref="transactionPointcut" />
     
     <aop:after method="commit" pointcut-ref="transactionPointcut"/>
     
     <aop:after-returning method="afterReturing" pointcut-ref="transactionPointcut"/>
     
     <aop:after-throwing method="afterThrowing" pointcut-ref="transactionPointcut"/>
   <aop:aspect>
 <aop:config>
<beans>
```

切入点表达式不在这里介绍。ref:Spring AOP 切入点表达式：http://blog.csdn.net/keda8997110/article/details/50747923

代码的测试结果如下:

![640?](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/QCu849YTaINcWuial6ZVHTpuAOjIOGxZReCGkvxfZTSSglztyysAWxiaiaqiaTMIVbPcSytOmqYwsILDSBJt2ictBbA/640?)

到这里,我们已经全部介绍完Spring AOP，回到开篇的问题，我们拿它做什么？

​    1.Spring声明式事务管理配置。

​    2.Controller层的参数校验。

​    3.使用Spring AOP实现MySQL数据库读写分离案例分析

​    4.在执行方法前,判断是否具有权限。

​    5.对部分函数的调用进行日志记录。监控部分重要函数，若抛出指定的异常，可以以短信或邮件方式通知相关人员。

​    6.信息过滤，页面转发等等功能。



## Spring相关知识点

### 第1章 案例：使用 spring的 IoC的实现账户的 CRUD 

#### 1.1 需求和技术要求 

1.1.1 需求 
实现账户的 CRUD 操作 
1.1.2 技术要求 
使用 spring 的 IoC 实现对象的管理 使用 DBAssit 作为持久层解决方案 使用 c3p0 数据源 

#### 1.2 环境搭建 

1.2.1 拷贝 jar包 

1.2.2 创建数据库和编写实体类 

```sql
create table account(  id int primary key auto_increment,  name varchar(40),  money float )character set utf8 collate utf8_general_ci; 

insert into account(name,money) values('aaa',1000); 
insert into account(name,money) values('bbb',1000); insert into account(name,money) values('ccc',1000); 
```


 * 账户的实体类

   ```java
   /** -   * @author 黑马程序员  * @Company http://www.ithiema.com  * @Version 1.0  */ 
   public class Account implements Serializable { 
   
    private Integer id; 
   private String name; 
   private Float money; 
   public Integer getId() {  
       return id; 
   } 
   public void setId(Integer id) { 
       this.id = id; 
   } 
   public String getName() { 
       return name; 
   } 
   public void setName(String name) {
       this.name = name;  
   } 
   public Float getMoney() { 
       return money; 
   }  public void setMoney(Float money) { 
       this.money = money;
   	} 
   } 
   ```

   



1.2.3 编写持久层代码 
```java
/** 

- 账户的持久层接口  * @author 黑马程序员  * @Company http://www.ithiema.com  * @Version 1.0  */ public interface IAccountDao {    /** 
- 保存   * @param account   */ 
    void save(Account account);    /** 
- 更新   * @param account   */ 
    void update(Account account); 

 /** 

- 删除   * @param accountId   */ 
    void delete(Integer accountId);    /** 
- 根据 id 查询   * @param accountId   * @return   */ 
    Account findById(Integer accountId);    /** 
- 查询所有   * @return   */ 
  List<Account> findAll(); 

} 

/** 

```


 * 账户的持久层实现类  

   ```java
   /* @author 黑马程序员  * @Company http://www.ithiema.com  * @Version 1.0  */ 
   - public class AccountDaoImpl implements IAccountDao { 
   
    private DBAssit dbAssit;      public void setDbAssit(DBAssit dbAssit) {   this.dbAssit = dbAssit;  } 
   
    @Override  public void save(Account account) {   dbAssit.update("insert into account(name,money)values(?,?)",account.getName(),account.getMoney());  } 
   
    @Override  public void update(Account account) {   dbAssit.update("update account set name=?,money=? where id=?",account.getName(),account.getMoney(),account.getId());  } 
   
    @Override  public void delete(Integer accountId) {   dbAssit.update("delete from account where id=?",accountId);  } 
   
    @Override  public Account findById(Integer accountId) {   return dbAssit.query("select * from account where id=?",new BeanHandler<Account>(Account.class),accountId);  } 
   
    @Override  public List<Account> findAll() {   return  dbAssit.query("select * from account where id=?",new BeanListHandler<Account>(Account.class));  } 
   
   } 
   ```

   



1.2.4 编写业务层代码 
```java
/** 

- 账户的业务层接口  * @author 黑马程序员  * @Company http://www.ithiema.com  * @Version 1.0  */ public interface IAccountService { 

 /** 

- 保存账户   * @param account   */  void saveAccount(Account account);      /** 
- 更新账户   * @param account   */  void updateAccount(Account account);   
  /** 
- 删除账户   * @param account   */  void deleteAccount(Integer accountId);    /** 
- 根据 id 查询账户   * @param accountId   * @return   */  Account findAccountById(Integer accountId);    /** 
- 查询所有账户   * @return   */  List<Account> findAllAccount(); 
  } 

/** 
```



 * 账户的业务层实现类  

   ```java
   /* @author 黑马程序员  * @Company http://www.ithiema.com  * @Version 1.0  */ 
   - public class AccountServiceImpl implements IAccountService {   
       private IAccountDao accountDao; 
   
    public void setAccountDao(IAccountDao accountDao) {   
        this.accountDao = accountDao;  } 
   
    @Override  public void saveAccount(Account account) {  
        accountDao.save(account);  } 
   
    @Override  public void updateAccount(Account account) { 
        accountDao.update(account);  } 
   
    @Override  public void deleteAccount(Integer accountId) { 
        accountDao.delete(accountId);  } 
   
    @Override  public Account findAccountById(Integer accountId) { 
        return accountDao.findById(accountId);  } 
   
    @Override  public List<Account> findAllAccount() {   
        return accountDao.findAll();  } 
   } 
   ```

   



1.2.5 创建并编写配置文件 

```xml
<?xml version="1.0" encoding="UTF-8"?> <beans xmlns="http://www.springframework.org/schema/beans"     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"     xsi:schemaLocation="http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd"> </beans> 
```



#### 1.3 配置步骤 

1.3.1 配置对象 

```xml
<?xml version="1.0" encoding="UTF-8"?> <beans xmlns="http://www.springframework.org/schema/beans"     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
    xsi:schemaLocation="http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd">      
 <!-- 配置 service -->
    <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl">
        <property name="accountDao" ref="accountDao"></property> 
 	</bean> 

 <!-- 配置 dao -->  
    <bean id="accountDao" class="com.itheima.dao.impl.AccountDaoImpl"> 
        <property name="dbAssit" ref="dbAssit"></property> 
    </bean>   
 <!-- 配置 dbAssit 此处我们只注入了数据源，表明每条语句独立事务-->
    <bean id="dbAssit" class="com.itheima.dbassit.DBAssit"> 


  <property name="dataSource" ref="dataSource"></property> 
 </bean>   
 <!-- 配置数据源 --> 
    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"> 
  <property name="driverClass" value="com.mysql.jdbc.Driver"></property>  
    <property name="jdbcUrl" value="jdbc:mysql:///spring_day02"></property> 
    <property name="user" value="root"></property> 
 	 <property name="password" value="1234"></property> 
    </bean> 
</beans> 
```

1.4 测试案例 
1.4.1 测试类代码 
 * ```java
   /** 
   
   - 测试类
   -   * @author 黑马程序员  * @Company http://www.ithiema.com  * @Version 1.0  */ public class AccountServiceTest {    /** 
   - 测试保存   */ 
       @Test 
       public void testSaveAccount() { 
           Account account = new Account(); 
           account.setName("黑马程序员"); 
           account.setMoney(100000f); 
           ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");   IAccountService as = ac.getBean("accountService",IAccountService.class);   as.saveAccount(account);  } 
   
    /** 
    - 测试查询一个   */ 
     @Test  public void testFindAccountById() {  
         ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); 
     
   
     IAccountService as = ac.getBean("accountService",IAccountService.class); 
         Account account = as.findAccountById(1); 
         System.out.println(account);  }   
   
    /** 
   - 测试更新   */ 
     @Test  public void testUpdateAccount() {   ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");   IAccountService as = ac.getBean("accountService",IAccountService.class);   Account account = as.findAccountById(1);   account.setMoney(20301050f); 
       as.updateAccount(account);  }    /** 
   - 测试删除   */  @Test  public void testDeleteAccount() {   ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");   IAccountService as = ac.getBean("accountService",IAccountService.class);   as.deleteAccount(1);  } 
   
    /** 
   
   - 测试查询所有   */ 
     @Test  public void testFindAllAccount() {   ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");   IAccountService as = ac.getBean("accountService",IAccountService.class);   List<Account> list = as.findAllAccount();   for(Account account : list) {    System.out.println(account);   }  } 
     } 
   
   ```

  * 1.4.2 分析测试了中的问题 
     通过上面的测试类，我们可以看出，每个测试方法都重新获取了一次 spring 的核心容器，造成了不必要的重
     

复代码，增加了我们开发的工作量。这种情况，在开发中应该避免发生。 有些同学可能想到了，我们把容器的获取定义到类中去。例如：

```java
 /** 

- 测试类  * @author 黑马程序员  * @Company http://www.ithiema.com  * @Version 1.0  */
public class AccountServiceTest { 
    private ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml"); 
    private IAccountService as = ac.getBean("accountService",IAccountService.class);
} 
```


 * 这种方式虽然能解决问题，但是扔需要我们自己写代码来获取容器。 能不能测试时直接就编写测试方法，而不需要手动编码来获取容器呢？ 请在今天的最后一章节找答案。 

  ### 第2章 基于注解的 IOC 配置 

  2.1 明确：写在最前 学习基于注解的 IoC 配置，大家脑海里首先得有一个认知，即注解配置和 xml 配置要实现的功能都是一样 的，都是要降低程序间的耦合。只是配置的形式不一样。 关于实际的开发中到底使用xml还是注解，每家公司有着不同的使用习惯。所以这两种配置方式我们都需要掌 握。 我们在讲解注解配置时，采用上一章节的案例，把 spring 的 xml 配置内容改为使用注解逐步实现。 

  #### 2.2 环境搭建 

  2.2.1 第一步：拷贝必备 jar 包到工程的 lib 目录。 
    注意：在基于注解的配置中，我们还要多拷贝一个 aop 的 jar 包。如下图： 



2.2.2 第二步：使用@Component 注解配置管理的资源 
```java
/** 

- 账户的业务层实现类  * @author 黑马程序员  * @Company http://www.ithiema.com  * @Version 1.0  */ 
  @Component("accountService") public class AccountServiceImpl implements IAccountService {    private IAccountDao accountDao; 

 public void setAccountDao(IAccountDao accountDao) {   this.accountDao = accountDao;  } } 

/** 

- 账户的持久层实现类  * @author 黑马程序员  * @Company http://www.ithiema.com  * @Version 1.0  */ 
  @Component("accountDao") public class AccountDaoImpl  implements IAccountDao { 

 private DBAssit dbAssit;
  } 
```



注意：  1、当我们使用注解注入时，set 方法不用写 
2.2.3 第三步：创建 spring 的 xml配置文件并开启对注解的支持 

注意：  基于注解整合时，导入约束时需要多导入一个 context 名称空间下的约束。  由于我们使用了注解配置，此时不能在继承 JdbcDaoSupport，需要自己配置一个 JdbcTemplate 

```xml
<?xml version="1.0" encoding="UTF-8"?> <beans xmlns="http://www.springframework.org/schema/beans"  xmlns:context="http://www.springframework.org/schema/context" 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"     xsi:schemaLocation="http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd 
        http://www.springframework.org/schema/context         http://www.springframework.org/schema/context/spring-context.xsd"> 
     
 <!-- 告知 spring 创建容器时要扫描的包 --> 
    <context:component-scan base-package="com.itheima"></context:component-scan>   
 <!-- 配置 dbAssit -->  <bean id="dbAssit" class="com.itheima.dbassit.DBAssit"> 
    <property name="dataSource" ref="dataSource"></property> 
 </bean>   
 <!-- 配置数据源 --> 
    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">  
        <property name="driverClass" value="com.mysql.jdbc.Driver"></property> 
        <property name="jdbcUrl" value="jdbc:mysql:///spring_day02"></property>  
        <property name="user" value="root"></property>   <property name="password" value="1234"></property> 
    </bean> 
</beans> 
```




#### 2.3 常用注解 

2.3.1 用于创建对象的 
 相当于：<bean id="" class=""> 

##### 2.3.1.1 @Component 

作用：  把资源让 spring 来管理。相当于在 xml 中配置一个 bean。 属性：  value：指定 bean 的 id。如果不指定 value 属性，默认 bean 的 id 是当前类的类名。首字母小写。 
2.3.1.2 @Controller  @Service  @Repository 
他们三个注解都是针对一个的衍生注解，他们的作用及属性都是一模一样的。 他们只不过是提供了更加明确的语义化。  @Controller：一般用于表现层的注解。  @Service：一般用于业务层的注解。  @Repository：一般用于持久层的注解。 细节：如果注解中有且只有一个属性要赋值时，且名称是 value，value在赋值是可以不写。 
2.3.2 用于注入数据的 
 相当于：

```xml
<property name="" ref="">      
<property name="" value=""> 
```



##### 2.3.2.1 @Autowired 

作用：  自动按照类型注入。当使用注解注入属性时，set方法可以省略。它只能注入其他 bean 类型。当有多个 类型匹配时，使用要注入的对象变量名称作为 bean 的 id，在 spring 容器查找，找到了也可以注入成功。找不到 就报错。 
传智播客——专注于 Java、.Net 和Php、网页平面设计工程师的培训 
北京市昌平区建材城西路金燕龙办公楼一层   电话：400-618-9090 

##### 2.3.2.2 @Qualifier 

作用：  在自动按照类型注入的基础之上，再按照 Bean 的 id 注入。它在给字段注入时不能独立使用，必须和 @Autowire 一起使用；但是给方法参数注入时，可以独立使用。 属性：  value：指定 bean 的 id。 

##### 2.3.2.3 @Resource 

作用：  直接按照 Bean 的 id 注入。它也只能注入其他 bean 类型。 属性：  name：指定 bean 的 id。 

##### 2.3.2.4 @Value 

作用：  注入基本数据类型和 String 类型数据的 属性：  value：用于指定值 
2.3.3 用于改变作用范围的： 
 相当于：<bean id="" class="" scope=""> 

##### 2.3.3.1 @Scope 

作用：  指定 bean 的作用范围。 属性：  value：指定范围的值。      取值：singleton  prototype request session globalsession 
2.3.4 和生命周期相关的：(了解)   
 相当于：<bean id="" class="" init-method="" destroy-method="" /> 


##### 2.3.4.1 @PostConstruct 

作用：  用于指定初始化方法。 

##### 2.3.4.2 @PreDestroy 

作用：  用于指定销毁方法。 
2.3.5 关于 Spring 注解和 XML的选择问题 
注解的优势：  配置简单，维护方便（我们找到类，就相当于找到了对应的配置）。 XML 的优势：  修改时，不用改源码。不涉及重新编译和部署。 Spring 管理 Bean方式的比较： 



2.4 spring管理对象细节 
基于注解的 spring IoC 配置中，bean 对象的特点和基于 XML 配置是一模一样的。 
2.5 spring的纯注解配置 
写到此处，基于注解的 IoC 配置已经完成，但是大家都发现了一个问题：我们依然离不开 spring 的 xml 配 置文件，那么能不能不写这个 bean.xml，所有配置都用注解来实现呢？ 当然，同学们也需要注意一下，我们选择哪种配置的原则是简化开发和配置方便，而非追求某种技术。 

2.5.1 待改造的问题 
我们发现，之所以我们现在离不开 xml 配置文件，是因为我们有一句很关键的配置：

```xml
 <!-- 告知spring框架在，读取配置文件，创建容器时，扫描注解，依据注解创建对象，并存入容器中 --> <context:component-scan base-package="com.itheima"></context:component-scan> 
如果他要也能用注解配置，那么我们就离脱离 xml 文件又进了一步。 

另外，数据源和 JdbcTemplate 的配置也需要靠注解来实现。 
<!-- 配置 dbAssit -->  <bean id="dbAssit" class="com.itheima.dbassit.DBAssit"> 
  <property name="dataSource" ref="dataSource"></property> 
</bean>   
 <!-- 配置数据源 --> 
<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"> 
  <property name="driverClass" value="com.mysql.jdbc.Driver"></property> 
    <property name="jdbcUrl" value="jdbc:mysql:///spring_day02"></property>  
    <property name="user" value="root"></property> 
    <property name="password" value="1234"></property> 
</bean> 
```

#### 2.5.2 新注解说明 

##### 2.5.2.1 @Configuration 

作用：  用于指定当前类是一个 spring 配置类，当创建容器时会从该类上加载注解。获取容器时需要使用 AnnotationApplicationContext(有@Configuration 注解的类.class)。 属性：  value:用于指定配置类的字节码 


示例代码：

```java
 /** 

- spring 的配置类，相当于 bean.xml 文件  * @author 黑马程序员  * @Company http://www.ithiema.com  * @Version 1.0  */ @Configuration public class SpringConfiguration { } 
```

 * 注意：  我们已经把配置文件用类来代替了，但是如何配置创建容器时要扫描的包呢？  请看下一个注解。 

  ##### 2.5.2.2 @ComponentScan 

  作用：  用于指定 spring 在初始化容器时要扫描的包。作用和在 spring 的 xml 配置文件中的： <context:component-scan base-package="com.itheima"/>是一样的。 属性：  basePackages：用于指定要扫描的包。和该注解中的 value 属性作用一样。 示例代码：

  ```java
  -  /** 
  - spring 的配置类，相当于 bean.xml 文件  * @author 黑马程序员  * @Company http://www.ithiema.com  * @Version 1.0  */ @Configuration @ComponentScan("com.itheima") public class SpringConfiguration { } 
  ```

  注意：  我们已经配置好了要扫描的包，但是数据源和 JdbcTemplate 对象如何从配置文件中移除呢？  请看下一个注解。 

  ##### 2.5.2.3 @Bean 

  作用：  该注解只能写在方法上，表明使用此方法创建一个对象，并且放入 spring 容器。 属性：  name：给当前@Bean 注解方法创建的对象指定一个名称(即 bean 的 id）。  示例代码： 


```java
/** 

- 连接数据库的配置类  * @author 黑马程序员  * @Company http://www.ithiema.com  * @Version 1.0  */ public class JdbcConfig { 

 /** 

- 创建一个数据源，并存入 spring 容器中   * @return   */  @Bean(name="dataSource")  public DataSource createDataSource() {   try {    ComboPooledDataSource ds = new ComboPooledDataSource();    ds.setUser("root");    ds.setPassword("1234");    ds.setDriverClass("com.mysql.jdbc.Driver"); 
  ds.setJdbcUrl("jdbc:mysql:///spring_day02");    return ds;   } catch (Exception e) {    throw new RuntimeException(e);   }  }  

 /** 
```


  * 创建一个 DBAssit，并且也存入 spring 容器中 

  ```java
    * @param dataSource   * @return   */  @Bean(name="dbAssit")  public DBAssit createDBAssit(DataSource dataSource) {   return new DBAssit(dataSource);  }  } 
  ```


  注意:  我们已经把数据源和 DBAssit 从配置文件中移除了，此时可以删除 bean.xml 了。  但是由于没有了配置文件，创建数据源的配置又都写死在类中了。如何把它们配置出来呢？  请看下一个注解。 

  

  ##### 2.5.2.4 @PropertySource 

  作用： 用于加载.properties 文件中的配置。例如我们配置数据源时，可以把连接数据库的信息写到 properties 配置文件中，就可以使用此注解指定 properties 配置文件的位置。 属性：  value[]：用于指定 properties 文件位置。如果是在类路径下，需要写上 classpath: 示例代码： 配置： /** 

 * 连接数据库的配置类  * @author 黑马程序员  * @Company http://www.ithiema.com  * @Version 1.0  */ public class JdbcConfig {  @Value("${jdbc.driver}")  private String driver;  @Value("${jdbc.url}")  private String url;  @Value("${jdbc.username}")  private String username;  @Value("${jdbc.password}")  private String password; 

 /** 
  * 创建一个数据源，并存入 spring 容器中 

  ```java
    * @return   */  @Bean(name="dataSource")  public DataSource 
  - createDataSource() {   try {    ComboPooledDataSource ds = new ComboPooledDataSource();    ds.setDriverClass(driver);    ds.setJdbcUrl(url);    ds.setUser(username);    ds.setPassword(password);    return ds;   } catch (Exception e) {    throw new RuntimeException(e);   }  }  
    } 
  
  jdbc.properties 文件：  jdbc.driver=com.mysql.jdbc.Driver  jdbc.url=jdbc:mysql://localhost:3306/day44_ee247_spring 
  
  
   jdbc.username=root 
   jdbc.password=1234 
  ```

  

注意：  此时我们已经有了两个配置类，但是他们还没有关系。如何建立他们的关系呢？  请看下一个注解。     

##### 2.5.2.5 @Import 

作用：  用于导入其他配置类，在引入其他配置类时，可以不用再写@Configuration 注解。当然，写上也没问 题。 属性：  value[]：用于指定其他配置类的字节码。 示例代码： @Configuration 

```java
@ComponentScan(basePackages = "com.itheima.spring") @Import({ JdbcConfig.class}) public class SpringConfiguration { } 
@Configuration @PropertySource("classpath:jdbc.properties") public class JdbcConfig{ } 
```


注意：  我们已经把要配置的都配置好了，但是新的问题产生了，由于没有配置文件了，如何获取容器呢？  请看下一小节。 
2.5.2.6 通过注解获取容器： 

```java
ApplicationContext ac = new AnnotationConfigApplicationContext(SpringConfiguration.class); 
```


2.5.3 工程结构图 



### 第3章 Spring 整合 Junit[掌握] 

#### 3.1 测试类中的问题和解决思路 

3.1.1 问题 
在测试类中，每个测试方法都有以下两行代码： 

```java
 ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");  IAccountService as = ac.getBean("accountService",IAccountService.class); 
```


这两行代码的作用是获取容器，如果不写的话，直接会提示空指针异常。所以又不能轻易删掉。 
3.1.2 解决思路分析 
针对上述问题，我们需要的是程序能自动帮我们创建容器。一旦程序能自动为我们创建 spring 容器，我们就 无须手动创建了，问题也就解决了。 我们都知道，junit 单元测试的原理（在 web 阶段课程中讲过），但显然，junit 是无法实现的，因为它自 己都无法知晓我们是否使用了 spring 框架，更不用说帮我们创建 spring 容器了。不过好在，junit 给我们暴露 了一个注解，可以让我们替换掉它的运行器。 这时，我们需要依靠 spring 框架，因为它提供了一个运行器，可以读取配置文件（或注解）来创建容器。我 们只需要告诉它配置文件在哪就行了。 
3.2 配置步骤 
3.2.1 第一步：拷贝整合 junit 的必备 jar 包到 lib 目录 
此处需要注意的是，导入 jar 包时，需要导入一个 spring 中 aop 的 jar 包。 



3.2.2 第二步：使用@RunWith 注解替换原有运行器 
```java
/** 

- 测试类  * @author 黑马程序员  * @Company http://www.ithiema.com  * @Version 1.0  */ @RunWith(SpringJUnit4ClassRunner.class) public class AccountServiceTest { } 
```

3.2.3 第三步：使用@ContextConfiguration 指定 spring 配置文件的位置 
```java
/** 

- 测试类  * @author 黑马程序员  * @Company http://www.ithiema.com  * @Version 1.0  */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations= {"classpath:bean.xml"}) public class AccountServiceTest { } 
```

 

##### @ContextConfiguration 注解：

  locations 属性：用于指定配置文件的位置。如果是类路径下，需要用 classpath:表明  classes 属性：用于指定注解的类。当不使用 xml 配置时，需要用此属性指定注解类的位置。 
3.2.4 第四步：使用@Autowired 给测试类中的变量注入数据 

```java
/** 

- 测试类  * @author 黑马程序员  * @Company http://www.ithiema.com  * @Version 1.0  */ @RunWith(SpringJUnit4ClassRunner.class) @ContextConfiguration(locations= {"classpath:bean.xml"}) public class AccountServiceTest {  
    @Autowired 
  private IAccountService as ; 
} 
```


#### 3.3 为什么不把测试类配到 xml 中 

在解释这个问题之前，先解除大家的疑虑，配到 XML 中能不能用呢？ 答案是肯定的，没问题，可以使用。 那么为什么不采用配置到 xml 中的方式呢？ 这个原因是这样的：  第一：当我们在 xml 中配置了一个 bean，spring 加载配置文件创建容器时，就会创建对象。  第二：测试类只是我们在测试功能时使用，而在项目中它并不参与程序逻辑，也不会解决需求上的问 题，所以创建完了，并没有使用。那么存在容器中就会造成资源的浪费。  所以，基于以上两点，我们不应该把测试配置到 xml 文件中。 

  



  

## 第2章 Spring中的 AOP[掌握] 

### 2.1 Spring中 AOP 的细节 

2.1.1 说明 
我们学习 spring 的 aop，就是通过配置的方式，实现上一章节的功能。

 

#### 2.1.2 AOP 相关术语 

Joinpoint(连接点):   所谓连接点是指那些被拦截到的点。在 spring 中,这些点指的是方法,因为 spring 只支持方法类型的 连接点。 Pointcut(切入点):   所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义。 


Advice(通知/增强):   所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知。   通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。 Introduction(引介):   引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方 法或 Field。 Target(目标对象):   代理的目标对象。 Weaving(织入):   是指把增强应用到目标对象来创建新的代理对象的过程。   spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。 Proxy（代理）:   一个类被 AOP 织入增强后，就产生一个结果代理类。 Aspect(切面):   是切入点和通知（引介）的结合。 
2.1.3 学习 spring 中的 AOP 要明确的事 
a、开发阶段（我们做的）  编写核心业务代码（开发主线）：大部分程序员来做，要求熟悉业务需求。  把公用代码抽取出来，制作成通知。（开发阶段最后再做）：AOP 编程人员来做。  在配置文件中，声明切入点与通知间的关系，即切面。：AOP 编程人员来做。 b、运行阶段（Spring框架完成的）  Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对 象的代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 
2.1.4 关于代理的选择 
 在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。 
2.2 基于 XML 的 AOP 配置 
示例：  我们在学习 spring 的 aop 时，采用账户转账作为示例。  并且把 spring 的 ioc 也一起应用进来。 

#### 2.2.1 环境搭建 

2.2.1.1 第一步：准备必要的代码 
此处包含了实体类，业务层和持久层代码。我们沿用上一章节中的代码即可。 


2.2.1.2 第二步：拷贝必备的 jar 包到工程的 lib 目录 
此处要拷贝 spring 的 ioc 和 aop 两组 jar 包 

2.2.1.3 第三步：创建 spring 的配置文件并导入约束 
此处要导入 aop 的约束

```xml
 <?xml version="1.0" encoding="UTF-8"?> 
<beans xmlns="http://www.springframework.org/schema/beans"        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
       xmlns:aop="http://www.springframework.org/schema/aop"        xsi:schemaLocation="http://www.springframework.org/schema/beans               http://www.springframework.org/schema/beans/spring-beans.xsd 
             http://www.springframework.org/schema/aop               http://www.springframework.org/schema/aop/spring-aop.xsd"> 
</beans> 
```


2.2.1.4 第四步：配置 spring 的 ioc 

```xml
<!-- 配置 service --> <bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"> 
 <property name="accountDao" ref="accountDao"></property> </bean> 

<!-- 配置 dao --> <bean id="accountDao" class="com.itheima.dao.impl.AccountDaoImpl"> 
<property name="dbAssit" ref="dbAssit"></property> 

</bean>   

<!-- 配置数据库操作对象 --> <bean id="dbAssit" class="com.itheima.dbassit.DBAssit"> 

 <property name="dataSource" ref="dataSource"></property> 

 <!-- 指定 connection 和线程绑定 -->  <property name="useCurrentConnection" value="true"></property> 

</bean>   

<!-- 配置数据源 --> <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">  <property name="driverClass" value="com.mysql.jdbc.Driver"></property>  <property name="jdbcUrl" value="jdbc:mysql:///spring_day02"></property> 

 <property name="user" value="root"></property>  <property name="password" value="1234"></property> </bean> 

```




2.2.1.5 第五步：抽取公共代码制作成通知 
```java
/** 

- 事务控制类  * @author 黑马程序员  * @Company http://www.ithiema.com  * @Version 1.0  */ public class TransactionManager {   
  //定义一个 DBAssit  private DBAssit dbAssit ; 

 public void setDbAssit(DBAssit dbAssit) {   this.dbAssit = dbAssit;  } 

 //开启事务  public void beginTransaction() {   try {    dbAssit.getCurrentConnection().setAutoCommit(false);   } catch (SQLException e) {    e.printStackTrace(); 
  }  } 
 //提交事务  public void commit() {   try {    dbAssit.getCurrentConnection().commit();   } catch (SQLException e) {    e.printStackTrace();   }  } 

 //回滚事务  public void rollback() {   try {    dbAssit.getCurrentConnection().rollback();   } catch (SQLException e) {    e.printStackTrace();   }  }   

 //释放资源  public void release() {   try {    dbAssit.releaseConnection();   } catch (Exception e) {    e.printStackTrace();   }  } } 

```





#### 2.2.2 配置步骤 

2.2.2.1 第一步：把通知类用 bean 标签配置起来 

```xml
<!-- 配置通知 --> 
 <bean id="txManager" class="com.itheima.utils.TransactionManager">  <property name="dbAssit" ref="dbAssit"></property> </bean>  
```


2.2.2.2 第二步：使用 aop:config 声明 aop 配置 
aop:config: 
 作用：用于声明开始 aop 的配置  <aop:config> 


 <!-- 配置的代码都写在此处 -->  </aop:config> 
2.2.2.3 第三步：使用 aop:aspect 配置切面 
aop:aspect: 
 作用：   用于配置切面。  属性：   id：给切面提供一个唯一标识。   ref：引用配置好的通知类 bean 的 id。 <aop:aspect id="txAdvice" ref="txManager"> 
  <!--配置通知的类型要写在此处--> </aop:aspect> 
2.2.2.4 第四步：使用 aop:pointcut 配置切入点表达式 
aop:pointcut：  作用：   用于配置切入点表达式。就是指定对哪些类的哪些方法进行增强。  属性：   expression：用于定义切入点表达式。   id：用于给切入点表达式提供一个唯一标识 

```xml
<aop:pointcut expression="execution(  public void com.itheima.service.impl.AccountServiceImpl.transfer(    java.lang.String, java.lang.String, java.lang.Float) )" id="pt1"/> 
```



##### 2.2.2.5 第五步：使用 aop:xxx 配置对应的通知类型 

###### aop:before   方法前启动

 作用：   用于配置前置通知。指定增强的方法在切入点方法之前执行   属性：   method:用于指定通知类中的增强方法名称   ponitcut-ref：用于指定切入点的表达式的引用   poinitcut：用于指定切入点表达式   执行时间点：   切入点方法执行之前执行 <aop:before method="beginTransaction" pointcut-ref="pt1"/> 

###### aop:after-returning   方法后启动



 作用：   用于配置后置通知  属性：   method：指定通知中方法的名称。   pointct：定义切入点表达式   pointcut-ref：指定切入点表达式的引用  执行时间点：   切入点方法正常执行之后。它和异常通知只能有一个执行 <aop:after-returning method="commit" pointcut-ref="pt1"/> 

###### aop:after-throwing  有异常时启动

 作用：   用于配置异常通知  属性：   method：指定通知中方法的名称。   pointct：定义切入点表达式   pointcut-ref：指定切入点表达式的引用  执行时间点：   切入点方法执行产生异常后执行。它和后置通知只能执行一个 <aop:after-throwing method="rollback" pointcut-ref="pt1"/>  

######    aop:after   最后启动

 作用：   用于配置最终通知  属性：   method：指定通知中方法的名称。   pointct：定义切入点表达式   pointcut-ref：指定切入点表达式的引用  执行时间点：   无论切入点方法执行时是否有异常，它都会在其后面执行。 <aop:after method="release" pointcut-ref="pt1"/> 
2.2.3 切入点表达式说明 
execution:匹配方法的执行(常用)  execution(表达式) 表达式语法：execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 写法说明：  全匹配方式：   public void com.itheima.service.impl.AccountServiceImpl.saveAccount(com.itheima.domain.Account) 
 访问修饰符可以省略    void 
com.itheima.service.impl.AccountServiceImpl.saveAccount(com.itheima.domain.Account) 


 返回值可以使用*号，表示任意返回值   * com.itheima.service.impl.AccountServiceImpl.saveAccount(com.itheima.domain.Account) 
 包名可以使用*号，表示任意包，但是有几级包，需要写几个*   * *.*.*.*.AccountServiceImpl.saveAccount(com.itheima.domain.Account) 
 使用..来表示当前包，及其子包   * com..AccountServiceImpl.saveAccount(com.itheima.domain.Account) 
 类名可以使用*号，表示任意类   * com..*.saveAccount(com.itheima.domain.Account) 
 方法名可以使用*号，表示任意方法   * com..*.*( com.itheima.domain.Account) 
 参数列表可以使用*，表示参数可以是任意数据类型，但是必须有参数   * com..*.*(*) 
 参数列表可以使用..表示有无参数均可，有参数可以是任意类型   * com..*.*(..) 
 全通配方式：   * *..*.*(..) 
注：  通常情况下，我们都是对业务层的方法进行增强，所以切入点表达式都是切到业务层实现类。  execution(* com.itheima.service.impl.*.*(..)) 

#### 2.2.4 环绕通知 

所有的通知（前置，后置，异常，最终）都执行一遍

配置方式:

```xml
 <aop:config> 
     <aop:pointcut expression="execution(* com.itheima.service.impl.*.*(..))" id="pt1"/>   <aop:aspect id="txAdvice" ref="txManager"> 
       <!-- 配置环绕通知 -->   <aop:around method="transactionAround" pointcut-ref="pt1"/> 

 /aop:aspect /aop:config 
```




###### aop:around   全部通知都启动

：  作用：   用于配置环绕通知  属性：   method：指定通知中方法的名称。   pointct：定义切入点表达式   pointcut-ref：指定切入点表达式的引用  说明：   它是 spring 框架为我们提供的一种可以在代码中手动控制增强代码什么时候执行的方式。  注意：   通常情况下，环绕通知都是独立使用的 


 * ```java
    /** 
    
    - 环绕通知  * @param pjp 
    - spring 框架为我们提供了一个接口：ProceedingJoinPoint，它可以作为环绕通知的方法参数。  *  在环绕通知执行时，spring 框架会为我们提供该接口的实现类对象，我们直接使用就行。  * @return  */ 
    public Object transactionAround(ProceedingJoinPoint pjp) { 
      //定义返回值  Object rtValue = null;  try {   //获取方法执行所需的参数   Object[] args = pjp.getArgs(); 
        //前置通知：开启事务   beginTransaction(); 
        //执行方法   rtValue = pjp.proceed(args); 
        //后置通知：提交事务   commit();  }catch(Throwable e) {   //异常通知：回滚事务   rollback();   e.printStackTrace();  }finally { 
        //最终通知：释放资源   release();  }  return rtValue; } 
    ```

    

### 2.3 基于注解的 AOP 配置 

#### 2.3.1 环境搭建 

2.3.1.1 第一步：准备必要的代码和 jar包 
拷贝上一小节的工程即可。  

2.3.1.2 第二步：在配置文件中导入 context 的名称空间 

```xml
<?xml version="1.0" encoding="UTF-8"?> <beans xmlns="http://www.springframework.org/schema/beans" 
 xmlns:aop="http://www.springframework.org/schema/aop"  xmlns:context="http://www.springframework.org/schema/context"     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"     xsi:schemaLocation="http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans.xsd         http://www.springframework.org/schema/aop         http://www.springframework.org/schema/aop/spring-aop.xsd 
        http://www.springframework.org/schema/context         http://www.springframework.org/schema/context/spring-context.xsd">
     <!-- 配置数据库操作对象 -->  <bean id="dbAssit" class="com.itheima.dbassit.DBAssit">   <property name="dataSource" ref="dataSource"></property> 

  <!-- 指定 connection 和线程绑定 -->  
    <property name="useCurrentConnection" value="true"></property> 
    </bean>   

 <!-- 配置数据源 -->  <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"> 

  <property name="driverClass" value="com.mysql.jdbc.Driver"></property>
    <property name="jdbcUrl" value="jdbc:mysql:///spring_day02"></property>  
    <property name="user" value="root"></property>
    <property name="password" value="1234"></property>  </bean> </beans> 

```


2.3.1.3 第三步：把资源使用注解配置 
```java
/** 

- 账户的业务层实现类  * @author 黑马程序员  * @Company http://www.ithiema.com  * @Version 1.0  */ 
  @Service("accountService") public class AccountServiceImpl implements IAccountService {     @Autowired  private IAccountDao accountDao; 

} 

/** 

- 账户的持久层实现类  * @author 黑马程序员  * @Company http://www.ithiema.com  * @Version 1.0  */ 
  @Repository("accountDao") public class AccountDaoImpl  implements IAccountDao { 

 @Autowired  private DBAssit dbAssit ; } 
```

2.3.1.4 第四步：在配置文件中指定 spring 要扫描的包 
```xml
<!-- 告知 spring，在创建容器时要扫描的包 --> <context:component-scan base-package="com.itheima"></context:component-scan>  
```


2.3.2 配置步骤 
2.3.2.1 第一步：把通知类也使用注解配置 
/** 
 * 事务控制类  * @author 黑马程序员  * @Company http://www.ithiema.com  * @Version 1.0  */ 
    @Component("txManager") public class TransactionManager { 
      //定义一个 DBAssit  @Autowired  private DBAssit dbAssit ;  } 
    2.3.2.2 第二步：在通知类上使用@Aspect 注解声明为切面 
    作用：  把当前类声明为切面类。 



/** 
 * 事务控制类  * @author 黑马程序员  * @Company http://www.ithiema.com  * @Version 1.0  */ @Component("txManager") 
    @Aspect//表明当前类是一个切面类 public class TransactionManager {   
      //定义一个 DBAssit  @Autowired  private DBAssit dbAssit ; } 
    2.3.2.3 第三步：在增强的方法上使用注解配置通知 

  ###### @Before 

   作用：   把当前方法看成是前置通知。  属性：   value：用于指定切入点表达式，还可以指定切入点表达式的引用。   

  ```java
   //开启事务  @Before("execution(* com.itheima.service.impl.*.*(..))") 
  public void beginTransaction() {  
      try {    dbAssit.getCurrentConnection().setAutoCommit(false);  
          } catch (SQLException e) {   
          e.printStackTrace();   } 
  } 
  ```

  

######  @AfterReturning 

 作用：   把当前方法看成是后置通知。  属性：   value：用于指定切入点表达式，还可以指定切入点表达式的引用 

```java
 //提交事务  @AfterReturning("execution(* com.itheima.service.impl.*.*(..))")  public void commit() { 

  try {    dbAssit.getCurrentConnection().commit();   } catch (SQLException e) {    e.printStackTrace();   } 
 }   
```



######  @AfterThrowing 

 作用：   把当前方法看成是异常通知。  属性：    value：用于指定切入点表达式，还可以指定切入点表达式的引用  //回滚事务  

```java
@AfterThrowing("execution(* com.itheima.service.impl.*.*(..))")  public void rollback() {   try {    dbAssit.getCurrentConnection().rollback();   } catch (SQLException e) {    e.printStackTrace();   }  } 
```



###### @After 

 作用：   把当前方法看成是最终通知。  属性：   value：用于指定切入点表达式，还可以指定切入点表达式的引用  

```java
//释放资源  @After("execution(* com.itheima.service.impl.*.*(..))")  public void release() {   try {    dbAssit.releaseConnection();   } catch (Exception e) {    e.printStackTrace();   }  } 
2.3.2.4 第四步：在 spring 配置文件中开启 spring 对注解 AOP 的支持 
<!-- 开启 spring 对注解 AOP 的支持 --> <aop:aspectj-autoproxy/> 
```




2.3.3 环绕通知注解配置 

###### @Around 

作用：  把当前方法看成是环绕通知。 属性：  value：用于指定切入点表达式，还可以指定切入点表达式的引用。 

  * ```java
      /** 
      
      - 环绕通知   * @param pjp   * @return   */  @Around("execution(* com.itheima.service.impl.*.*(..))")  public Object transactionAround(ProceedingJoinPoint pjp) { 
        //定义返回值   Object rtValue = null;   try { 
           //获取方法执行所需的参数    Object[] args = pjp.getArgs(); 
           //前置通知：开启事务    beginTransaction(); 
           //执行方法    rtValue = pjp.proceed(args); 
           //后置通知：提交事务    commit();   }catch(Throwable e) { 
           //异常通知：回滚事务    rollback();    e.printStackTrace();   }finally {    //最终通知：释放资源    release();   }   return rtValue;  } 
      ```

      

      ##### 2.3.4 切入点表达式注解 

      ###### @Pointcut 

      作用：  指定切入点表达式 属性： 
      

 value：指定表达式的内容 

@Pointcut("execution(* com.itheima.service.impl.*.*(..))") private void pt1() {} 

引用方式： 

```java
 /** 

- 环绕通知   * @param pjp   * @return   */ 
  @Around("pt1()")//注意：千万别忘了写括号 
public Object transactionAround(ProceedingJoinPoint pjp) {   //定义返回值 
Object rtValue = null; 
try { 
     //获取方法执行所需的参数   
Object[] args = pjp.getArgs(); 
     //前置通知：开启事务  
beginTransaction(); 
     //执行方法  
rtValue = pjp.proceed(args); 
     //后置通知：提交事务  
commit();   }catch(Throwable e) { 
     //异常通知：回滚事务  
    rollback();   
    e.printStackTrace(); 
}finally { 
	//最终通知：释放资源   
    release();  
} 
return rtValue;
} 
```


  * 2.3.5 不使用 XML的配置方式 

     ```java
     - @Configuration 
       @ComponentScan(basePackages="com.itheima") @EnableAspectJAutoProxy 
       public class SpringConfiguration { } 
     
      
     ```

     





# SpringMVC

## SpringMVC框架三层架构和MVC 

springMVC的优势

```txt
1、清晰的角色划分：  前端控制器（DispatcherServlet）->  请求到处理器映射（HandlerMapping）->  处理器适配器（HandlerAdapter）->  视图解析器（ViewResolver）->  处理器或页面控制器（Controller）->  验证器（ Validator） -> 命令对象（Command  请求参数绑定到的对象就叫命令对象）  表单对象（Form Object 提供给表单展示和提交到的对象就叫表单对象）。
2、分工明确，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要。 
3、由于命令对象就是一个 POJO，无需继承框架特定 API，可以使用命令对象直接作为业务对象。
4、和 Spring 其他框架无缝集成，是其它 Web 框架所不具备的。
5、可适配，通过 HandlerAdapter 可以支持任意的类作为处理器。
6、可定制性，HandlerMapping、ViewResolver 等能够非常简单的定制。
7、功能强大的数据验证、格式化、绑定机制。
8、利用 Spring 提供的 Mock 对象能够非常简单的进行 Web 层单元测试。
9、本地化、主题的解析的支持，使我们更容易进行国际化和主题的切换。
10、强大的 JSP 标签库，使 JSP 编写更容易。 
```

![1564296307069](C:\Users\lenovo\AppData\Local\Temp\1564296307069.png)

dispatcherServlet前端核心控制器

我们平时的controller方法就是所谓的后端控制器，只是一般不这么叫

springmvc在三层架构中的位置

![1564054655726](C:\Users\lenovo\AppData\Local\Temp\1564054655726.png)



1. 三层架构 
2. 咱们开发服务器端程序，一般都基于两种形式，一种C/S架构程序，一种B/S架构程序 2. 使用Java语言基本上都是开发B/S架构的程序，B/S架构又分成了三层架构 3. 三层架构 1. 表现层：WEB层，用来和客户端进行数据交互的。表现层一般会采用MVC的设计模型 2. 业务层：处理公司具体的业务逻辑的 3. 持久层：用来操作数据库的 2. MVC模型 
3. MVC全名是Model View Controller 模型视图控制器，每个部分各司其职。 2. Model：数据模型，JavaBean的类，用来进行数据封装。 3. View：指JSP、HTML用来展示数据给用户 4. Controller：用来接收用户的请求，整个流程的控制器。用来进行数据校验等。 第二章：SpringMVC的入门案例 
4. SpringMVC的概述（查看大纲文档） 
5. SpringMVC的概述 1. 是一种基于Java实现的MVC设计模型的请求驱动类型的轻量级WEB框架。 2. Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。Spring 框架提供 了构建 Web 应用程序的全功能 MVC 模块。 3. 使用 Spring 可插入的 MVC 架构，从而在使用Spring进行WEB开发时，可以选择使用Spring的 SpringMVC框架或集成其他MVC开发框架，如Struts1(现在一般不用)，Struts2等。 2. SpringMVC在三层架构中的位置 1. 表现层框架 3. SpringMVC的优势 4. SpringMVC和Struts2框架的对比 2. SpringMVC的入门程序 
6. 创建WEB工程，引入开发的jar包 1. 具体的坐标如下


2. 配置核心的控制器（配置DispatcherServlet） 1. 在web.xml配置文件中核心控制器DispatcherServlet


```xml
<!-- 版本锁定 -->    <properties>        <spring.version>5.0.2.RELEASE</spring.version>    </properties>
 
<dependencies>        <dependency>            <groupId>org.springframework</groupId>            <artifactId>spring-context</artifactId>            <version>${spring.version}</version>        </dependency>
 
    <dependency>            <groupId>org.springframework</groupId>            <artifactId>spring-web</artifactId>            <version>${spring.version}</version>        </dependency>
 
    <dependency>            <groupId>org.springframework</groupId>            <artifactId>spring-webmvc</artifactId>            <version>${spring.version}</version>        </dependency>
 
    <dependency>            <groupId>javax.servlet</groupId>            <artifactId>servlet-api</artifactId>            <version>2.5</version>            <scope>provided</scope>        </dependency>
 
    <dependency>            <groupId>javax.servlet.jsp</groupId>            <artifactId>jsp-api</artifactId>            <version>2.0</version>            <scope>provided</scope>        </dependency>    </dependencies>
 
<!-- SpringMVC的核心控制器 -->    <servlet>        <servlet-name>dispatcherServlet</servlet-name>        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servletclass>        <!-- 配置Servlet的初始化参数，读取springmvc的配置文件，创建spring容器 -->
    <init-param>
```
3. 编写springmvc.xml的配置文件

4. 编写index.jsp和HelloController控制器类 1. index.jsp

           <param-name>contextConfigLocation</param-name>            <param-value>classpath:springmvc.xml</param-value>        </init-param>        <!-- 配置servlet启动时加载对象 -->        <load-on-startup>1</load-on-startup>    </servlet>    <servlet-mapping>        <servlet-name>dispatcherServlet</servlet-name>        <url-pattern>/</url-pattern>    </servlet-mapping>
      ```xml
      1. <?xml version="1.0" encoding="UTF-8"?> <beans xmlns="http://www.springframework.org/schema/beans"    xmlns:mvc="http://www.springframework.org/schema/mvc"    xmlns:context="http://www.springframework.org/schema/context"    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    xsi:schemaLocation="        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd">    
          <!-- 配置spring创建容器时要扫描的包 -->   
          <context:component-scan base-package="com.itheima"></context:component-scan>           <!-- 配置视图解析器 -->  
          <bean id="viewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">    
              <property name="prefix" value="/WEB-INF/pages/"></property>  
              <property name="suffix" value=".jsp"></property>  
          </bean>     
          <!-- 配置spring开启注解mvc的支持   
        <mvc:annotation-driven></mvc:annotation-driven>--> 
      </beans>
         <body>      
             <h3>入门案例</h3>      
             <a href="${ pageContext.request.contextPath }/hello">入门案例</a>
      
      </body>
      ```

      

2. HelloController

3. 在WEB-INF目录下创建pages文件夹，编写success.jsp的成功页面

4. 启动Tomcat服务器，进行测试
  5. 入门案例的执行过程分析 
6. 入门案例的执行流程 1. 当启动Tomcat服务器的时候，因为配置了load-on-startup标签，所以会创建DispatcherServlet对象， 就会加载springmvc.xml配置文件 2. 开启了注解扫描，那么HelloController对象就会被创建 3. 从index.jsp发送请求，请求会先到达DispatcherServlet核心控制器，根据配置@RequestMapping注解 找到执行的具体方法 4. 根据执行方法的返回值，再根据配置的视图解析器，去指定的目录下查找指定名称的JSP文件 5. Tomcat服务器渲染页面，做出响应 2. SpringMVC官方提供图形

  ```java
  1. package cn.itcast.controller;
  
  import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping;
  
  /** * 控制器 * @author rt */ @Controller public class HelloController {        /**     * 接收请求     * @return     */    @RequestMapping(path="/hello")    public String sayHello() {        System.out.println("Hello SpringMVC!!");        return "success";    }
  
  }
  ```

  



```html
<body>
<h3>入门成功！！</h3>
</body>
```


3. 入门案例中的组件分析

    1.前端控制器（DispatcherServlet）

    2.处理器映射器（HandlerMapping）

    3.处理器（Handler）

    4.处理器适配器（HandlAdapter） 

    5.视图解析器（View Resolver）

    6.视图（View）

    

    

    

    

    RequestMapping注解 

4. RequestMapping注解的作用是建立请求URL和处理方法之间的对应关系 2. RequestMapping注解可以作用在方法和类上 1. 作用在类上：第一级的访问目录 2. 作用在方法上：第二级的访问目录 3. 细节：路径可以不编写 / 表示应用的根目录开始 4. 细节：${ pageContext.request.contextPath }也可以省略不写，但是路径上不能写 / 3. RequestMapping的属性 1. path 指定请求路径的url 2. value       value属性和path属性是一样的 3. mthod     指定该方法的请求方式 4. params   指定限制请求参数的条件 5. headers  发送的请求中必须包含的请求头
    第三章：请求参数的绑定 

5. 请求参数的绑定说明 1. 绑定机制 1. 表单提交的数据都是k=v格式的 username=haha&password=123 2. SpringMVC的参数绑定过程是把表单提交的请求参数，作为控制器中方法的参数进行绑定的 3. 要求：提交表单的name和参数的名称是相同的 2. 支持的数据类型 1. 基本数据类型和字符串类型 2. 实体类型（JavaBean） 3. 集合数据类型（List、map集合等） 2. 基本数据类型和字符串类型 1. 提交表单的name和参数的名称是相同的 2. 区分大小写 3. 实体类型（JavaBean） 1. 提交表单的name和JavaBean中的属性名称需要一致 2. 如果一个JavaBean类中包含其他的引用类型，那么表单的name属性需要编写成：对象.属性 例如： address.name 4. 给集合属性数据封装

6. JSP页面编写方式：list[0].属性 5. 请求参数中文乱码的解决 1. 在web.xml中配置Spring提供的过滤器类

7. 自定义类型转换器 1. 表单提交的任何数据类型全部都是字符串类型，但是后台定义Integer类型，数据也可以封装上，说明 Spring框架内部会默认进行数据类型转换。 2. 如果想自定义数据类型转换，可以实现Converter的接口 1. 自定义类型转换器


    <!-- 配置过滤器，解决中文乱码的问题 -->    <filter>        <filter-name>characterEncodingFilter</filter-name>        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filterclass>        <!-- 指定字符集 -->        <init-param>            <param-name>encoding</param-name>            <param-value>UTF-8</param-value>        </init-param>    </filter>    <filter-mapping>        <filter-name>characterEncodingFilter</filter-name>        <url-pattern>/*</url-pattern>    </filter-mapping>


```java
package cn.itcast.utils;

import java.text.DateFormat; import java.text.SimpleDateFormat; import java.util.Date;

import org.springframework.core.convert.converter.Converter;

/** * 把字符串转换成日期的转换器 * @author rt */ public class StringToDateConverter implements Converter<String, Date>{

/**     * 进行类型转换的方法     */   
    public Date convert(String source) {    
        // 判断    
        if(source == null) {            throw new RuntimeException("参数不能为空");
    }
```
2. 注册自定义类型转换器，在springmvc.xml配置文件中编写配置

3. 在控制器中使用原生的ServletAPI对象 1. 只需要在控制器的方法参数定义HttpServletRequest和HttpServletResponse对象 

   

   

   

   

   

   

   第四章：常用的注解 

4. **RequestParam注解** 1. 作用：把请求中的指定名称的参数传递给控制器中的形参赋值 2. 属性 1. value：请求参数中的名称 2. required：请求参数中是否必须提供此参数，默认值是true，必须提供 3. 代码如下

   ```java
   try {       
   DateFormat df = new SimpleDateFormat("yyyy-MM-dd");            // 解析字符串    
       Date date = df.parse(source);      
       return date;      
   } catch (Exception e) {   
       throw new RuntimeException("类型转换错误");   
   
   }    }
   
   }
   ```

   


```xml
<!-- 注册自定义类型转换器 -->    <bean id="conversionService" class="org.springframework.context.support.ConversionServiceFactoryBean">        <property name="converters">            <set>                <bean class="cn.itcast.utils.StringToDateConverter"/>            </set>        </property>    </bean>        <!-- 开启Spring对MVC注解的支持 -->    <mvc:annotation-driven conversion-service="conversionService"/>    
```

 

2. **RequestBody注解** 1. 作用：用于获取请求体的内容（注意：get方法不可以） 2. 属性 1. required：是否必须有请求体，默认值是true 3. 代码如下

3. **PathVariable注解** 1. 作用：拥有绑定url中的占位符的。例如：url中有/delete/{id}，{id}就是占位符 2. 属性 1. value：指定url中的占位符名称 3. Restful风格的URL 1. 请求路径一样，可以根据不同的请求方式去执行后台的不同方法 2. restful风格的URL优点 1. 结构清晰 2. 符合标准 3. 易于理解 4. 扩展方便 4. 代码如下

    ```java
    /**     * 接收请求     * @return     */    @RequestMapping(path="/hello")    public String sayHello(@RequestParam(value="username",required=false)String name) {        System.out.println("aaaa");        System.out.println(name);        return "success";    }
    /**     * 接收请求     * @return     */    @RequestMapping(path="/hello")    public String sayHello(@RequestBody String body) {        System.out.println("aaaa");        System.out.println(body);        return "success";    }
    ```

    


4. **RequestHeader注解** 1. 作用：获取指定请求头的值 2. 属性 1. value：请求头的名称 3. 代码如下

5. **CookieValue注解** 1. 作用：用于获取指定cookie的名称的值 2. 属性 1. value：cookie的名称 3. 代码

6. **ModelAttribute注解** 1. 作用 1. 出现在方法上：表示当前方法会在控制器方法执行前线执行。 2. 出现在参数上：获取指定的数据给参数赋值。 2. 应用场景 1. 当提交表单数据不是完整的实体数据时，保证没有提交的字段使用数据库原来的数据。 3. 具体的代码
    <a href="user/hello/1">入门案例</a>     

    ```java
       /**     * 接收请求     * @return     */    @RequestMapping(path="/hello/{id}")    public String sayHello(@PathVariable(value="id") String id) {        System.out.println(id);        return "success";    }   
    @RequestMapping(path="/hello")    public String sayHello(@RequestHeader(value="Accept") String header) {        System.out.println(header);        return "success";    }
    @RequestMapping(path="/hello")    public String sayHello(@CookieValue(value="JSESSIONID") String cookieValue) {        System.out.println(cookieValue);        return "success";    }
    ```

    

7. 修饰的方法有返回值

8. 修饰的方法没有返回值

    ```java
    /**     * 作用在方法，先执行     * @param name     * @return     */    @ModelAttribute   
    public User showUser(String name) {        System.out.println("showUser执行了...");  
                                       // 模拟从数据库中查询对象       
                                       User user = new User();        user.setName("哈哈");        user.setPassword("123");        user.setMoney(100d);        return user;    }       
    /**     * 修改用户的方法     * @param cookieValue     * @return     */  
    @RequestMapping(path="/updateUser") 
    public String updateUser(User user) {        System.out.println(user);    
       return "success";    }
    /**     * 作用在方法，先执行     * @param name     * @return     */    @ModelAttribute 
    public void showUser(String name,Map<String, User> map) {        System.out.println("showUser执行了...");        // 模拟从数据库中查询对象     
                                                             User user = new User();        user.setName("哈哈");        user.setPassword("123");        user.setMoney(100d);        map.put("abc", user);    }        /**     * 修改用户的方法     * @param cookieValue     * @return     */
     @RequestMapping(path="/updateUser")    public String updateUser(@ModelAttribute(value="abc") User user) {        System.out.println(user);        return "success";    }
    
    ```

    

9. SessionAttributes注解 1. 作用：用于多次执行控制器方法间的参数共享 2. 属性 1. value：指定存入属性的名称 3. 代码如下

    ```java
    @RequestMapping(path="/updateUser")    public String updateUser(@ModelAttribute(value="abc") User user) {        System.out.println(user);        return "success";    }
    @Controller @RequestMapping(path="/user") @SessionAttributes(value= {"username","password","age"},types= {String.class,Integer.class})        // 把数据存入到session域对象中 public class HelloController {        /**     * 向session中存入值     * @return     */    @RequestMapping(path="/save")    public String save(Model model) {        System.out.println("向session域中保存数据");        model.addAttribute("username", "root");        model.addAttribute("password", "123");        model.addAttribute("age", 20);        return "success";    }        /**     * 从session中获取值     * @return     */    @RequestMapping(path="/find")    public String find(ModelMap modelMap) {        String username = (String) modelMap.get("username");        String password = (String) modelMap.get("password");        Integer age = (Integer) modelMap.get("age");        System.out.println(username + " : "+password +" : "+age);        return "success";    }        /**     * 清除值     * @return     */    @RequestMapping(path="/delete")
    public String delete(SessionStatus status) {
           status.setComplete();   
        return "success";    }
     
    }
    ```

    

 课程总结 
1. SpringMVC的概述 2. 入门 1. 创建工程，导入坐标 2. 在web.xml中配置前端控制器（启动服务器，加载springmvc.xml配置文件） 3. 编写springmvc.xml配置文件 4. 编写index.jsp的页面，发送请求 5. 编写Controller类，编写方法（@RequestMapping(path="/hello")），处理请求 6. 编写配置文件（开启注解扫描），配置视图解析器 7. 执行的流程 8. @RequestMapping注解 1. path 2. value 3. method 4. .... 3. 参数绑定 1. 参数绑定必须会 2. 解决中文乱码，配置过滤器 3. 自定义数据类型转换器







## SpringMVC响应数据和结果视图 

1. 返回值分类 

2. 返回字符串 1. Controller方法返回字符串可以指定逻辑视图的名称，根据视图解析器为物理视图的地址。

3. 具体的应用场景

    ```java
    @RequestMapping(value="/hello")    public String sayHello() {        System.out.println("Hello SpringMVC!!");        // 跳转到XX页面        return "success";    }
    @Controller @RequestMapping("/user") public class UserController {        /**     * 请求参数的绑定     */    @RequestMapping(value="/initUpdate")    public String initUpdate(Model model) {        // 模拟从数据库中查询的数据        User user = new User();        user.setUsername("张三");        user.setPassword("123");        user.setMoney(100d);        user.setBirthday(new Date());        model.addAttribute("user", user);        return "update";    }    }
    ```

    ```html
    <h3>修改用户</h3>    $[Math Processing Error]{ requestScope }    <form action="user/update" method="post">        姓名：<input type="text" name="username" value="${ user.username }"><br>        密码：<input type="text" name="password" value="${ user.password }"><br>        金额：<input type="text" name="money" value="${ user.money }"><br>        <input type="submit" value="提交">
    </form>
    ```

    

4. 返回值是void 1. 如果控制器的方法返回值编写成void，执行程序报404的异常，默认查找JSP页面没有找到。 1. 默认会跳转到@RequestMapping(value="/initUpdate") initUpdate的页面。 2. 可以使用请求转发或者重定向跳转到指定的页面

5. 返回值是ModelAndView对象 1. ModelAndView对象是Spring提供的一个对象，可以用来调整具体的JSP视图 2. 具体的代码如下

```java
@RequestMapping(value="/initAdd")    public void initAdd(HttpServletRequest request,HttpServletResponse response) throws Exception {        System.out.println("请求转发或者重定向");        // 请求转发        // request.getRequestDispatcher("/WEB-INF/pages/add.jsp").forward(request, response);        // 重定向        // response.sendRedirect(request.getContextPath()+"/add2.jsp");                response.setCharacterEncoding("UTF-8");        response.setContentType("text/html;charset=UTF-8");                // 直接响应数据        response.getWriter().print("你好");        return;    }
    /**     * 返回ModelAndView对象     * 可以传入视图的名称（即跳转的页面），还可以传入对象。     * @return     * @throws Exception     */    @RequestMapping(value="/findAll")    public ModelAndView findAll() throws Exception {        ModelAndView mv = new ModelAndView();        // 跳转到list.jsp的页面        mv.setViewName("list");                // 模拟从数据库中查询所有的用户信息        List<User> users = new ArrayList<>();        User user1 = new User();        user1.setUsername("张三");        user1.setPassword("123");                User user2 = new User();        user2.setUsername("赵四");        user2.setPassword("456");
```


2. SpringMVC框架提供的转发和重定向 
3. forward请求转发 1. controller方法返回String类型，想进行请求转发也可以编写成


2. redirect重定向

      ```java
           users.add(user1);     
      users.add(user2);     
      // 添加对象    
      mv.addObject("users", users);   
      return mv;    }  
      ```

         

```html
   <%@ page language="java" contentType="text/html; charset=UTF-8"    pageEncoding="UTF-8"%>        <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>    <!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <title>Insert title here</title> </head> <body>
<h3>查询所有的数据</h3>    <c:forEach items="${ users }" var="user">        ${ user.username }    </c:forEach>
       </body> </html>
```

```java
    /**     * 使用forward关键字进行请求转发     * "forward:转发的JSP路径"，不走视图解析器了，所以需要编写完整的路径     * @return     * @throws Exception     */    @RequestMapping("/delete")    public String delete() throws Exception {        System.out.println("delete方法执行了...");        // return "forward:/WEB-INF/pages/success.jsp";        return "forward:/user/findAll";    }
```


1. controller方法返回String类型，想进行重定向也可以编写成

2. ResponseBody响应json数据 

3. DispatcherServlet会拦截到所有的资源，导致一个问题就是静态资源（img、css、js）也会被拦截到，从而 不能被使用。解决问题就是需要配置静态资源不进行拦截，在springmvc.xml配置文件添加如下配置 1. mvc:resources标签配置不过滤 1. location元素表示webapp目录下的包下的所有文件 2. mapping元素表示以/static开头的所有请求路径，如/static/a 或者/static/a/b

4. 使用@RequestBody获取请求体数据

    ```java
    /**     * 重定向     * @return     * @throws Exception     */    @RequestMapping("/count")    public String count() throws Exception {        System.out.println("count方法执行了...");        return "redirect:/add.jsp";        // return "redirect:/user/findAll";    }
    ```

    ```js
    <!-- 设置静态资源不过滤 -->    <mvc:resources location="/css/" mapping="/css/**"/>  <!-- 样式 -->    <mvc:resources location="/images/" mapping="/images/**"/>  <!-- 图片 -->    <mvc:resources location="/js/" mapping="/js/**"/>  <!-- javascript -->
    // 页面加载 
    // 页面加载   
    $(function(){    
        // 绑定点击事件    
        $("#btn").click(function(){    
            $.ajax({       
                url:"user/testJson",                contentType:"application/json;charset=UTF-8",                data:'{"addressName":"aa","addressNum":100}',                dataType:"json",         
                type:"post",                success:function(data){     
                    alert(data);           
                alert(data.addressName);    
                }      
            });  
        });  
    });    
    /**
    ```

    

5. 使用@RequestBody注解把json的字符串转换成JavaBean的对象


4. 使用@ResponseBody注解把JavaBean对象转换成json字符串，直接响应 1. 要求方法需要返回JavaBean的对象

     * 获取请求体的数据     * @param body     */    @RequestMapping("/testJson")    public void testJson(@RequestBody String body) {        System.out.println(body);    }
```java
// 页面加载    // 页面加载    $(function(){        // 绑定点击事件        $("#btn").click(function(){            $.ajax({                url:"user/testJson",                contentType:"application/json;charset=UTF-8",                data:'{"addressName":"aa","addressNum":100}',                dataType:"json",                type:"post",                success:function(data){                    alert(data);                    alert(data.addressName);                }            });        });    });        /**     * 获取请求体的数据     * @param body     */    @RequestMapping("/testJson")    public void testJson(@RequestBody Address address) {        System.out.println(address);    }
```
```js
// 页面加载   
$(function(){  
// 绑定点击事件   
    $("#btn").click(function(){       
        $.ajax({url:"user/testJson",       contentType:"application/json;charset=UTF-8",
                data:'{"addressName":"哈","addressNum":100}',
```



  5. json字符串和JavaBean对象互相转换的过程中，需要使用jackson的jar包

  第二章：SpringMVC实现文件上传 
1. 文件上传的回顾 
2. 导入文件上传的jar包

      ```java
           dataType:"json",     
      type:"post",           
      success:function(data){      
          alert(data);                    alert(data.addressName);    
      }        
      });     
      });  
      });     
      @RequestMapping("/testJson")  
      public @ResponseBody Address testJson(@RequestBody Address address) {   
          System.out.println(address);        address.setAddressName("上海");   
          return address;    }
      ```

      
```pom
<dependency>            <groupId>com.fasterxml.jackson.core</groupId>            <artifactId>jackson-databind</artifactId>            <version>2.9.0</version>        </dependency>        <dependency>            <groupId>com.fasterxml.jackson.core</groupId>            <artifactId>jackson-core</artifactId>            <version>2.9.0</version>        </dependency>        <dependency>            <groupId>com.fasterxml.jackson.core</groupId>            <artifactId>jackson-annotations</artifactId>            <version>2.9.0</version>        </dependency>
```

 



2. 编写文件上传的JSP页面


3. 编写文件上传的Controller控制器

    ```pom
    <dependency>            <groupId>commons-fileupload</groupId>            <artifactId>commons-fileupload</artifactId>            <version>1.3.1</version>        </dependency>        <dependency>            <groupId>commons-io</groupId>            <artifactId>commons-io</artifactId>            <version>2.4</version>        </dependency>
    ```

    ```html
    <h3>文件上传</h3>        <form action="user/fileupload" method="post" enctype="multipart/form-data">        选择文件：<input type="file" name="upload"/><br/>        <input type="submit" value="上传文件"/>    </form>
    ```

    ```java
    /**     * 文件上传     * @throws Exception      */    @RequestMapping(value="/fileupload")    public String fileupload(HttpServletRequest request) throws Exception {        // 先获取到要上传的文件目录        String path = request.getSession().getServletContext().getRealPath("/uploads");        // 创建File对象，一会向该路径下上传文件        File file = new File(path);        // 判断路径是否存在，如果不存在，创建该路径        if(!file.exists()) {            file.mkdirs();        }        // 创建磁盘文件项工厂        DiskFileItemFactory factory = new DiskFileItemFactory();        ServletFileUpload fileUpload = new ServletFileUpload(factory);        // 解析request对象        List<FileItem> list = fileUpload.parseRequest(request);        // 遍历        for (FileItem fileItem : list) {            // 判断文件项是普通字段，还是上传的文件            if(fileItem.isFormField()) {                            }else {                // 上传文件项
    ```

    

 4. SpringMVC传统方式文件上传 

5. SpringMVC框架提供了MultipartFile对象，该对象表示上传的文件，要求变量名称必须和表单ﬁle标签的 name属性名称相同。 2. 代码如下

6. 配置文件解析器对象
        
       // 获取到上传文件的名称                String filename = fileItem.getName();                // 上传文件                fileItem.write(new File(file, filename));                // 删除临时文件                fileItem.delete();            }        }                return "success";    }
    /**     * SpringMVC方式的文件上传     *      * @param request     * @return     * @throws Exception     */    @RequestMapping(value="/fileupload2")    public String fileupload2(HttpServletRequest request,MultipartFile upload) throws Exception {        System.out.println("SpringMVC方式的文件上传...");        // 先获取到要上传的文件目录        String path = request.getSession().getServletContext().getRealPath("/uploads");        // 创建File对象，一会向该路径下上传文件        File file = new File(path);        // 判断路径是否存在，如果不存在，创建该路径        if(!file.exists()) {            file.mkdirs();        }        // 获取到上传文件的名称        String filename = upload.getOriginalFilename();        String uuid = UUID.randomUUID().toString().replaceAll("-", "").toUpperCase();        // 把文件的名称唯一化        filename = uuid+"_"+filename;        // 上传文件        upload.transferTo(new File(file,filename));        return "success";    }

 



3. SpringMVC跨服务器方式文件上传 
4. 搭建图片服务器 1. 根据文档配置tomcat9的服务器，现在是2个服务器 2. 导入资料中day02_springmvc5_02image项目，作为图片服务器使用 2. 实现SpringMVC跨服务器方式文件上传 1. 导入开发需要的jar包

5. 编写文件上传的JSP页面


3. 编写控制器

```xml
<!-- 配置文件解析器对象，要求id名称必须是multipartResolver -->    <bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver">        <property name="maxUploadSize" value="10485760"/>    </bean>
```


​     

```pom
   <dependency>            <groupId>com.sun.jersey</groupId>            <artifactId>jersey-core</artifactId>            <version>1.18.1</version>        </dependency>        <dependency>            <groupId>com.sun.jersey</groupId>            <artifactId>jersey-client</artifactId>            <version>1.18.1</version>        </dependency>
```

```html
<h3>跨服务器的文件上传</h3>        <form action="user/fileupload3" method="post" enctype="multipart/form-data">        选择文件：<input type="file" name="upload"/><br/>        <input type="submit" value="上传文件"/>    </form>
```

```

    /**     * SpringMVC跨服务器方式的文件上传     *      * @param request     * @return     * @throws Exception     */
    @RequestMapping(value="/fileupload3")
```


第三章：SpringMVC的异常处理 
1. 异常处理思路 
2. Controller调用service，service调用dao，异常都是向上抛出的，最终有DispatcherServlet找异常处理器进 行异常的处理。 2. SpringMVC的异常处理 
3. 自定义异常类

    public String fileupload3(MultipartFile upload) throws Exception {        System.out.println("SpringMVC跨服务器方式的文件上传...");                // 定义图片服务器的请求路径        String path = "http://localhost:9090/day02_springmvc5_02image/uploads/";                // 获取到上传文件的名称        String filename = upload.getOriginalFilename();        String uuid = UUID.randomUUID().toString().replaceAll("-", "").toUpperCase();        // 把文件的名称唯一化        filename = uuid+"_"+filename;        // 向图片服务器上传文件                // 创建客户端对象        Client client = Client.create();        // 连接图片服务器        WebResource webResource = client.resource(path+filename);        // 上传文件        webResource.put(upload.getBytes());        return "success";    }
    package cn.itcast.exception;

public class SysException extends Exception{

    private static final long serialVersionUID = 4055945147128016300L;        // 异常提示信息    private String message;    public String getMessage() {        return message;    }    public void setMessage(String message) {        this.message = message;    }    public SysException(String message) {        this.message = message;    }
    }


  2. 自定义异常处理器


3. 配置异常处理器





```java
package cn.itcast.exception;

import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;

import org.springframework.web.servlet.HandlerExceptionResolver; import org.springframework.web.servlet.ModelAndView;

/** * 异常处理器 * @author rt */ public class SysExceptionResolver implements HandlerExceptionResolver{

/**     * 跳转到具体的错误页面的方法     */    public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler,            Exception ex) {        ex.printStackTrace();        SysException e = null;        // 获取到异常对象        if(ex instanceof SysException) {            e = (SysException) ex;        }else {            e = new SysException("请联系管理员");        }        ModelAndView mv = new ModelAndView();        // 存入错误的提示信息        mv.addObject("message", e.getMessage());        // 跳转的Jsp页面        mv.setViewName("error");        return mv;    }
}

<!-- 配置异常处理器 --> <bean id="sysExceptionResolver" class="cn.itcast.exception.SysExceptionResolver"/>

```




  第四章：SpringMVC框架中的拦截器 
1. 拦截器的概述 
2. SpringMVC框架中的拦截器用于对处理器进行预处理和后处理的技术。 2. 可以定义拦截器链，连接器链就是将拦截器按着一定的顺序结成一条链，在访问被拦截的方法时，拦截器链 中的拦截器会按着定义的顺序执行。 3. 拦截器和过滤器的功能比较类似，有区别 1. 过滤器是Servlet规范的一部分，任何框架都可以使用过滤器技术。 2. 拦截器是SpringMVC框架独有的。 3. 过滤器配置了/*，可以拦截任何资源。 4. 拦截器只会对控制器中的方法进行拦截。 4. 拦截器也是AOP思想的一种实现方式 5. 想要自定义拦截器，需要实现HandlerInterceptor接口。 2. 自定义拦截器步骤 
3. 创建类，实现HandlerInterceptor接口，重写需要的方法

```java
package cn.itcast.demo1;
import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;

import org.springframework.web.servlet.HandlerInterceptor;

/** * 自定义拦截器1 * @author rt */ public class MyInterceptor1 implements HandlerInterceptor{

/**     * controller方法执行前，进行拦截的方法     * return true放行     * return false拦截     * 可以使用转发或者重定向直接跳转到指定的页面。     */    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)            throws Exception {        System.out.println("拦截器执行了...");        return true;    }
    }
```



  2. 在springmvc.xml中配置拦截器类

   3. HandlerInterceptor接口中的方法 
 4. preHandle方法是controller方法执行前拦截的方法 1. 可以使用request或者response跳转到指定的页面 2. return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法。 3. return false不放行，不会执行controller中的方法。 2. postHandle是controller方法执行后执行的方法，在JSP视图执行前。 1. 可以使用request或者response跳转到指定的页面 2. 如果指定了跳转的页面，那么controller方法跳转的页面将不会显示。 3. postHandle方法是在JSP执行后执行 1. request或者response不能再跳转页面了
   5. 配置多个拦截器 
 6. 再编写一个拦截器的类 2. 配置2个拦截器


```xml
<!-- 配置拦截器 -->    <mvc:interceptors>        <mvc:interceptor>            <!-- 哪些方法进行拦截 -->            <mvc:mapping path="/user/*"/>            <!-- 哪些方法不进行拦截             <mvc:exclude-mapping path=""/>            -->            <!-- 注册拦截器对象 -->            <bean class="cn.itcast.demo1.MyInterceptor1"/>        </mvc:interceptor>    </mvc:interceptors>
 
<!-- 配置拦截器 -->    <mvc:interceptors>        <mvc:interceptor>            <!-- 哪些方法进行拦截 -->            <mvc:mapping path="/user/*"/>            <!-- 哪些方法不进行拦截             <mvc:exclude-mapping path=""/>            -->
            <!-- 注册拦截器对象 -->            <bean class="cn.itcast.demo1.MyInterceptor1"/>        </mvc:interceptor>                <mvc:interceptor>            <!-- 哪些方法进行拦截 -->            <mvc:mapping path="/**"/>            <!-- 注册拦截器对象 -->            <bean class="cn.itcast.demo1.MyInterceptor2"/>        </mvc:interceptor>    </mvc:interceptors>
```

 

     

    

SpringMVC第三天 第一章：搭建整合环境 

1. 搭建整合环境 
2. 整合说明：SSM整合可以使用多种方式，咱们会选择XML + 注解的方式 2. 整合的思路 1. 先搭建整合的环境 2. 先把Spring的配置搭建完成 3. 再使用Spring整合SpringMVC框架 4. 最后使用Spring整合MyBatis框架 3. 创建数据库和表结构 1. 语句

3. 创建maven的工程（今天会使用到工程的聚合和拆分的概念，这个技术maven高级会讲） 1. 创建ssm_parent父工程（打包方式选择pom，必须的） 2. 创建ssm_web子模块（打包方式是war包） 3. 创建ssm_service子模块（打包方式是jar包） 4. 创建ssm_dao子模块（打包方式是jar包） 5. 创建ssm_domain子模块（打包方式是jar包） 6. web依赖于service，service依赖于dao，dao依赖于domain 7. 在ssm_parent的pom.xml文件中引入坐标依赖

```java
create database ssm; use ssm; create table account(    id int primary key auto_increment,    name varchar(20),    money double );
```




```pom
<properties>        <spring.version>5.0.2.RELEASE</spring.version>        <slf4j.version>1.6.6</slf4j.version>        <log4j.version>1.2.12</log4j.version>        <mysql.version>5.1.6</mysql.version>        <mybatis.version>3.4.5</mybatis.version>    </properties>
<dependencies>
 
    <!-- spring -->        <dependency>            <groupId>org.aspectj</groupId>            <artifactId>aspectjweaver</artifactId>            <version>1.6.8</version>        </dependency>
 
    <dependency>            <groupId>org.springframework</groupId>            <artifactId>spring-aop</artifactId>            <version>${spring.version}</version>        </dependency>
 
    <dependency>            <groupId>org.springframework</groupId>            <artifactId>spring-context</artifactId>            <version>${spring.version}</version>        </dependency>
 
    <dependency>            <groupId>org.springframework</groupId>            <artifactId>spring-web</artifactId>            <version>${spring.version}</version>        </dependency>
 
    <dependency>            <groupId>org.springframework</groupId>            <artifactId>spring-webmvc</artifactId>            <version>${spring.version}</version>        </dependency>
 
    <dependency>            <groupId>org.springframework</groupId>            <artifactId>spring-test</artifactId>            <version>${spring.version}</version>        </dependency>
 
    <dependency>            <groupId>org.springframework</groupId>            <artifactId>spring-tx</artifactId>            <version>${spring.version}</version>        </dependency>
 
    <dependency>            <groupId>org.springframework</groupId>            <artifactId>spring-jdbc</artifactId>            <version>${spring.version}</version>        </dependency>
 
    <dependency>            <groupId>junit</groupId>            <artifactId>junit</artifactId>
        <version>4.12</version>
        <scope>compile</scope>        </dependency>
 
    <dependency>            <groupId>mysql</groupId>            <artifactId>mysql-connector-java</artifactId>            <version>${mysql.version}</version>        </dependency>
 
    <dependency>            <groupId>javax.servlet</groupId>            <artifactId>servlet-api</artifactId>            <version>2.5</version>            <scope>provided</scope>        </dependency>
 
    <dependency>            <groupId>javax.servlet.jsp</groupId>            <artifactId>jsp-api</artifactId>            <version>2.0</version>            <scope>provided</scope>        </dependency>
 
    <dependency>            <groupId>jstl</groupId>            <artifactId>jstl</artifactId>            <version>1.2</version>        </dependency>
 
    <!-- log start -->        <dependency>            <groupId>log4j</groupId>            <artifactId>log4j</artifactId>            <version>${log4j.version}</version>        </dependency>
 
    <dependency>            <groupId>org.slf4j</groupId>            <artifactId>slf4j-api</artifactId>            <version>${slf4j.version}</version>        </dependency>
 
    <dependency>            <groupId>org.slf4j</groupId>            <artifactId>slf4j-log4j12</artifactId>            <version>${slf4j.version}</version>        </dependency>        <!-- log end -->        <dependency>            <groupId>org.mybatis</groupId>            <artifactId>mybatis</artifactId>            <version>${mybatis.version}</version>
    </dependency>
```
8. 部署ssm_web的项目，只要把ssm_web项目加入到tomcat服务器中即可 5. 编写实体类，在ssm_domain项目中编写


        <dependency>            <groupId>org.mybatis</groupId>            <artifactId>mybatis-spring</artifactId>            <version>1.3.0</version>        </dependency>
     
        <dependency>            <groupId>c3p0</groupId>            <artifactId>c3p0</artifactId>            <version>0.9.1.2</version>            <type>jar</type>            <scope>compile</scope>        </dependency>
     
    </dependencies>    <build>        <finalName>ssm</finalName>        <pluginManagement>            <plugins>                <plugin>                    <groupId>org.apache.maven.plugins</groupId>                    <artifactId>maven-compiler-plugin</artifactId>                    <version>3.2</version>                    <configuration>                        <source>1.8</source>                        <target>1.8</target>                        <encoding>UTF-8</encoding>                        <showWarnings>true</showWarnings>                    </configuration>                </plugin>            </plugins>        </pluginManagement>    </build>


```java
package cn.itcast.domain;

import java.io.Serializable;

public class Account implements Serializable{

private static final long serialVersionUID = 7355810572012650248L;      
    private Integer id; 
    private String name; 
    private Double money;   
    public Integer getId() {
 return id;  
    }
    public void setId(Integer id) {  
        this.id = id;    }   
    public String getName() {     
        return name;    } 
    public void setName(String name) {      
        this.name = name;    }   
    public Double getMoney() {     
        return money;    }
    public void setMoney(Double money) {       
        this.money = money;    } 
}        
```

  6. 编写dao接口

     ```java
     package cn.itcast.dao;
     
     import java.util.List;
     
     import cn.itcast.domain.Account;
     
     public interface AccountDao {        public void saveAccount(Account account);        public List<Account> findAll();
     
     }
     ```

     


7. 编写service接口和实现类

   ```java
   package cn.itcast.dao;
   
   import java.util.List;
   
   import cn.itcast.domain.Account;
   
   public interface AccountDao {        public void saveAccount(Account account);        public List<Account> findAll();
   
   }
   
   package cn.itcast.service;
   
   import java.util.List;
   
   import cn.itcast.domain.Account;
   
   public interface AccountService {
     public void saveAccount(Account account);        public List<Account> findAll();    }
    
   package cn.itcast.service.impl;
    
   import java.util.List;
    
   import org.springframework.stereotype.Service;
    
   import cn.itcast.dao.AccountDao; import cn.itcast.domain.Account; import cn.itcast.service.AccountService;
    
   @Service("accountService") public class AccountServiceImpl implements AccountService {        private AccountDao account;
    
       public void saveAccount(Account account) {    }
    
       public List<Account> findAll() {        System.out.println("业务层：查询所有账户...");        return null;    }
    
   }
   ```




 第二章：Spring框架代码的编写 
1. 搭建和测试Spring的开发环境 
2. 在ssm_web项目中创建applicationContext.xml的配置文件，编写具体的配置信息。

    public void saveAccount(Account account);        public List<Account> findAll();    }

package cn.itcast.service.impl;

import java.util.List;

import org.springframework.stereotype.Service;

import cn.itcast.dao.AccountDao; import cn.itcast.domain.Account; import cn.itcast.service.AccountService;

@Service("accountService") public class AccountServiceImpl implements AccountService {        private AccountDao account;

    public void saveAccount(Account account) {    }
     
    public List<Account> findAll() {        System.out.println("业务层：查询所有账户...");        return null;    }

}

<?xml version="1.0" encoding="UTF-8"?> <beans xmlns="http://www.springframework.org/schema/beans"    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    xmlns:context="http://www.springframework.org/schema/context"    xmlns:aop="http://www.springframework.org/schema/aop"    xmlns:tx="http://www.springframework.org/schema/tx"    xsi:schemaLocation="http://www.springframework.org/schema/beans     http://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/context    http://www.springframework.org/schema/context/spring-context.xsd    http://www.springframework.org/schema/aop    http://www.springframework.org/schema/aop/spring-aop.xsd
2. 在ssm_web项目中编写测试方法，进行测试

## 第三章：Spring整合SpringMVC框架  搭建和测试SpringMVC的开发环境 

1. 在web.xml中配置DispatcherServlet前端控制器

    http://www.springframework.org/schema/tx     http://www.springframework.org/schema/tx/spring-tx.xsd">        <!-- 开启注解扫描，要扫描的是service和dao层的注解，要忽略web层注解，因为web层让SpringMVC框架 去管理 -->    <context:component-scan base-package="cn.itcast">        <!-- 配置要忽略的注解 -->        <context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller"/>    </context:component-scan>    </beans>

package cn.itcast.test;

import org.junit.Test; import org.springframework.context.ApplicationContext; import org.springframework.context.support.ClassPathXmlApplicationContext;

import cn.itcast.service.AccountService;

public class ServiceTest {        @Test    public void run1() {        ApplicationContext ac = new ClassPathXmlApplicationContext("classpath:applicationContext.xml");        AccountService as = (AccountService) ac.getBean("accountService");        as.findAll();    }

}

    <!-- 配置前端控制器：服务器启动必须加载，需要加载springmvc.xml配置文件 -->    <servlet>        <servlet-name>dispatcherServlet</servlet-name>        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>        <!-- 配置初始化参数，创建完DispatcherServlet对象，加载springmvc.xml配置文件 -->        <init-param>

 2. 在web.xml中配置DispatcherServlet过滤器解决中文乱码

3. 创建springmvc.xml的配置文件，编写配置文件

           <param-name>contextConfigLocation</param-name>            <param-value>classpath:springmvc.xml</param-value>        </init-param>        <!-- 服务器启动的时候，让DispatcherServlet对象创建 -->        <load-on-startup>1</load-on-startup>    </servlet>    <servlet-mapping>        <servlet-name>dispatcherServlet</servlet-name>        <url-pattern>/</url-pattern>    </servlet-mapping>
    <!-- 配置解决中文乱码的过滤器 -->    <filter>        <filter-name>characterEncodingFilter</filter-name>        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>        <init-param>            <param-name>encoding</param-name>            <param-value>UTF-8</param-value>        </init-param>    </filter>    <filter-mapping>        <filter-name>characterEncodingFilter</filter-name>        <url-pattern>/*</url-pattern>    </filter-mapping>
<?xml version="1.0" encoding="UTF-8"?> <beans xmlns="http://www.springframework.org/schema/beans"    xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context"    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    xsi:schemaLocation="        http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/mvc        http://www.springframework.org/schema/mvc/spring-mvc.xsd        http://www.springframework.org/schema/context        http://www.springframework.org/schema/context/spring-context.xsd">

    <!-- 扫描controller的注解，别的不扫描 -->    <context:component-scan base-package="cn.itcast">        <context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/>    </context:component-scan>        <!-- 配置视图解析器 -->    <bean id="viewResolver" 
4. 测试SpringMVC的框架搭建是否成功 1. 编写index.jsp和list.jsp编写，超链接


2. 创建AccountController类，编写方法，进行测试

3. Spring整合SpringMVC的框架 
4. 目的：在controller中能成功的调用service对象中的方法。
  class="org.springframework.web.servlet.view.InternalResourceViewResolver">        <!-- JSP文件所在的目录 -->        <property name="prefix" value="/WEB-INF/pages/" />        <!-- 文件的后缀名 -->        <property name="suffix" value=".jsp" />    </bean>

    <!-- 设置静态资源不过滤 -->    <mvc:resources location="/css/" mapping="/css/**" />    <mvc:resources location="/images/" mapping="/images/**" />    <mvc:resources location="/js/" mapping="/js/**" />

    <!-- 开启对SpringMVC注解的支持 -->    <mvc:annotation-driven />

</beans>
<a href="account/findAll">查询所有</a>
package cn.itcast.controller;

import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping;

@Controller @RequestMapping("/account") public class AccountController {        /**     * 查询所有的数据     * @return     */    @RequestMapping("/findAll")    public String findAll() {        System.out.println("表现层：查询所有账户...");        return "list";    }

}

2. 在项目启动的时候，就去加载applicationContext.xml的配置文件，在web.xml中配置 ContextLoaderListener监听器（该监听器只能加载WEB-INF目录下的applicationContext.xml的配置文 件）。

3. 在controller中注入service对象，调用service对象的方法进行测试

  第四章：Spring整合MyBatis框架 
<!-- 配置Spring的监听器 -->    <listener>        <listener-class>org.springframework.web.context.ContextLoaderListener</listenerclass>    </listener>    <!-- 配置加载类路径的配置文件 -->    <context-param>        <param-name>contextConfigLocation</param-name>        <param-value>classpath:applicationContext.xml</param-value>    </context-param>
package cn.itcast.controller;

import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.RequestMapping;

import cn.itcast.service.AccountService;

@Controller @RequestMapping("/account") public class AccountController {        @Autowired    private AccountService accoutService;        /**     * 查询所有的数据     * @return     */    @RequestMapping("/findAll")    public String findAll() {        System.out.println("表现层：查询所有账户...");        accoutService.findAll();        return "list";    }

}

1. 搭建和测试MyBatis的环境 
2. 在web项目中编写SqlMapConﬁg.xml的配置文件，编写核心配置文件

3. 在AccountDao接口的方法上添加注解，编写SQL语句

<?xml version="1.0" encoding="UTF-8"?> <!DOCTYPE configuration    PUBLIC "-//mybatis.org//DTD Config 3.0//EN"    "http://mybatis.org/dtd/mybatis-3-config.dtd"> <configuration>    <environments default="mysql">        <environment id="mysql">            <transactionManager type="JDBC"/>            <dataSource type="POOLED">                <property name="driver" value="com.mysql.jdbc.Driver"/>                <property name="url" value="jdbc:mysql:///ssm"/>                <property name="username" value="root"/>                <property name="password" value="root"/>            </dataSource>        </environment>    </environments>        <!-- 使用的是注解 -->    <mappers>        <!-- <mapper class="cn.itcast.dao.AccountDao"/> -->        <!-- 该包下所有的dao接口都可以使用 -->        <package name="cn.itcast.dao"/>    </mappers> </configuration>
package cn.itcast.dao;

import java.util.List;

import org.apache.ibatis.annotations.Insert; import org.apache.ibatis.annotations.Select;

import cn.itcast.domain.Account;

public interface AccountDao {        @Insert(value="insert into account (name,money) values (#{name},#{money})")    public void saveAccount(Account account);        @Select("select * from account")    public List<Account> findAll();

}

3. 编写测试的方法
   package cn.itcast.test;

import java.io.InputStream; import java.util.List;

import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.junit.Test;

import cn.itcast.dao.AccountDao; import cn.itcast.domain.Account;

public class Demo1 {        @Test    public void run1() throws Exception {        // 加载配置文件        InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml");        // 创建工厂        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream);        // 创建sqlSession对象        SqlSession session = factory.openSession();        // 获取代理对象        AccountDao dao = session.getMapper(AccountDao.class);        // 调用查询的方法        List<Account> list = dao.findAll();        for (Account account : list) {            System.out.println(account);        }        // 释放资源        session.close();        inputStream.close();    }        @Test    public void run2() throws Exception {        Account account = new Account();        account.setName("熊大");        account.setMoney(400d);                // 加载配置文件        InputStream inputStream = Resources.getResourceAsStream("SqlMapConfig.xml");        // 创建工厂        SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream);        // 创建sqlSession对象        SqlSession session = factory.openSession();                // 获取代理对象        AccountDao dao = session.getMapper(AccountDao.class);

 2. Spring整合MyBatis框架 
3. 目的：把SqlMapConﬁg.xml配置文件中的内容配置到applicationContext.xml配置文件中

4. 在AccountDao接口中添加@Repository注解 3. 在service中注入dao对象，进行测试 4. 代码如下

           dao.saveAccount(account);                // 提交事务        session.commit();        // 释放资源        session.close();        inputStream.close();    }

}


    <!-- 配置C3P0的连接池对象 -->    <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">        <property name="driverClassName" value="com.mysql.jdbc.Driver" />        <property name="url" value="jdbc:mysql:///ssm" />        <property name="username" value="root" />        <property name="password" value="root" />    </bean>
     
    <!-- 配置SqlSession的工厂 -->    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">        <property name="dataSource" ref="dataSource" />    </bean>        <!-- 配置扫描dao的包 -->    <bean id="mapperScanner" class="org.mybatis.spring.mapper.MapperScannerConfigurer">        <property name="basePackage" value="cn.itcast.dao"/>    </bean>

package cn.itcast.dao;

import java.util.List;

import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Select;
import org.springframework.stereotype.Repository;

import cn.itcast.domain.Account;

@Repository public interface AccountDao {        @Insert(value="insert into account (name,money) values (#{name},#{money})")    public void saveAccount(Account account);        @Select("select * from account")    public List<Account> findAll();

}

  package cn.itcast.service.impl;

   import java.util.List;

   import org.springframework.beans.factory.annotation.Autowired;

   import org.springframework.stereotype.Service;

   import cn.itcast.dao.AccountDao;

   import cn.itcast.domain.Account;

   import cn.itcast.service.AccountService;

   @Service("accountService")

   public class AccountServiceImpl implements AccountService {

​    

    @Autowired
     
    private AccountDao accountDao;
     
    public void saveAccount(Account account) {
     
    }
     
    public List<Account> findAll() {
     
        System.out.println("业务层：查询所有账户...");
     
        return accountDao.findAll();
     
    }

   }



   package cn.itcast.controller;

   import java.util.List;

   import org.springframework.beans.factory.annotation.Autowired;

   import org.springframework.stereotype.Controller;

   import org.springframework.web.bind.annotation.RequestMapping;

   import cn.itcast.domain.Account;

   import cn.itcast.service.AccountService;

   @Controller

   @RequestMapping("/account")

   public class AccountController {

​    

    @Autowired
     
    private AccountService accoutService;


​    

    /**
     
     *  查询所有的数据         * @return            */            @RequestMapping("/findAll")            public String findAll() {                System.out.println("表现层：查询所有账户...");                List<Account> list = accoutService.findAll();                for (Account account : list) {                    System.out.println(account);                }                return "list";            }

   }


​    

5. 配置Spring的声明式事务管理



<tx:advice id="txAdvice" transaction-manager="transactionManager"> tx:attributes
<tx:method name="ﬁnd*" read-only="true"/> <tx:method name="*" isolation="DEFAULT"/>
/tx:attributes /tx:advice aop:conﬁg
<aop:advisor advice-ref="txAdvice" pointcut="execution(public * cn.itcast.service..ServiceImpl.*(..))"/> /aop:conﬁg

姓名： 
金额： 
保存 
@RequestMapping("/saveAccount") public String saveAccount(Account account) { accoutService.saveAccount(account); return "list"; }



 

 

 

 

# **全文检索技术**Lucene****

## 什么是全文检索

## 2.1    数据分类

我们生活中的数据总体分为两种：结构化数据和非结构化数据。

结构化数据：指具有固定格式或有限长度的数据，如数据库，元数据等。

非结构化数据：指不定长或无固定格式的数据，如邮件，word文档等磁盘上的文件

## 2.2    结构化数据搜索

常见的结构化数据也就是数据库中的数据。在数据库中搜索很容易实现，通常都是使用sql语句进行查询，而且能很快的得到查询结果。

为什么数据库搜索很容易？

因为数据库中的数据存储是有规律的，有行有列 而且数据格式、数据长度都是固定的。

## 2.3    非结构化数据查询方法

**（1）****顺序扫描法****(Serial Scanning)**

所谓顺序扫描，比如要找内容包含某一个字符串的文件，就是一个文档一个文档的看，对于每一个文档，从头看到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件。如利用windows的搜索也可以搜索文件内容，只是相当的慢。

**（2）****全文检索****(Full-text Search)**

将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之**索引**。

例如：字典。字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据——也即对字的解释。

**这种先建立索引，再对索引进行搜索的过程就叫全文检索****(Full-text Search)****。**

虽然创建索引的过程也是非常耗时的，但是索引一旦创建就可以多次使用，全文检索主要处理的是查询，所以耗时间创建索引是值得的。

## 2.4    如何实现全文检索

可以使用Lucene实现全文检索。Lucene是apache下的一个开放源代码的全文检索引擎工具包。提供了完整的查询引擎和索引引擎，部分文本分析引擎。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能。

 

## 2.5    全文检索的应用场景

对于数据量大、数据结构不固定的数据可采用全文检索方式搜索，比如百度、Google等搜索引擎、论坛站内搜索、电商网站站内搜索等。

# 3   Lucene实现全文检索的流程

## 3.1    索引和搜索流程图

![img](file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image002.jpg)

1、绿色表示索引过程，对要搜索的原始内容进行索引构建一个索引库，索引过程包括：

确定原始内容即要搜索的内容à采集文档à创建文档à分析文档à索引文档

​         

2、红色表示搜索过程，从索引库中搜索内容，搜索过程包括：

用户通过搜索界面à创建查询à执行搜索，从索引库搜索à渲染搜索结果

## 3.2    创建索引

对文档索引的过程，将用户要搜索的文档内容进行索引，索引存储在索引库（index）中。

这里我们要搜索的文档是磁盘上的文本文件，根据案例描述：凡是文件名或文件内容包括关键字的文件都要找出来，这里要对文件名和文件内容创建索引。

### 3.2.1 获得原始文档

**原始文档**是指要索引和搜索的内容。原始内容包括互联网上的网页、数据库中的数据、磁盘上的文件等。 

本案例中的原始内容就是磁盘上的文件，如下图：

 

![img](file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image004.jpg)

从互联网上、数据库、文件系统中等获取需要搜索的原始信息，这个过程就是信息采集，信息采集的目的是为了对原始内容进行索引。

在Internet上采集信息的软件通常称为爬虫或蜘蛛，也称为网络机器人，爬虫访问互联网上的每一个网页，将获取到的网页内容存储起来。

本案例我们要获取磁盘上文件的内容，可以通过文件流来读取文本文件的内容，对于pdf、doc、xls等文件可通过第三方提供的解析工具读取文件内容，比如Apache POI读取doc和xls的文件内容。

 

### 3.2.2 创建文档对象

获取原始内容的目的是为了索引，在索引前需要将原始内容创建成文档（Document），文档中包括一个一个的域（Field），域中存储内容。

这里我们可以将磁盘上的一个文件当成一个document，Document中包括一些Field（file_name文件名称、file_path文件路径、file_size文件大小、file_content文件内容），如下图：

 

![img](file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image005.gif)

注意：每个Document可以有多个Field，不同的Document可以有不同的Field，同一个Document可以有相同的Field（域名和域值都相同）

 

每个文档都有一个唯一的编号，就是文档id。

### 3.2.3 分析文档

将原始内容创建为包含域（Field）的文档（document），需要再对域中的内容进行分析，分析的过程是经过对原始文档提取单词、将字母转为小写、去除标点符号、去除停用词等过程生成最终的语汇单元，可以将语汇单元理解为一个一个的单词。

 

比如下边的文档经过分析如下：

原文档内容：

Lucene is a Java full-text search engine.  Lucene is not a complete

application, but rather a code library and API that can easily be used

to add search capabilities to applications.

 

分析后得到的语汇单元：

lucene、java、full、search、engine。。。。

 

每个单词叫做一个Term，不同的域中拆分出来的相同的单词是不同的term。term中包含两部分一部分是文档的域名，另一部分是单词的内容。

例如：文件名中包含apache和文件内容中包含的apache是不同的term。

### 3.2.4 创建索引

对所有文档分析得出的语汇单元进行索引，索引的目的是为了搜索，最终要实现只搜索被索引的语汇单元从而找到Document（文档）。

  

|      |                                                              |
| ---- | ------------------------------------------------------------ |
|      | ![img](file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image006.gif) |

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

注意：创建索引是对语汇单元索引，通过词语找文档，这种索引的结构叫**倒排索引结构**。

传统方法是根据文件找到该文件的内容，在文件内容中匹配搜索关键字，这种方法是顺序扫描方法，数据量大、搜索慢。

**倒排索引结构**是根据内容（词语）找文档，如下图： 

![IMG_256](file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image008.jpg)

 

**倒排索引结构也叫反向索引结构，包括索引和文档两部分，索引即词汇表，它的规模较小，而文档集合较大。**

## 3.3    查询索引

查询索引也是搜索的过程。搜索就是用户输入关键字，从索引（index）中进行搜索的过程。根据关键字搜索索引，根据索引找到对应的文档，从而找到要搜索的内容（这里指磁盘上的文件）。 

### 3.3.1 用户查询接口

全文检索系统提供用户搜索的界面供用户提交搜索的关键字，搜索完成展示搜索结果。

 

比如：

![img](file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image010.jpg)

 

Lucene不提供制作用户搜索界面的功能，需要根据自己的需求开发搜索界面。

### 3.3.2 创建查询

用户输入查询关键字执行搜索之前需要先构建一个查询对象，查询对象中可以指定查询要搜索的Field文档域、查询关键字等，查询对象会生成具体的查询语法，

例如：

语法 “fileName:lucene”表示要搜索Field域的内容为“lucene”的文档

 

### 3.3.3 执行查询

搜索索引过程：

根据查询语法在倒排索引词典表中分别找出对应搜索词的索引，从而找到索引所链接的文档链表。

比如搜索语法为“fileName:lucene”表示搜索出fileName域中包含Lucene的文档。

搜索过程就是在索引上查找域为fileName，并且关键字为Lucene的term，并根据term找到文档id列表。

 

![IMG_256](file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image011.jpg)

 

### 3.3.4 渲染结果

以一个友好的界面将查询结果展示给用户，用户根据搜索结果找自己想要的信息，为了帮助用户很快找到自己的结果，提供了很多展示的效果，比如搜索结果中将关键字高亮显示，百度提供的快照等。

![img](file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image013.jpg)

 

 

# 4   配置开发环境

## 4.1    Lucene下载

Lucene是开发全文检索功能的工具包，从官方网站下载lucene-7.4.0，并解压。

![img](file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image015.jpg)

官方网站：<http://lucene.apache.org/> 

版本：lucene-7.4.0

Jdk要求：1.8以上

## 4.2    使用的jar包

lucene-core-7.4.0.jar

![img](file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image017.jpg)

lucene-analyzers-common-7.4.0.jar

![img](file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image019.jpg)

# 5   入门程序

## 5.1    需求

实现一个文件的搜索功能，通过关键字搜索文件，凡是文件名或文件内容包括关键字的文件都需要找出来。还可以根据中文词语进行查询，并且需要支持多个条件查询。

本案例中的原始内容就是磁盘上的文件，如下图：

![img](file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image021.jpg)

 

## 5.2    创建索引

### 5.2.1 实现步骤

第一步：创建一个java工程，并导入jar包。

第二步：创建一个indexwriter对象。

1）指定索引库的存放位置Directory对象

2）指定一个IndexWriterConfig对象。

第二步：创建document对象。

第三步：创建field对象，将field添加到document对象中。

第四步：使用indexwriter对象将document对象写入索引库，此过程进行索引创建。并将索引和document对象写入索引库。

第五步：关闭IndexWriter对象。

### 5.2.2 代码实现

 

### 5.2.3 使用Luke工具查看索引文件

![img](file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image023.jpg)

我们使用的luke的版本是luke-7.4.0，跟lucene的版本对应的。可以打开7.4.0版本的lucene创建的索引库。需要注意的是此版本的Luke是jdk9编译的，所以要想运行此工具还需要jdk9才可以。

 

 

## 5.3    查询索引

### 5.3.1 实现步骤

第一步：创建一个Directory对象，也就是索引库存放的位置。

第二步：创建一个indexReader对象，需要指定Directory对象。

第三步：创建一个indexsearcher对象，需要指定IndexReader对象

第四步：创建一个TermQuery对象，指定查询的域和查询的关键词。

第五步：执行查询。

第六步：返回查询结果。遍历查询结果并输出。

第七步：关闭IndexReader对象

 

### 5.3.2 代码实现

# 6   分析器

## 6.1    分析器的分词效果

 

## 6.2    中文分析器

### 6.2.1 Lucene自带中文分词器

l  StandardAnalyzer：

单字分词：就是按照中文一个字一个字地进行分词。如：“我爱中国”，
 效果：“我”、“爱”、“中”、“国”。

l  SmartChineseAnalyzer

对中文支持较好，但扩展性差，扩展词库，禁用词库和同义词库等不好处理

### 6.2.2 IKAnalyzer

![img](file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image025.jpg)

使用方法：

第一步：把jar包添加到工程中

第二步：把配置文件和扩展词典和停用词词典添加到classpath下

 

注意：hotword.dic和ext_stopword.dic文件的格式为UTF-8，注意是无BOM 的UTF-8 编码。

也就是说禁止使用windows记事本编辑扩展词典文件

 

使用EditPlus.exe保存为无BOM 的UTF-8 编码格式，如下图：

![img](file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image027.jpg)

## 6.3    使用自定义分析器

 

# 7   索引库的维护

## 7.1    索引库的添加

### 7.1.1 Field域的属性

**是否分析**：是否对域的内容进行分词处理。前提是我们要对域的内容进行查询。

**是否索引**：将Field分析后的词或整个Field值进行索引，只有索引方可搜索到。

比如：商品名称、商品简介分析后进行索引，订单号、身份证号不用分析但也要索引，这些将来都要作为查询条件。

**是否存储**：将Field值存储在文档中，存储在文档中的Field才可以从Document中获取

比如：商品名称、订单号，凡是将来要从Document中获取的Field都要存储。

 

**是否存储的标准：是否要将内容展示给用户**

 

| Field类                                                      | 数据类型               | Analyzed   是否分析 | Indexed   是否索引 | Stored   是否存储 | 说明                                                         |
| ------------------------------------------------------------ | ---------------------- | ------------------- | ------------------ | ----------------- | ------------------------------------------------------------ |
| StringField(FieldName,   FieldValue,Store.YES))              | 字符串                 | N                   | Y                  | Y或N              | 这个Field用来构建一个字符串Field，但是不会进行分析，会将整个串存储在索引中，比如(订单号,姓名等)   是否存储在文档中用Store.YES或Store.NO决定 |
| LongPoint(String name, long... point)                        | Long型                 | Y                   | Y                  | N                 | 可以使用LongPoint、IntPoint等类型存储数值类型的数据。让数值类型可以进行索引。但是不能存储数据，如果想存储数据还需要使用StoredField。 |
| StoredField(FieldName, FieldValue)                           | 重载方法，支持多种类型 | N                   | N                  | Y                 | 这个Field用来构建不同类型Field   不分析，不索引，但要Field存储在文档中 |
| TextField(FieldName, FieldValue, Store.NO)   或   TextField(FieldName, reader) | 字符串   或   流       | Y                   | Y                  | Y或N              | 如果是一个Reader, lucene猜测内容比较多,会采用Unstored的策略. |

 

 

### 7.1.2 添加文档代码实现

## 7.2    索引库删除

### 7.2.1 删除全部

 

说明：将索引目录的索引信息全部删除，直接彻底删除，无法恢复。

 

**此方法慎用！！**

 

### 7.2.2 指定查询条件删除

 

## 7.3    索引库的修改

原理就是先删除后添加。

# 8   Lucene索引库查询

​         对要搜索的信息创建Query查询对象，Lucene会根据Query查询对象生成最终的查询语法，类似关系数据库Sql语法一样Lucene也有自己的查询语法，比如：“name:lucene”表示查询Field的name为“lucene”的文档信息。

​         可通过两种方法创建查询对象：

​         1）使用Lucene提供Query子类

​         2）使用QueryParse解析查询表达式

## 8.1       TermQuery

TermQuery，通过项查询，TermQuery不使用分析器所以建议匹配不分词的Field域查询，比如订单号、分类ID号等。

指定要查询的域和要查询的关键词。

## 8.2    数值范围查询

 

## 8.3    使用queryparser查询

通过QueryParser也可以创建Query，QueryParser提供一个Parse方法，此方法可以直接根据查询语法来查询。Query对象执行的查询语法可通过System.out.println(query);查询。

需要使用到分析器。建议创建索引时使用的分析器和查询索引时使用的分析器要一致。

需要加入queryParser依赖的jar包。

![img](file:///C:/Users/lenovo/AppData/Local/Temp/msohtmlclip1/01/clip_image029.jpg)

 









# Spring Security

​	

### 最简单 Demo 

（1）创建工程 spring-security-demo ,pom.xml 内容 

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 
http://maven.apache.org/maven-v4_0_0.xsd"> 
 <modelVersion>4.0.0</modelVersion> 
 <groupId>cn.itcast.demo</groupId> 
 <artifactId>spring-security-demo</artifactId> 
    <packaging>war</packaging> 
 <version>0.0.1-SNAPSHOT</version> 
 <properties> 
  <spring.version>4.2.4.RELEASE</spring.version> 
 </properties> 
 <dependencies> 
  <dependency> 
   <groupId>org.springframework</groupId> 
   <artifactId>spring-core</artifactId> 
   <version>${spring.version}</version> 
  </dependency> 
  <dependency> 
   <groupId>org.springframework</groupId> 
   <artifactId>spring-web</artifactId> 
   <version>${spring.version}</version> 
  </dependency> 
  <dependency> 
   <groupId>org.springframework</groupId> 
   <artifactId>spring-webmvc</artifactId> 
   <version>${spring.version}</version> 
  </dependency> 
  <dependency> 
   <groupId>org.springframework</groupId> 
      <artifactId>spring-context-support</artifactId> 
   <version>${spring.version}</version> 
  </dependency> 
  <dependency> 
   <groupId>org.springframework</groupId> 
   <artifactId>spring-test</artifactId> 
   <version>${spring.version}</version> 
  </dependency> 
  <dependency> 
   <groupId>org.springframework</groupId> 
   <artifactId>spring-jdbc</artifactId> 
   <version>${spring.version}</version> 
  </dependency> 
  <dependency> 
   <groupId>org.springframework.security</groupId> 
   <artifactId>spring-security-web</artifactId> 
   <version>4.1.0.RELEASE</version> 
  </dependency> 
  <dependency> 
   <groupId>org.springframework.security</groupId> 
   <artifactId>spring-security-config</artifactId> 
   <version>4.1.0.RELEASE</version> 
  </dependency> 
      <dependency> 
   <groupId>javax.servlet</groupId> 
   <artifactId>servlet-api</artifactId> 
   <version>2.5</version> 
   <scope>provided</scope> 
  </dependency> 
 </dependencies> 
 <build> 
   <plugins>   
       <!-- java 编译插件 --> 
    <plugin> 
    <groupId>org.apache.maven.plugins</groupId> 
    <artifactId>maven-compiler-plugin</artifactId> 
    <version>3.2</version> 
    <configuration> 
     <source>1.7</source> 
     <target>1.7</target> 
     <encoding>UTF-8</encoding> 
    </configuration> 
    </plugin>       
       <plugin> 
    <groupId>org.apache.tomcat.maven</groupId> 
    <artifactId>tomcat7-maven-plugin</artifactId> 
           <configuration> 
     <!-- 指定端口 --> 
     <port>9090</port> 
     <!-- 请求路径 --> 
     <path>/</path> 
    </configuration> 
      </plugin> 
    </plugins>   
    </build> 
</project> 
```





（2）创建 web.xml 

#####  

```xml
<?xml version="1.0" encoding="UTF-8"?> 
<web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
 xmlns="http://java.sun.com/xml/ns/javaee" 
 xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 
http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" 
 version="2.5">   
    <context-param> 
  <param-name>contextConfigLocation</param-name> 
  <param-value>classpath:spring-security.xml</param-value> 
  </context-param> 
  <listener> 
  <listener-class> 
   org.springframework.web.context.ContextLoaderListener 
       </listener-class> 
  </listener>  
  <filter>   
  <filter-name>springSecurityFilterChain</filter-name>     
<filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>   
  </filter>   
  <filter-mapping>   
  <filter-name>springSecurityFilterChain</filter-name>   
  <url-pattern>/*</url-pattern>   
  </filter-mapping>  
</web-app> 
```





​    

####  

  

（3）创建 index.html   内容略 
（4）创建 spring 配置文件 spring-security.xml 

```xml
<?xml version="1.0" encoding="UTF-8"?> 
<beans:beans xmlns="http://www.springframework.org/schema/security" 
 xmlns:beans="http://www.springframework.org/schema/beans" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
 xsi:schemaLocation="http://www.springframework.org/schema/beans 
http://www.springframework.org/schema/beans/spring-beans.xsd 
      http://www.springframework.org/schema/security 
http://www.springframework.org/schema/security/spring-security.xsd"> 

 <!-- 页面拦截规则 --> 
 <http use-expressions="false"> 
  <intercept-url pattern="/**" access="ROLE_USER" /> 
      <form-login/>  
 </http> 
 
 <!-- 认证管理器 --> 
 <authentication-manager> 
  <authentication-provider> 
   <user-service> 
    <user name="admin" password="123456" authorities="ROLE_USER"/> 
   </user-service>   
  </authentication-provider>  
 </authentication-manager> 
</beans:beans> 
```



   





此案例我们没有登录页，而是使用了系统自动生成的登陆页，效果如下： 

![1564060056178](C:\Users\lenovo\AppData\Local\Temp\1564060056178.png)









 配置说明： 
intercept-url 表示拦截页面    
/*  表示的是该目录下的资源，只包括本级目录不包括下级目录 
/** 表示的是该目录以及该目录下所有级别子目录的资源 
form-login  为开启表单登陆 
use-expressions 为是否使用使用 Spring 表达式语言（ SpEL ），默认为 true ,如果开启，则拦截的配置应该写成以下形式 



```xml
<intercept-url pattern="/**" access="hasRole('ROLE_USER')" /> 
```

#### 1.2.2 用户自定义登录页 

实际开发中，我们不可能使用系统生成的登录页，而是使用我们自己的登录页。 
（1）构建登陆页： 

```html
<!DOCTYPE html> 
<html> 
<head> 
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> 
<title>登陆</title> 
</head> 
<body>  
 <form action='/login' method='POST'> 
  <table> 
   <tr> 
    <td>用户名:</td> 
    <td><input type='text' name='username' value=''></td> 
   </tr> 
   <tr> 
    <td>密码:</td> 
    <td><input type='password' name='password' /></td> 
   </tr> 
      <tr> 
    <td colspan='2'><input name="submit" type="submit" 
     value=" 登陆 " /></td> 
   </tr> 
  </table> 
 </form> 
</body> 
</html> 
```

（2）构建登陆失败页  login_error.html（内容略） 
（3）修改 spring 配置文件 spring-security.xml 

```html
<!-- 以下页面不被拦截 --> 
 <http pattern="/login.html" security="none"></http> 
 <http pattern="/login_error.html" security="none"></http> 
 <!-- 页面拦截规则 --> 
 <http use-expressions="false"> 
  <intercept-url pattern="/*" access="ROLE_USER" /> 
  <form-login login-page="/login.html" default-target-url="/index.html" 
authentication-failure-url="/login_error.html"/>  
  <csrf disabled="true"/> 
 </http> 
```

security="none"  设置此资源不被拦截.  如果你没有设置登录页 security="none"  ，将会出现以下错误 

![1564060205372](C:\Users\lenovo\AppData\Local\Temp\1564060205372.png)

因为登录页会被反复重定向。 
login-page：指定登录页面。 authentication-failure-url：指定了身份验证失败时跳转到的页面。 default-target-url：指定了成功进行身份验证和授权后默认呈现给用户的页面。 
csrf disabled="true"  关闭 csrf ,如果不加会出现错误 

![1564060236358](C:\Users\lenovo\AppData\Local\Temp\1564060236358.png)

CSRF（Cross-site request forgery）跨站请求伪造，也被称为“One Click Attack”或者 Session Riding，通常缩写为 CSRF 或者 XSRF，是一种对网站的恶意利用。 





## 一    hibernate

概述：Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。

	orm思想
		主要目的：操作实体类就相当于操作数据库表
		建立两个映射关系：
			实体类和表的映射关系
			实体类中属性和表中字段的映射关系
		不再重点关注：sql语句
	实现了ORM思想的框架：mybatis，hibernate

